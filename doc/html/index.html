<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<meta http-equiv="cache-control" content="no-cache">
<title>RE/flex user guide</title>
<link href="doxygen_tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="doxygen_content.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top">
 <div id="titlearea">
  <table height="72px" width="100%" cellspacing="0" cellpadding="0">
   <tbody>
    <tr>
     <td width="10%">&nbsp;</td>
     <td><a href="https://github.com/Genivia/RE-flex"><img src="reflex-logo.png"/></a></td>
     <td>
      <div style="float: right; font-size: 18px; font-weight: bold;">RE/flex user guide</div>
      <br>
      <div style="float: right; font-size: 10px;">updated Sun Apr 9 2017 by Robert van Engelen</div>
     </td>
     <td width="10%">&nbsp;</td>
    </tr>
   </tbody>
  </table>
 </div>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RE/flex user guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro">What is RE/flex?                                                       </a><ul><li class="level2"><a href="#intro1">Yet another scanner generator                                         </a></li>
<li class="level2"><a href="#intro2">A flexible regex library                                              </a></li>
</ul>
</li>
<li class="level1"><a href="#reflex">The RE/flex scanner generator                                         </a><ul><li class="level2"><a href="#reflex-command">The reflex command line tool                                  </a></li>
<li class="level2"><a href="#reflex-options">Command-line options                                          </a><ul><li class="level3"><a href="#reflex-options-scanner">Scanner options</a></li>
<li class="level3"><a href="#reflex-options-files">Output files options</a></li>
<li class="level3"><a href="#reflex-options-code">Output code options</a></li>
<li class="level3"><a href="#reflex-options-debug">Debugging options</a></li>
<li class="level3"><a href="#reflex-options-miscellaneous">Miscellaneous options</a></li>
</ul>
</li>
<li class="level2"><a href="#reflex-spec">Lexer specifications                                             </a><ul><li class="level3"><a href="#reflex-spec-defs">The definitions section</a></li>
<li class="level3"><a href="#reflex-spec-rules">The rules section</a></li>
<li class="level3"><a href="#reflex-spec-user">User code sections</a></li>
</ul>
</li>
<li class="level2"><a href="#reflex-patterns">Patterns                                                     </a><ul><li class="level3"><a href="#reflex-pattern-syntax">Pattern syntax</a></li>
<li class="level3"><a href="#reflex-pattern-class">Character classes</a></li>
<li class="level3"><a href="#reflex-patterns-cat">Character categories</a></li>
<li class="level3"><a href="#reflex-pattern-anchor">Anchors and boundaries</a></li>
<li class="level3"><a href="#reflex-pattern-dents">Indent/nodent/dedent</a></li>
<li class="level3"><a href="#reflex-pattern-lookahead">Lookahead/lookbehind</a></li>
<li class="level3"><a href="#reflex-pattern-unicode">Unicode mode</a></li>
<li class="level3"><a href="#reflex-pattern-freespace">Free space mode</a></li>
<li class="level3"><a href="#reflex-pattern-multiline">Multi-line mode</a></li>
<li class="level3"><a href="#reflex-pattern-dotall">Dotall mode</a></li>
<li class="level3"><a href="#reflex-pattern-anycase">Case-insensitive mode</a></li>
</ul>
</li>
<li class="level2"><a href="#reflex-lexer">The Lexer/yyFlexLexer class                                     </a></li>
<li class="level2"><a href="#reflex-inherit">Inheriting Lexer/yyFlexLexer                                  </a></li>
<li class="level2"><a href="#reflex-multiple">Combining multiple lexers                                    </a></li>
<li class="level2"><a href="#reflex-input">Switching input sources                                         </a></li>
<li class="level2"><a href="#reflex-states">Start condition states                                         </a></li>
<li class="level2"><a href="#reflex-bison">Interfacing with Bison/Yacc                                     </a></li>
<li class="level2"><a href="#reflex-posix-perl">POSIX versus Perl matching                                 </a></li>
<li class="level2"><a href="#reflex-examples">Examples                                                     </a></li>
<li class="level2"><a href="#reflex-limitations">Limitations                                               </a></li>
</ul>
</li>
<li class="level1"><a href="#regex">The RE/flex regex library                                              </a><ul><li class="level2"><a href="#regex-boost">Boost matcher classes                                            </a></li>
<li class="level2"><a href="#regex-std">std::regex matcher classes                                         </a></li>
<li class="level2"><a href="#regex-matcher">The RE/flex matcher class                                      </a></li>
<li class="level2"><a href="#regex-pattern">The RE/flex pattern class                                      </a></li>
<li class="level2"><a href="#regex-convert">Regex converters                                               </a></li>
<li class="level2"><a href="#regex-methods">Methods and iterators                                          </a><ul><li class="level3"><a href="#regex-methods-matches">matches</a></li>
<li class="level3"><a href="#regex-methods-find">find</a></li>
<li class="level3"><a href="#regex-methods-scan">scan</a></li>
<li class="level3"><a href="#regex-methods-split">split</a></li>
<li class="level3"><a href="#regex-methods-props">Properties of a match</a></li>
<li class="level3"><a href="#regex-members">Public data members</a></li>
<li class="level3"><a href="#regex-methods-pattern">Pattern methods</a></li>
<li class="level3"><a href="#regex-methods-input">Input methods</a></li>
</ul>
</li>
<li class="level2"><a href="#regex-input">The Input class                                                  </a><ul><li class="level3"><a href="#regex-input-assign">Assigning input</a></li>
<li class="level3"><a href="#regex-input-methods">Input methods</a></li>
<li class="level3"><a href="#regex-input-file">FILE encodings</a></li>
</ul>
</li>
<li class="level2"><a href="#regex-examples">Examples                                                      </a></li>
</ul>
</li>
<li class="level1"><a href="#tricks">Tips, tricks and gotchas                                              </a><ul><li class="level2"><a href="#invalid-utf">Invalid UTF encodings                                            </a></li>
<li class="level2"><a href="#lazy">Lazy repetitions                                                        </a></li>
<li class="level2"><a href="#switching">Repeately switching to the same input                              </a></li>
<li class="level2"><a href="#flexlexer">Where is FlexLexer.h?                                              </a></li>
<li class="level2"><a href="#readline">Interactive input with GNU readline                                 </a></li>
</ul>
</li>
<li class="level1"><a href="#download">Getting RE/flex                                                     </a></li>
<li class="level1"><a href="#license">License and copyright                                                </a></li>
</ul>
</div>
<div class="textblock"><p>"The asteroid to kill this dinosaur is still in orbit." &ndash; Lex Manual</p>
<p>"Optimize: this currently has no effect in Boost.Regex." &ndash; Boost Manual</p>
<p>"Reflex: a thing that is determined by and reproduces
   the essential features or qualities of something else." &ndash; Oxford Dictionary</p>
<h1><a class="anchor" id="intro"></a>
What is RE/flex?                                                       </h1>
<p>RE/flex is a flexible scanner-generator framework for generating regex-centric, Flex-compatible scanners. The RE/flex command-line tool is compatible with the Flex command-line tool. RE/flex accepts standard Flex specification syntax and supports Flex options.</p>
<p>Features:</p>
<ul>
<li>integrated support for Unicode, auto-detects BOM in files (UTF-8/16/32);</li>
<li>optional "free space mode" improves readability of lexer specifications;</li>
<li>regular expressions may contain lazy quantifiers;</li>
<li>regular expressions may contain word boundary anchors;</li>
<li>regular expressions may contain indent/dedent markers for matching;</li>
<li>intuitive customization of the C++ lexer class code output;</li>
<li>efficient matching in direct code or with finite state machine tables;</li>
<li>visualization of finite state machines;</li>
<li>generates scanners that are thread-safe by default;</li>
<li>works with Bison and supports reentrant, bison-bridge and bison-locations;</li>
<li>includes a regex class library that is extensible;</li>
<li>Boost.Regex can be used as a regex engine;</li>
<li>C++11 std::regex can be used as a regex engine (but not with a scanner);</li>
<li>conversion of regex expressions, for regex engines that lack regex features;</li>
<li>released under a permissive open source license (BSD-3).</li>
</ul>
<p>RE/flex is not merely designed to fix the limitations of Flex and Lex! RE/flex balances efficiency with flexibility by offering a choice of regex engines that are used by the generated scanner. The choice includes Boost.Regex and RE/flex matcher engines that offer a rich regex syntax. The RE/flex POSIX matcher adds lazy quantifiers, word boundary anchors, and other useful patterns to the POSIX mode of matching. Also Unicode character sets and ASCII/UTF-8/16/32 file input is supported by RE/flex, without any additional coding required. RE/flex regex patterns are converted to efficient deterministic finite state machines. These machines differ from Flex in supporting the new pattern-matching features.</p>
<p>RE/flex incorporates proper object-oriented design principles and does not rely on macros and globals as Flex does. Macros and globals are only added when the Flex-compatibility option <code>−−flex</code> is used when invoking the <b>reflex</b> scanner generator. However, in all cases the <b>reflex</b> scanner generator produces C++ scanner classes derived from a base lexer class template, with a matcher engine as the template parameter. This offers an extensible approach that permits new regex matching engines to be included in this framework in the future.</p>
<p>Use the <b>reflex</b> scanner generator with two options <code>−−flex</code> and <code>−−bison</code> to output Flex C-compatible code. These options generate the global non-reentrant "yy" functions and variables, such as <code>yylex()</code> and <code>yytext</code>.</p>
<p>In this document we refer to a <em>regex</em> as a shorthand for <em>regular expression</em>. Some of you may not agree with this broad use of terminology. The term regular expressions refers to the formal concept of <em>regular languages</em>, wheras <em>regex</em> refers to backtracking-based regex matching that Perl introduced, that could no longer be said to be regular in a true mathematical sense.</p>
<p>In summary, RE/flex is</p>
<ul>
<li>a <em>feature-rich replacement</em> of both <a href="dinosaur.compilertools.net/#flex">Flex</a> and <a href="dinosaur.compilertools.net/#lex">Lex</a>, preserving the compatibility with the Bison (Yacc) parser generators;</li>
<li>an <em>enhancement</em> of <a href="www.boost.org/libs/regex">Boost.Regex</a> to use its engine for matching, seaching, splitting and for scanning of tokens on various types of data sources, such as strings, files, and streams of unlimited length.</li>
<li>a stand-alone <em>regex library</em> is included with RE/flex for fast matching with efficient deterministic finite state machines (FSMs) that are contructed from regex patterns with POSIX mode matching extended to support lazy quantifiers, word boundary anchors, Unicode UTF-8, and much more;</li>
<li>a <em>flexible regex framework</em> that combines the above with a collection of C++ class templates that are easy to use and that offer a rich API for searching, matching, scanning, and splitting of input strings, files and streaming data. This framework is flexible and can be extended to include other regex pattern matchers that can operate seamlessly with the RE/flex scanner generator.</li>
</ul>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="intro1"></a>
Yet another scanner generator                                         </h2>
<p>Lex, Flex and variants are powerful <em>scanner generators</em> that generate scanners (a.k.a. <em>lexical analyzers</em> and <em>lexers</em>) from lexer specifications. The lexer specifications define patterns with user-defined actions that are executed when their patterns match the input stream. The scanner repeatedly matches patterns and triggers these actions until the end of the input stream is reached.</p>
<p>Both Lex and Flex are popular to develop <em>tokenizers</em> in which the user-defined actions emit or return a <em>token</em> when the corresponding pattern matches. These tokenizers are typically implemented to scan and tokenize the source code for a compiler or an interpreter of a programming language. The <em>regular expression</em> patterns in a tokenizer define the make-up of identifiers, constants, keywords, punctuation, and to skip over white space in the source code that is scanned.</p>
<p>Consider for example the following patterns and associated actions defined in a lexer specification:</p>
<div class="alt"> <div class="fragment"><div class="line">%%</div><div class="line"><span class="comment">/* PATTERN */</span>           <span class="comment">/* ACTION */</span></div><div class="line"><span class="stringliteral">&quot;if&quot;</span>                    <span class="keywordflow">return</span> KEYWORD_IF;</div><div class="line"><span class="stringliteral">&quot;*&quot;</span>                     <span class="keywordflow">return</span> OP_MUL;</div><div class="line"><span class="stringliteral">&quot;=&quot;</span>                     <span class="keywordflow">return</span> OP_ASSIGN;</div><div class="line">[a-zA-Z_][a-zA-Z0-9_]*  <span class="keywordflow">return</span> ASCII_IDENTIFIER;</div><div class="line">[0-9]+                  <span class="keywordflow">return</span> CONST_NUMBER;</div><div class="line">\<span class="stringliteral">&quot;([^\\&quot;</span>]|\\<span class="stringliteral">&quot;)*\&quot;       return CONST_STRING;</span></div><div class="line"><span class="stringliteral">[ \t\r\n]               /* no action: ignore all white space */</span></div><div class="line"><span class="stringliteral">%%</span></div></div><!-- fragment --> </div><p>When the tokenizer matches a pattern, the corresponding action is invoked. The example above returns tokens to the compiler's parser, which repeatedly invokes the tokenizer for more tokens until the tokenizer reaches the end of the input. The tokenizer returns zero (0) when the end of the input is reached.</p>
<p>Lex and Flex have remained relatively stable (inert) tools while the demand has increased for tokenizing Unicode texts encoded in common wide character formats such as UTF-8, UCS/UTF-16, and UTF-32. Lex/Flex still use 8-bit character sets for regex patterns. Regex pattern syntax in Lex/Flex is also limited. No lazy repetitions. No word boundary anchors. No indent and dedent matching.</p>
<p>It is possible, but not trivial to implement scanners with Lex/Flex to tokenize the source code of more modern programming languages with Unicode-based lexical structures, such as Java, C#, and C++11.</p>
<p>A possible approach is to use UTF-8 in patterns and reformat the input to UTF-8 for matching. However, the UTF-8 patterns for common Unicode character classes are unrecognizable by humans and are prone to errors when written by hand. The UTF-8 pattern to match a Unicode letter <code>\p{L}</code> is hundreds of lines long!</p>
<p>Furthermore, the regular expression syntax in Lex/Flex is limited to meet POSIX mode matching constraints. Scanners should use POSIX mode matching, as we will explain below. To make things even more interesting, scanners should avoid the "greedy trap" when matching input.</p>
<p>Lex/Flex scanners use POSIX pattern matching, meaning that the leftmost longest match is returned (among a set of patterns that match the same input). Because POSIX matchers produce the longest match for any given input text, we should be careful when using patterns with "greedy" repetitions (<code>X*</code>, <code>X+</code> etc.) because our pattern may gobble up more input than intended. We end up falling into the "greedy trap".</p>
<p>To illustrate this trap consider matching HTML comments <code>&lt;!−− ... −−&gt;</code> with the pattern <code>&lt;!−−.*−−&gt;</code>. The problem is that the repetition <code>X*</code> is greedy and the <code>.*−−&gt;</code> pattern matches everything until the last <code>−−&gt;</code> while moving over <code>−−&gt;</code> that are between the <code>&lt;!−−</code> and the last <code>−−&gt;</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Dot <code>.</code> normally does not match newline <code>\n</code> in Lex/Flex patterns, unless we use <em>dot-all mode</em> that is sometimes confusingly called "single line mode".</dd></dl>
<p>We can use much more complex patterns such as <code>&lt;!−−([^−]|−[^−]|−−+[^−&gt;])*−*−−&gt;</code> just to match comments in HTML, by ensuring the pattern ends at the first match of a <code>−−&gt;</code> in the input and not at the very last <code>−−&gt;</code> in the input. The POSIX leftmost longest match can be surprisingly effective in rendering our tokenizer into works of ASCII art!</p>
<p>We may claim our intricate pattern trophies as high achievements to the project team, but our team will quickly point out that a regex <code>&lt;!−−.*?−−&gt;</code> suffices to match HTML comments with the <em>lazy repetition</em> <code>X*?</code> construct, also known as a <em>non-greedy repeat</em>. The <code>?</code> is a <em>lazy quantifier</em> that modifies the behavior of the <code>X*?</code> repeat to match only <code>X</code> repeately if the rest of the pattern does not match. Therefore, the regex <code>&lt;!−−.*?−−&gt;</code> matches HTML comments and nothing more.</p>
<p>But Lex/Flex does not permit us to be lazy!</p>
<p>Not surprising, even the Flex manual shows ad-hoc code rather than a pattern to scan over C/C++ source code input to match multiline comments that start with a <code>/*</code> and end with the first occurrence of a <code>*/</code>. The Flex manual recommends:</p>
<div class="alt"> <div class="fragment"><div class="line"><span class="stringliteral">&quot;/*&quot;</span>    {  <span class="comment">/* skip multiline comments */</span></div><div class="line">  <span class="keywordtype">int</span> c;</div><div class="line">  <span class="keywordflow">while</span> ((c = <a class="code" href="flexlexer_8h.html#a411db26910a55c4e92a226dee582564b">yyinput</a>()) != 0)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;\n&#39;</span>)</div><div class="line">      ++mylineno;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;*&#39;</span>)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> ((c = <a class="code" href="flexlexer_8h.html#a411db26910a55c4e92a226dee582564b">yyinput</a>()) == <span class="charliteral">&#39;/&#39;</span>)</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      unput(c);</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --> </div><p>Another argument to use this code with Flex is that the internal Flex buffer is limited to 16KB. By contrast, RE/flex buffers are dynamically resized and will accept long matches.</p>
<p>Workarounds such as these are not necessary with RE/flex. The RE/flex scanners use regex libraries with expressive pattern syntax. We can use lazy repetition to write a regex pattern for multiline comments as follows:</p>
<div class="alt"> <div class="fragment"><div class="line"><span class="stringliteral">&quot;/*&quot;</span>(.|\n)*?<span class="stringliteral">&quot;*/&quot;</span>  <span class="comment">/* no action: ignore multiline comments */</span></div></div><!-- fragment --> </div><p>Most regex libraries support syntaxes and features that we have come to rely on for pattern matching. A regex with lazy quantifiers can be much easier to read and comprehend compared to a greedy variant. Most regex libraries that support lazy quantifiers run in Perl mode, using backtracking over the input. Scanners use POSIX mode matching, meaning that the leftmost longest match is found. The difference is important as we saw earlier and even more so when we consider the problems with Perl mode matching when specifying patterns to tokenize input, as we will explain next.</p>
<p>Consider the lexer specification example shown earlier. Suppose the input text to tokenize is <code>iflag = 1</code>. In POSIX mode we return <code>ASCII_IDENTIFIER</code> for the name <code>iflag</code>, <code>OP_ASSIGN</code> for <code>=</code>, and <code>NUMBER</code> for <code>1</code>. In Perl mode, we find that <code>iflag</code> matches <code>if</code> and the rest of the name is not consumed, which gives <code>KEYWORD_IF</code> for <code>if</code>, <code>ASCII_IDENTIFIER</code> for <code>lag</code>, <code>OP_ASSIGN</code> for <code>=</code>, and a <code>NUMBER</code> for <code>1</code>. Perl mode matching greedely returns leftmost matches.</p>
<p>Using Perl mode in a scanner requires all overlapping patterns to be defined in a lexer specification such that all longest matching patterns are defined first to ensure longest matches. By contrast, POSIX mode is <em>declarative</em> and allows you to define the patterns in the specification in any order. Perhaps the only ordering constraint on patterns is for patterns that match the same input, such such as matching the keyword <code>if</code> in the example: <code>KEYWORD_IF</code> must be matched before <code>ASCII_IDENTIFIER</code>.</p>
<p>For this reason, RE/flex scanners use a regex library in POSIX mode by default.</p>
<p>In summary, the advantages that RE/flex has to offer include:</p>
<ul>
<li>RE/flex is fully compatible with Flex and Bison, by using the <code>−−flex</code> and/or <code>−−bison</code> options. This eliminates a learning curve to use RE/flex.</li>
<li>The RE/flex scanner generator accepts specifications that are compatible with <a href="dinosaur.compilertools.net/#flex">Flex</a>, with additional options to select a matcher engine and to specify names and options for C++ class generation.</li>
<li>The RE/flex scanner generator option <code>−−bison</code> generates a scanner compatible with <a href="dinosaur.compilertools.net/#bison">Bison</a>. RE/flex also supports Bison bridge (pure reentrant and MT-safe) parsers.</li>
<li>The regular expression syntax in Flex and Lex specifications is restricted to POSIX ERE. By contrast, the RE/flex specification syntax is regex-centric by design and offers a much richer pattern syntax, including lazy quantifiers.</li>
<li>A matcher engine for a lexer class has a common interface API declared by the abstract base matcher class template.</li>
<li>RE/flex scanners are not implemented as a set of global functions and tables. RE/flex scanners are instances of generated lexer classes. Thus are MT-safe. A lexer class is derived from an abstract base lexer class template and it is instantiated with a regex matcher engine class that is provided as a template parameter.</li>
<li>Lex and Flex scanners are restricted to ASCII or 8-bit character sets without adequate support for Unicode. RE/flex specifications are extended to support Unicode such that the RE/flex scanner generator produces scanners that handle UTF-8/16/32 input files.</li>
<li>Input to matcher engines and scanners is implemented as a class that supports streaming sources of input and automatically decodes UTF-encoded files.</li>
<li>RE/flex scanners can be stand-alone applications, similar to Flex scanners.</li>
</ul>
<p><a class="el" href="index.html#reflex">The RE/flex scanner generator </a> section has more details on the RE/flex scanner generator tool.</p>
<p>In the next part of this manual, we will take a quick look at the RE/flex regex API that can be used as a stand-alone library for matching, searching, scanning and splitting input from strings, files and streams in regular C++ applications (i.e. applications that are not necessarily tokenizers for compilers).</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="intro2"></a>
A flexible regex library                                              </h2>
<p>The RE/flex regex pattern matching classes include two classes for Boost.Regex, two classes for C++11 std::regex, and a RE/flex class:</p>
<table class="doxtable">
<tr>
<th>Engine </th><th>Header file to include </th><th>reflex matcher classes  </th></tr>
<tr>
<td>RE/flex regex </td><td><code><a class="el" href="matcher_8h.html" title="RE/flex matcher engine. ">reflex/matcher.h</a></code> </td><td><code>Matcher</code> </td></tr>
<tr>
<td>Boost.Regex </td><td><code><a class="el" href="boostmatcher_8h.html" title="Boost::regex-based matcher engines for pattern matching. ">reflex/boostmatcher.h</a></code> </td><td><code>BoostMatcher</code>, <code>BoostPosixMatcher</code> </td></tr>
<tr>
<td>std::regex </td><td><code><a class="el" href="stdmatcher_8h.html" title="C++11 std::regex-based matcher engines for pattern matching. ">reflex/stdmatcher.h</a></code> </td><td><code>StdMatcher</code>, <code>StdPosixMatcher</code> </td></tr>
</table>
<p>The RE/flex <code><a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a></code> class compiles regex patterns to efficient finite state machines (FSMs) when instantiated. These deterministic automata speed up matching considerably, at the cost of the initial FSM construction (see further below for hints on how to avoid this run time overhead).</p>
<p>C++11 std::regex supports ECMAScript and AWK POSIX syntax with the <code>StdMatcher</code> and <code>StdPosixMatcher</code> classes respectively. The std::regex syntax is therefore a lot more limited compared to Boost.Regex and RE/flex.</p>
<p>The RE/flex regex common interface API is implemented in an abstract base class template <code><a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">reflex::AbstractMatcher</a></code> from which regex matchers are derived. This regex API offers a common interface that is used in the generated scanner. You can also use this API in your C++ application for pattern matching.</p>
<p>The RE/flex abstract matcher offers four operations for matching with the regex engines that are derived from this base abstract class:</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Result  </th></tr>
<tr>
<td><code>matches()</code> </td><td>true if the input from begin to end matches the regex pattern </td></tr>
<tr>
<td><code>find()</code> </td><td>search input and return true if a match was found </td></tr>
<tr>
<td><code>scan()</code> </td><td>return true if input at current position matches partially </td></tr>
<tr>
<td><code>split()</code> </td><td>split input at the next match </td></tr>
</table>
<p>These methods are repeatable, where the last three return additional matches.</p>
<p>For example, to check if a string is a valid date:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><span class="comment">// use a BoostMatcher to check if the birthdate string is a valid date</span></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a>(<span class="stringliteral">&quot;\\d{4}-\\d{2}-\\d{2}&quot;</span>, birthdate).matches())</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Valid date!&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>To search a string for words <code>\w+</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><span class="comment">// use a BoostMatcher to search for words in a sentence</span></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;\\w+&quot;</span>, <span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line"><span class="keywordflow">while</span> (matcher.find() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; matcher.text() &lt;&lt; std::endl;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">Found How
Found now
Found brown
Found cow
</pre><p>The <code>scan</code> method is similar to the <code>find</code> method, but <code>scan</code> matches only from the current position in the input. It fails when no partial match was possible at the current position. Repeately scanning an input source means that matches must be continuous, otherwise <code>scan</code> returns zero (no match).</p>
<p>The <code>split</code> method is roughly the inverse of the <code>find</code> method and returns text located between matches. For example using non-word matching <code>\W+</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><span class="comment">// use a BoostMatcher to search for words in a sentence</span></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;\\W+&quot;</span>, <span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line"><span class="keywordflow">while</span> (matcher.split() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; matcher.text() &lt;&lt; std::endl;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">Found How
Found now
Found brown
Found cow
Found
</pre><p>Note that split also returns the (possibly empty) remaining text after the last match, as you can see in the output above: the last split with <code>\W+</code> returns an empty string, which is the remaining input after the period in the sentence.</p>
<p>The regex engines currently available as classes in the <code>reflex</code> namespace are:</p>
<table class="doxtable">
<tr>
<th>Class </th><th>Mode </th><th>Engine </th><th>Performance  </th></tr>
<tr>
<td><code>Matcher</code> </td><td>POSIX </td><td>RE/flex lib </td><td>deterministic finite automaton </td></tr>
<tr>
<td><code>BoostMatcher</code> </td><td>Perl </td><td>Boost.Regex </td><td>regex backtracking </td></tr>
<tr>
<td><code>BoostPerlMatcher</code> </td><td>Perl </td><td>Boost.Regex </td><td>regex backtracking </td></tr>
<tr>
<td><code>BoostPosixMatcher</code> </td><td>POSIX </td><td>Boost.Regex </td><td>regex backtracking </td></tr>
<tr>
<td><code>StdMatcher</code> </td><td>ECMA </td><td>std::regex </td><td>regex backtracking </td></tr>
<tr>
<td><code>StdEcmaMatcher</code> </td><td>ECMA </td><td>std::regex </td><td>regex backtracking </td></tr>
<tr>
<td><code>StdPosixMatcher</code> </td><td>POSIX </td><td>std::regex </td><td>regex backtracking </td></tr>
</table>
<p>The RE/flex regex engine uses a deterministic finite state machine (FSM) to get the best performance when matching. However, constructing a FSM adds overhead. This matcher is better suitable for searching long texts. The FSM construction overhead can be eliminated by pre-converting the regex to C++ code tables ahead of time as we will see later.</p>
<p>The Boost.Regex engines normally use Perl mode matching. We added a POSIX mode Boost.Regex engine class for the RE/flex scanner generator. Scanners typically use POSIX mode matching. See <a class="el" href="index.html#reflex-posix-perl">POSIX versus Perl matching </a> for more information.</p>
<p>The Boost.Regex engines are all initialized with <code>match_not_dot_newline</code>, which disables dotall matching as the default setting. Dotall can be re-enabled with the <code>(?s)</code> regex mode modifier. This is done for compatibility with scanners.</p>
<p>A matcher can be applied to strings and wide strings, such as <code>std::string</code> and <code>std::wstring</code>, <code>char*</code> and <code>wchar_t*</code>. Wide strings are converted to UTF-8 to enable matching with regular expressions that contain Unicode patterns.</p>
<p>To match Unicode patterns with regex library engines that are 8-bit based or do not support Unicode, you may want to convert your regex string first before you use it with a regex matcher engine as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matcher_8h.html">reflex/matcher.h</a>&gt;</span> <span class="comment">// reflex::Matcher, reflex::Input, reflex::Pattern</span></div><div class="line"></div><div class="line"><span class="comment">// convert a regex with Unicode character classes to create a pattern FSM:</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string regex = <a class="code" href="classreflex_1_1_matcher.html#a8862686f6d5680d4d0e5af146c4aed69">reflex::Matcher::convert</a>(<span class="stringliteral">&quot;[\\p{Greek}\\p{Zs}\\pP]+&quot;</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classreflex_1_1_pattern.html">reflex::Pattern</a> pattern(regex);</div><div class="line"></div><div class="line"><span class="comment">// use a Matcher to check if sentence is in Greek:</span></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classreflex_1_1_matcher.html">reflex::Matcher</a>(pattern, sentence).matches())</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is Greek&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>This converts the Unicode character classes to UTF-8 for matching with an 8-bit regex engine. The <code>convert</code> static method differs per matcher class. An error <code><a class="el" href="classreflex_1_1regex__error.html" title="Regex syntax error exceptions. ">reflex::regex_error</a></code> is thrown as an exception if conversion was not possible, which is unlikely, or if the regex is syntactically incorrect.</p>
<p>Conversion is fast (it runs in linear time in the size of the regex), but it is not without some overhead. You can make the converted regex patterns <code>static</code>, as shown above, to eliminate the cost of repeated conversions.</p>
<p>A <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> object is immutable (it stores a constant table) and can be shared among threads.</p>
<p>Use <code>convert</code> with option <code><a class="el" href="namespacereflex_1_1convert__flag.html#ab1c057a380f8673a13064c755652dc39" title="convert . (dot), \s, \w, \l, \u, \S, \W, \L, \U to Unicode ">reflex::convert_flag::unicode</a></code> to change the meaning of <code>.</code> (dot), <code>\w</code>, <code>\s</code>, <code>\l</code>, <code>\u</code>, <code>\W</code>, <code>\S</code>, <code>\L</code>, <code>\U</code> character classes.</p>
<p>You can pattern match text in files. File contents are streamed and not loaded as a whole into memory, meaning that the data stream is not limited in size and matching happens immediately. Interactive mode permits matching the input from a console (a TTY device generates a potentially endless stream of characters):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><span class="comment">// use a BoostMatcher to search and display words from console input</span></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;\\w+&quot;</span>, std::cin);</div><div class="line">matcher.interactive();</div><div class="line"><span class="keywordflow">while</span> (matcher.find() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; matcher.text() &lt;&lt; std::endl;</div></div><!-- fragment --><p>We can also pattern match text from <code>FILE</code> descriptors. The additional benefit of using <code>FILE</code> descriptors is the automatic decoding of UTF-16/32 input to UTF-8 by the <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> class that manages input sources and their state.</p>
<p>For example, pattern matching the content of "cows.txt" that may use UTF-8, 16, or 32 encodings:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><span class="comment">// use a BoostMatcher to search and display words from a FILE</span></div><div class="line">FILE *fd = fopen(<span class="stringliteral">&quot;cows.txt&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> (fd == NULL)</div><div class="line">  exit(EXIT_FAILURE);</div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;\\w+&quot;</span>, fd);</div><div class="line"><span class="keywordflow">while</span> (matcher.find() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; matcher.text() &lt;&lt; std::endl;</div></div><!-- fragment --><p>The <code>find</code>, <code>scan</code>, and <code>split</code> methods are also implemented as input iterators that apply filtering tokenization, and splitting:</p>
<table class="doxtable">
<tr>
<th>Iterator range </th><th>Acts as a </th><th>Iterates over  </th></tr>
<tr>
<td><code>find.begin()</code>...<code>find.end()</code> </td><td>filter </td><td>all matches </td></tr>
<tr>
<td><code>scan.begin()</code>...<code>scan.end()</code> </td><td>tokenizer </td><td>continuous matches </td></tr>
<tr>
<td><code>split.begin()</code>...<code>split.end()</code> </td><td>splitter </td><td>text between matches </td></tr>
</table>
<p>The type <code><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html" title="AbstractMatcher::Operation functor to match input to a pattern, also provides a (const) AbstractMatch...">reflex::AbstractMatcher::Operation</a></code> is a functor that defines <code>find</code>, <code>scan</code>, and <code>split</code>. The functor operation returns true upon success. The use of an iterator is simply supported by invoking <code>begin()</code> and <code>end()</code> methods of the functor, which return <code><a class="el" href="classreflex_1_1_abstract_matcher.html#a7237c1fb8ab2a2283117739e6516c31f" title="std::input_iterator for scanning, searching, and splitting input character sequences ...">reflex::AbstractMatcher::iterator</a></code>. Likewise, there are also <code>cbegin()</code> and <code>cend()</code> methods that return a <code>const_iterator</code>.</p>
<p>We can use these RE/flex iterators in C++ for many tasks, including to populate containers by stuffing the iterator's text matches into it:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span>                <span class="comment">// std::vector</span></div><div class="line"></div><div class="line"><span class="comment">// use a BoostMatcher to convert words of a sentence into a string vector</span></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;\\w+&quot;</span>, <span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line">std::vector&lt;std::string&gt; words(matcher.find.begin(), matcher.find.end());</div></div><!-- fragment --><p>As a result, the <code>words</code> vector contains "How", "now", "brown", "cow".</p>
<p>Casting a matcher object to <code>std::string</code> is the same as converting <code>text()</code> to a string with <code>std::string(text(), size())</code>, which in the example above is done to construct the <code>words</code> vector. Casting a matcher object to <code>std::wstring</code> is similar, but also converts the UTF-8 <code>text()</code> match to a wide string.</p>
<p>RE/flex iterators are useful in C++11 range-based loops. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// Requires C++11, compile with: cc -std=c++11</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdmatcher_8h.html">reflex/stdmatcher.h</a>&gt;</span> <span class="comment">// reflex::StdMatcher, reflex::Input, std::regex</span></div><div class="line"></div><div class="line"><span class="comment">// use a StdMatcher to search for words in a sentence using an iterator</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; match : <a class="code" href="classreflex_1_1_std_matcher.html">reflex::StdMatcher</a>(<span class="stringliteral">&quot;\\w+&quot;</span>, <span class="stringliteral">&quot;How now brown cow.&quot;</span>).find)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; match.text() &lt;&lt; std::endl;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">Found How
Found now
Found brown
Found cow
</pre><p>And RE/flex iterators are also useful with STL algorithms and lambdas, for example to compute a histogram of word frequencies:</p>
<div class="fragment"><div class="line"><span class="comment">// Requires C++11, compile with: cc -std=c++11</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdmatcher_8h.html">reflex/stdmatcher.h</a>&gt;</span> <span class="comment">// reflex::StdMatcher, reflex::Input, std::regex</span></div><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span>           <span class="comment">// std::for_each</span></div><div class="line"></div><div class="line"><span class="comment">// use a StdMatcher to create a frequency histogram of group captures</span></div><div class="line"><a class="code" href="classreflex_1_1_std_matcher.html">reflex::StdMatcher</a> matcher(<span class="stringliteral">&quot;(now)|(cow)|(ow)&quot;</span>, <span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line"><span class="keywordtype">size_t</span> freq[4] = { 0, 0, 0, 0 };</div><div class="line">std::for_each(matcher.find.begin(), matcher.find.end(), [&amp;](<span class="keywordtype">size_t</span> n){ ++freq[n]; });</div></div><!-- fragment --><p>As a result, the <code>freq</code> array contains 0, 1, 1, and 2.</p>
<p>Casting the matcher object to a <code>size_t</code> returns the group capture index, which is used in the example shown above. We also us it in the example below that is capturing all regex pattern groupings into a vector:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span>                <span class="comment">// std::vector</span></div><div class="line"></div><div class="line"><span class="comment">// use a BoostMatcher to convert captured groups into a numeric vector</span></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;(now)|(cow)|(ow)&quot;</span>, <span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line">std::vector&lt;size_t&gt; captures(matcher.find.begin(), matcher.find.end());</div></div><!-- fragment --><p>As a result, the vector contains the group captures 3, 1, 3, and 2.</p>
<p>Casting the matcher object to <code>size_t</code> is the same as invoking <code>accept()</code>.</p>
<p>You can use this method and other methods to obtain the details of a match:</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Result  </th></tr>
<tr>
<td><code>accept()</code> </td><td>returns group capture index or zero if not captured/matched </td></tr>
<tr>
<td><code>text()</code> </td><td>returns <code>const char*</code> to NUL-terminated match (ends in <code>\0</code>) </td></tr>
<tr>
<td><code>str()</code> </td><td>returns <code>std::string</code> copy of <code>text()</code> (but preserves <code>\0</code>s) </td></tr>
<tr>
<td><code>wstr()</code> </td><td>returns <code>std::wstring</code> copy of <code>text()</code>, converted from UTF-8 </td></tr>
<tr>
<td><code>pair()</code> </td><td>returns <code>std::pair&lt;size_t,std::string&gt;(accept(),str())</code> </td></tr>
<tr>
<td><code>wpair()</code> </td><td>returns <code>std::pair&lt;size_t,std::wstring&gt;(accept(),wstr())</code> </td></tr>
<tr>
<td><code>size()</code> </td><td>returns the length of the text match in bytes </td></tr>
<tr>
<td><code>wsize()</code> </td><td>returns the length of the match in number of wide characters </td></tr>
<tr>
<td><code>begin()</code> </td><td>returns <code>const char*</code> to non-NUL-terminated match begin </td></tr>
<tr>
<td><code>end()</code> </td><td>returns <code>const char*</code> to non-NUL-terminated match end </td></tr>
<tr>
<td><code>rest()</code> </td><td>returns <code>const char*</code> to NUL-terminated rest of input </td></tr>
<tr>
<td><code>more()</code> </td><td>tells the matcher to append the next match (adjacent matches) </td></tr>
<tr>
<td><code>less(n)</code> </td><td>cuts <code>text()</code> to <code>n</code> bytes and repositions the matcher </td></tr>
<tr>
<td><code>lineno()</code> </td><td>returns line number of the match, starting with line 1 </td></tr>
<tr>
<td><code>columno()</code> </td><td>returns column number of the match, starting with 0 </td></tr>
<tr>
<td><code>first()</code> </td><td>returns position of the first character of the match </td></tr>
<tr>
<td><code>last()</code> </td><td>returns position of the last + 1 character of the match </td></tr>
<tr>
<td><code>at_bol()</code> </td><td>true if matcher reached the begin of a new line <code>\n</code> </td></tr>
<tr>
<td><code>at_bob()</code> </td><td>true if matcher is at the start of input, no matches consumed </td></tr>
<tr>
<td><code>at_end()</code> </td><td>true if matcher is at the end of input </td></tr>
<tr>
<td><code>[0]</code> </td><td>operator returns <code>std::pair&lt;const char*,size_t&gt;(begin(),size())</code> </td></tr>
<tr>
<td><code>[n]</code> </td><td>operator returns n'th capture <code>std::pair&lt;const char*,size_t&gt;</code> </td></tr>
</table>
<p>The <code>operator[n]</code> takes the group number <code>n</code> and returns the n'th group capture match as a pair with a <code>const char*</code> pointer to the group-matching text and the size of the matched text in bytes. Because the pointer points to a string that is not NUL-terminated, you should use the size to determine the matching part.</p>
<p>The pointer is NULL when the group capture has no match.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><span class="comment">// a BoostMatcher to capture name and number:</span></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;(\\w+)\\s+(\\d+)&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// use the matcher on a string:</span></div><div class="line"><span class="keywordflow">if</span> (matcher.input(<span class="stringliteral">&quot;cow 123&quot;</span>).matches())</div><div class="line">  std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">&quot;name: &quot;</span> &lt;&lt; std::string(matcher[1].first, matcher[1].second) &lt;&lt;</div><div class="line">    <span class="stringliteral">&quot;, number: &quot;</span> &lt;&lt; std::string(matcher[2].first, matcher[2].second) &lt;&lt;</div><div class="line">    std::endl;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">name: cow, number: 123
</pre><dl class="section warning"><dt>Warning</dt><dd>The <code>text()</code> method returns the match by pointing to the <code>const char*</code> string that is stored in an internal buffer. This pointer <em>should not be used</em> after matching continues and when the matcher object is deallocated. To retain the <code>text()</code> value use the <code>str()</code> method that returns a copy of <code>text()</code>.</dd>
<dd>
The <code>operator[]</code> method returns a pair with the match info of the n'th group, which is a non-NUL-terminated <code>const char*</code> pointer (or NULL), with size in bytes of the captured match. The string <em>should not be used</em> after matching continues.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When using the <code><a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a></code> class, the <code>accept()</code> method returns the accepted pattern among the alternations in the regex that are specified only at the top level in the regex. For example, the regex <code>"(a(b)c)|([A-Z])"</code> has two groups, because only the outer top-level groups are recognized. Because groups are specified at the top level only, the grouping parenthesis are optional. We can simplify the regex to <code>"a(b)c|[A-Z]"</code> and still capture the two patterns.</dd></dl>
<p>Three special methods can be used to manipulate the input stream directly:</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Result  </th></tr>
<tr>
<td><code>input()</code> </td><td>returns next char 0..255 from the input, matcher then skips it </td></tr>
<tr>
<td><code>winput()</code> </td><td>returns the next wide character from the input, matcher skips it </td></tr>
<tr>
<td><code>unput(c)</code> </td><td>put char <code>c</code> back unto the stream, matcher then takes it </td></tr>
<tr>
<td><code>peek()</code> </td><td>returns the next char 0..255 from the input without consuming it </td></tr>
</table>
<p>To initialize a matcher for interactive use, to assign a new input source or to change its pattern, you can use the following methods:</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Result  </th></tr>
<tr>
<td><code>input(i)</code> </td><td>set input to <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> i</code> (string, stream, or <code>FILE*</code>) </td></tr>
<tr>
<td><code>pattern(p)</code> </td><td>set pattern <code>p</code> string, <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> or <code>boost::regex</code> </td></tr>
<tr>
<td><code>has_pattern()</code> </td><td>true if the matcher has a pattern assigned to it </td></tr>
<tr>
<td><code>own_pattern()</code> </td><td>true if the matcher has a pattern to manage and delete </td></tr>
<tr>
<td><code>pattern()</code> </td><td>get the pattern object, <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> or <code>boost::regex</code> </td></tr>
<tr>
<td><code>buffer()</code> </td><td>buffer all input at once, returns true if successful </td></tr>
<tr>
<td><code>buffer(n)</code> </td><td>set the adaptive buffer size to <code>n</code> bytes to buffer input </td></tr>
<tr>
<td><code>interactive()</code> </td><td>sets buffer size to 1 for console-based (TTY) input </td></tr>
<tr>
<td><code>flush()</code> </td><td>flush the remaining input from the internal buffer </td></tr>
<tr>
<td><code>reset()</code> </td><td>resets the matcher, restarting it from the remaining input </td></tr>
<tr>
<td><code>reset(o)</code> </td><td>resets the matcher with new options string <code>o</code> ("A?N?T?") </td></tr>
</table>
<p>A <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> object represents the source of input for a matcher, which is either a file <code>FILE*</code>, or a string (with UTF-8 character data) of <code>const char*</code> or <code>std::string</code> type, or a stream pointer <code>std::istream*</code>. The <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> object is implicitly constructed from one of these input sources, for example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><span class="comment">// set the input source to a string (or a stream or a FILE*)</span></div><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> source = <span class="stringliteral">&quot;How now brown cow.&quot;</span>;</div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;\\w+&quot;</span>, source);</div><div class="line"></div><div class="line"><span class="keywordflow">while</span> (matcher.find() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; matcher.text() &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// use the same matcher with a new source (an Input object):</span></div><div class="line">std::ifstream ifs(<span class="stringliteral">&quot;cows.txt&quot;</span>, std::ifstream::in);</div><div class="line">source = ifs;           <span class="comment">// Input source is reassignable</span></div><div class="line">matcher.input(source);  <span class="comment">// can use ifs as parameter also</span></div><div class="line"></div><div class="line"><span class="keywordflow">while</span> (matcher.find() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; matcher.text() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">ifs.close();</div></div><!-- fragment --><p>The entire input is buffered in a matcher with <code>buffer()</code>, or is read piecemeal with <code>buffer(n)</code>, or is read interactively with <code>interactive()</code>. These methods should be used after setting the input source. Reading a stream with buffering all data is done with the <code>&gt;&gt;</code> operator as a shortcut:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><span class="comment">// read and buffer cows.txt file</span></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;&lt;cow&gt;&quot;</span>);</div><div class="line">std::ifstream cows(<span class="stringliteral">&quot;cows.txt&quot;</span>, std::ifstream::in);</div><div class="line">cows &gt;&gt; matcher;     <span class="comment">// same as matcher.input(cows).buffer();</span></div><div class="line">cows.close();        <span class="comment">// can already close now because stream content is stored</span></div><div class="line"></div><div class="line"><span class="comment">// count number of &#39;cow&#39; words:</span></div><div class="line">std::out &lt;&lt; std::distance(matcher.find.begin(), matcher.find.end()) &lt;&lt; <span class="stringliteral">&quot; &#39;cow&#39; in cows.txt\n&quot;</span>;</div></div><!-- fragment --><p>So far we explained how to use <code><a class="el" href="classreflex_1_1_boost_matcher.html" title="Boost matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::BoostMatcher</a></code> for pattern matching. We can also use the RE/flex <code><a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a></code> class for pattern matching. The API is exactly the same. The <code><a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a></code> class uses <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code>, which internally represents an efficient finite state machine that is compiled from a regex. These state machines are used for fast matching.</p>
<p>The construction of deterministic finite state machines (FSMs) is optimized but can take some time and therefore adds overhead before matching can start. This FSM construction should not be executed repeatedly if it can be avoided. So we recommend to construct static pattern objects to create the FSMs only once:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matcher_8h.html">reflex/matcher.h</a>&gt;</span> <span class="comment">// reflex::Matcher, reflex::Pattern, reflex::Input</span></div><div class="line"></div><div class="line"><span class="comment">// statically allocate and construct a pattern, i.e. once and for all</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="classreflex_1_1_pattern.html">reflex::Pattern</a> word_pattern(<span class="stringliteral">&quot;\\w+&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// use the RE/flex POSIX matcher to search for words in a string sentence</span></div><div class="line"><a class="code" href="classreflex_1_1_matcher.html">reflex::Matcher</a> matcher(word_pattern, <span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line"><span class="keywordflow">while</span> (matcher.find() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; matcher.text() &lt;&lt; std::endl;</div></div><!-- fragment --><p>A <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> object is immutable (it stores a constant table) and can be shared among threads.</p>
<p>The RE/flex matcher only supports POSIX mode matching and does not support Perl mode matching. See <a class="el" href="index.html#reflex-posix-perl">POSIX versus Perl matching </a> for more information.</p>
<p>The RE/flex <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> class has several options that control the regex. Options and modes for the regex are set as a string, for example:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="classreflex_1_1_pattern.html">reflex::Pattern</a> word_pattern(<span class="stringliteral">&quot;\\w+&quot;</span>, <span class="stringliteral">&quot;f=graph.gv;f=machine.cpp&quot;</span>);</div></div><!-- fragment --><p>The <code>f=graph.gv</code> option emits a Graphviz .gv file that can be visually rendered with the open source <a href="http://www.graphviz.org">Graphviz dot tool</a> by converting the deterministic finite state machine (FSM) to PDF, PNG, or other formats:</p>
<div align="center">
<img src="dot_inline_dotgraph_1.png" alt="dot_inline_dotgraph_1.png" border="0" usemap="#dot_inline_dotgraph_1.map"/>
<map name="dot_inline_dotgraph_1.map" id="dot_inline_dotgraph_1.map"></map>
</div>
<p>The <code>f=machine.cpp</code> option emits opcode tables for the finite state machine, which in this case is the following table of 11 code words:</p>
<div class="fragment"><div class="line">REFLEX_CODE_DECL reflex_code_FSM[11] =</div><div class="line">{</div><div class="line">  0x617A0005, <span class="comment">// 0: GOTO 5 ON a-z</span></div><div class="line">  0x5F5F0005, <span class="comment">// 1: GOTO 5 ON _</span></div><div class="line">  0x415A0005, <span class="comment">// 2: GOTO 5 ON A-Z</span></div><div class="line">  0x30390005, <span class="comment">// 3: GOTO 5 ON 0-9</span></div><div class="line">  0x00FFFFFF, <span class="comment">// 4: HALT</span></div><div class="line">  0xFF000001, <span class="comment">// 5: TAKE 1</span></div><div class="line">  0x617A0005, <span class="comment">// 6: GOTO 5 ON a-z</span></div><div class="line">  0x5F5F0005, <span class="comment">// 7: GOTO 5 ON _</span></div><div class="line">  0x415A0005, <span class="comment">// 8: GOTO 5 ON A-Z</span></div><div class="line">  0x30390005, <span class="comment">// 9: GOTO 5 ON 0-9</span></div><div class="line">  0x00FFFFFF, <span class="comment">// 10: HALT</span></div><div class="line">};</div></div><!-- fragment --><p>Option <code>o</code> can be used with <code>f=machine.cpp</code> to emit optimized native C++ code for the finite state machine:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> reflex_code_FSM(<a class="code" href="classreflex_1_1_matcher.html">reflex::Matcher</a>&amp; m)</div><div class="line">{</div><div class="line">  <span class="keywordtype">int</span> c0 = 0, c1 = c0;</div><div class="line">  m.<a class="code" href="classreflex_1_1_matcher.html#a81899695d5bb82e06e49608ed9ebd629">FSM_INIT</a>(c1);</div><div class="line"></div><div class="line">S0:</div><div class="line">  c0 = c1, c1 = m.<a class="code" href="classreflex_1_1_matcher.html#a1c852851aeae6ed96e7adb0f6afe7932">FSM_CHAR</a>();</div><div class="line">  <span class="keywordflow">if</span> (97 &lt;= c1 &amp;&amp; c1 &lt;= 122) <span class="keywordflow">goto</span> S5;</div><div class="line">  <span class="keywordflow">if</span> (c1 == 95) <span class="keywordflow">goto</span> S5;</div><div class="line">  <span class="keywordflow">if</span> (65 &lt;= c1 &amp;&amp; c1 &lt;= 90) <span class="keywordflow">goto</span> S5;</div><div class="line">  <span class="keywordflow">if</span> (48 &lt;= c1 &amp;&amp; c1 &lt;= 57) <span class="keywordflow">goto</span> S5;</div><div class="line">  <span class="keywordflow">return</span> m.<a class="code" href="classreflex_1_1_matcher.html#a16876012f70f8957f689b9bda076a730">FSM_HALT</a>(c1);</div><div class="line"></div><div class="line">S5:</div><div class="line">  m.<a class="code" href="classreflex_1_1_matcher.html#a6237f5989d641c75edc310beb73fd84d">FSM_TAKE</a>(1);</div><div class="line">  c0 = c1, c1 = m.<a class="code" href="classreflex_1_1_matcher.html#a1c852851aeae6ed96e7adb0f6afe7932">FSM_CHAR</a>();</div><div class="line">  <span class="keywordflow">if</span> (97 &lt;= c1 &amp;&amp; c1 &lt;= 122) <span class="keywordflow">goto</span> S5;</div><div class="line">  <span class="keywordflow">if</span> (c1 == 95) <span class="keywordflow">goto</span> S5;</div><div class="line">  <span class="keywordflow">if</span> (65 &lt;= c1 &amp;&amp; c1 &lt;= 90) <span class="keywordflow">goto</span> S5;</div><div class="line">  <span class="keywordflow">if</span> (48 &lt;= c1 &amp;&amp; c1 &lt;= 57) <span class="keywordflow">goto</span> S5;</div><div class="line">  <span class="keywordflow">return</span> m.<a class="code" href="classreflex_1_1_matcher.html#a16876012f70f8957f689b9bda076a730">FSM_HALT</a>(c1);</div><div class="line">}</div></div><!-- fragment --><p>The compact FSM opcode tables or the optimized larger FSM code may be used directly in your code. This omits the FSM construction overhead at runtime. You can simply include this generated file in your source code and pass it on to the <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> constructor:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matcher_8h.html">reflex/matcher.h</a>&gt;</span>   <span class="comment">// reflex::Matcher, reflex::Pattern, reflex::Input</span></div><div class="line"><span class="preprocessor">#include &quot;machine.cpp&quot;</span> <span class="comment">// reflex_code_FSM[]</span></div><div class="line"></div><div class="line"><span class="comment">// use the pattern FSM (opcode table or C++ code) for fast search</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="classreflex_1_1_pattern.html">reflex::Pattern</a> pattern(reflex_code_FSM);</div><div class="line"></div><div class="line"><span class="comment">// use the RE/flex POSIX matcher to search for words in a string sentence</span></div><div class="line"><a class="code" href="classreflex_1_1_matcher.html">reflex::Matcher</a> matcher(pattern, <span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line"><span class="keywordflow">while</span> (matcher.find() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Found &quot;</span> &lt;&lt; matcher.text() &lt;&lt; std::endl;</div></div><!-- fragment --><p>The RE/flex <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> construction options are given as a string:</p>
<table class="doxtable">
<tr>
<th>Option </th><th>Effect  </th></tr>
<tr>
<td><code>b</code> </td><td>bracket lists are parsed without converting escapes </td></tr>
<tr>
<td><code>e=c;</code> </td><td>redefine the escape character </td></tr>
<tr>
<td><code>f=file.cpp;</code> </td><td>save finite state machine code to file.cpp </td></tr>
<tr>
<td><code>f=file.gv;</code> </td><td>save deterministic finite state machine to file.gv </td></tr>
<tr>
<td><code>i</code> </td><td>case-insensitive matching, same as <code>(?i)X</code> </td></tr>
<tr>
<td><code>l</code> </td><td>Lex-style trailing context with <code>/</code>, same as <code>(?l)X</code> </td></tr>
<tr>
<td><code>m</code> </td><td>multiline mode, same as <code>(?m)X</code> </td></tr>
<tr>
<td><code>n=name;</code> </td><td>use <code>reflex_code_name</code> for the machine (instead of <code>FSM</code>) </td></tr>
<tr>
<td><code>o</code> </td><td>only with option <code>f</code>: generate optimized FSM native C++ code </td></tr>
<tr>
<td><code>q</code> </td><td>Lex-style quotations "..." equal <code>\Q...\E</code>, same as <code>(?q)X</code> </td></tr>
<tr>
<td><code>r</code> </td><td>throw regex syntax error exceptions (not just fatal errors) </td></tr>
<tr>
<td><code>s</code> </td><td>dot matches all (aka. single line mode), same as <code>(?s)X</code> </td></tr>
<tr>
<td><code>x</code> </td><td>free space mode with inline comments, same as <code>(?x)X</code> </td></tr>
<tr>
<td><code>w</code> </td><td>display regex syntax errors before raising them as exceptions </td></tr>
</table>
<p>For example, <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a> pattern(pattern, "isr")</code> enables case-insensitive dot-all matching with syntax errors thrown as <code>reflex::Pattern::Error</code> types of exceptions.</p>
<p>In summary:</p>
<ul>
<li>RE/flex defines an extensible abstract class interface that offers a standard API to use regex matcher engines. The API is used by the generated scanners. The API supports UTF-8/16/32-encoded FILE content, wide strings and streaming data.</li>
<li>RE/flex includes a regex matcher class and a regex pattern class to implement fast matching with deterministic finite state machines (FSMs). The FSM graph can be visualized with the Graphviz dot tool. Furthermore, this FSM can also be exported and imported as source code to expedite pattern matching.</li>
</ul>
<p><a class="el" href="index.html#regex">The RE/flex regex library </a> section has more information about the RE/flex regex library.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="reflex"></a>
The RE/flex scanner generator                                         </h1>
<p>The RE/flex scanner generator takes a lexer specification and generates a regex-based C++ lexer class that is saved in lex.yy.cpp, or saved to the file specified by the <code>-o</code> command-line option. This file is then compiled and linked with a regex-library to produce a scanner. A scanner can be a stand-alone application or part of a larger program such as a compiler:</p>
<div align="center">
<img src="dot_inline_dotgraph_2.png" alt="dot_inline_dotgraph_2.png" border="0" usemap="#dot_inline_dotgraph_2.map"/>
<map name="dot_inline_dotgraph_2.map" id="dot_inline_dotgraph_2.map"></map>
</div>
<p>The RE/flex-generated scanners use the RE/flex regex library API for pattern matching. The RE/flex regex library API is defined by the abstract class <code><a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">reflex::AbstractMatcher</a></code>.</p>
<p>There are two regex matching engines to choose from for the generated scanner: the Boost.Regex library (assuming Boost.Regex is installed) or the RE/flex POSIX matcher engine. The <code>libreflex</code> library should be linked and also <code>libboost_regex</code> when needed.</p>
<p>The input class <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> of the <code>libreflex</code> library manages input from strings, wide strings, streams, and data from <code>FILE</code> descriptors. File data may be encoded in ASCII, binary or in UTF-8/16/32. UTF-16/32 is automatically decoded and converted to UTF-8 for UTF-8-based regex matching:</p>
<div align="center">
<img src="dot_inline_dotgraph_3.png" alt="dot_inline_dotgraph_3.png" border="0" usemap="#dot_inline_dotgraph_3.map"/>
<map name="dot_inline_dotgraph_3.map" id="dot_inline_dotgraph_3.map"></map>
</div>
<p>The generated scanner executes actions (typically to produce tokens for a parser). The actions are triggered by matching patterns to the input.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-command"></a>
The reflex command line tool                                  </h2>
<p>The <b>reflex</b> command generates a C++ scanner class in a source code file given a lexer specification. The <b>reflex</b> command accepts <code>−−flex</code> and <code>−−bison</code> options for compatibility. These options allow <b>reflex</b> to be used as a replacement of the classic Flex and Lex tools: </p><pre class="fragment">$ reflex −−flex −−bison lexerspec.l
</pre><p>The first option <code>−−flex</code> specifies that <code>lexerspec.l</code> is a classic Flex/Lex specification with <code>yytext</code> or <code>YYText()</code> and the usual "yy" variables and functions.</p>
<p>The second option <code>−−bison</code> generates a scanner class and auxiliary code for compatibility with <a href="dinosaur.compilertools.net/#bison">Bison</a> parsers. See <a class="el" href="index.html#reflex-bison">Interfacing with Bison/Yacc </a> for more details.</p>
<p>The source code output is intentionally structured in sections that are clean, readable, and reusable.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-options"></a>
Command-line options                                          </h2>
<p>To control the output of the <b>reflex</b> scanner generator, use command-line options. These options can also be specified in the lexer specification with <code>%option</code> (or <code>%o</code> for short):</p>
<div class="alt"> <div class="fragment"><div class="line">%option flex</div><div class="line">%option bison</div><div class="line">%option graphs-file=mygraph</div></div><!-- fragment --> </div><p>The above is equivalent to the <code>−−flex</code>, <code>−−bison</code>, and <code>−−graphs-file=mygraph</code> command-line options. Multiple options can be grouped on a single line:</p>
<div class="alt"> <div class="fragment"><div class="line">%o flex bison graphs-file=mygraph</div></div><!-- fragment --> </div><p>Option parameters should be quoted when parameters contain special characters:</p>
<div class="alt"> <div class="fragment"><div class="line">%o flex bison graphs-file=<span class="stringliteral">&quot;dev/output/mygraph.gv&quot;</span></div></div><!-- fragment --> </div><p>Shorter forms can be used, with each option on a separate line:</p>
<div class="alt"> <div class="fragment"><div class="line">%flex</div><div class="line">%bison</div><div class="line">%graphs-file=<span class="stringliteral">&quot;dev/output/mygraph.gv&quot;</span></div></div><!-- fragment --> </div><p>Options that affect the regular expressions such as <code>%option unicode</code> and <code>%option dotall</code> should be specified before any regular expressions are defined and used in the specification.</p>
<p>The scanner code generated by <b>reflex</b> defines options as macros <code>REFLEX_OPTION_name</code> with a value of <code>true</code> when the option is enabled or with the value that is assigned to the option. This allows your program code to check and use RE/flex options. For example, the lexer class name is <code>REFLEX_OPTION_lexer</code> when the lexer class name is redefined with option <code>−−lexer=NAME</code>.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-options-scanner"></a>
Scanner options</h3>
<h4><code>−+</code>, <code>−−flex</code></h4>
<p>This generates a <code>yyFlexLexer</code> scanner class that is compatible with the Flex-generated <code>yyFlexLexer</code> scanner class (assuming Flex with option <code>−+</code> for C++). The generated <code>yyFlexLexer</code> class has the usual <code>yytext</code> and other "yy" variables and functions, as defined by the Flex specification standard. Without this option, RE/flex actions should be used that are lexer class methods such as <code>echo()</code> and <code><a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">reflex::AbstractMatcher</a></code> class methods such as <code>matcher.more()</code>, see <a class="el" href="index.html#reflex-spec">Lexer specifications </a> for more details.</p>
<h4><code>-a</code>, <code>−−dotall</code></h4>
<p>This makes dot (<code>.</code>) in patterns match newline. Normally dot matches a single character except a newline (<code>\n</code> ASCII 0x0A).</p>
<h4><code>-B</code>, <code>−−batch</code></h4>
<p>This generates a batch input scanner that reads the entire input all at once when possible. This scanner is fast, but consumes more memory depending on the input data size.</p>
<h4><code>-f</code>, <code>−−full</code></h4>
<p>(RE/flex matcher only). This option adds the FSM to the generated code as a static opcode table, thus generating the scanner in full. FSM construction overhead is eliminated when the scanner is initialized, resulting in a scanner that starts scanning the input immediately. This option has no effect when option <code>−−fast</code> is used.</p>
<h4><code>-F</code>, <code>−−fast</code></h4>
<p>(RE/flex matcher only). This option adds the FSM to the generated code as optimized native C++ code. FSM construction overhead is eliminated when the scanner is initialized, resulting in a scanner that starts scanning the input immediately. The generated code takes more space compared to the <code>−−full</code> option.</p>
<h4><code>-i</code>, <code>−−case-insensitive</code></h4>
<p>This ignore case in patterns. Patterns match lower and upper case letters. This switch only applies to ASCII letters.</p>
<h4><code>-I</code>, <code>−−interactive</code>, <code>−−always-interactive</code></h4>
<p>This generates an interactive scanner and permits console input by sacrificing speed. By contrast, the default buffered input strategy is more efficient.</p>
<h4><code>-m reflex</code>, <code>−−matcher=reflex</code></h4>
<p>This generates a scanner that uses the RE/flex <code><a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a></code> class with a POSIX matcher engine. This is the default matcher for scanning. This option is best for Flex compatibility. The matcher supports Unicode, lazy quantifiers, word boundaries, indent/nodent/dedent matching, and supports FSM output for visualization with Graphviz.</p>
<h4><code>-m boost</code>, <code>−−matcher=boost</code></h4>
<p>This generates a scanner that uses the <code><a class="el" href="classreflex_1_1_boost_posix_matcher.html" title="Boost matcher engine class, extends reflex::BoostMatcher for Boost POSIX regex matching. ">reflex::BoostPosixMatcher</a></code> class with a Boost.Regex POSIX matcher engine for scanning. The matcher supports Unicode and word boundary anchors, but not lazy quantifiers. No Graphviz output.</p>
<h4><code>-m boost-perl</code>, <code>−−matcher=boost-perl</code></h4>
<p>This generates a scanner that uses the <code><a class="el" href="classreflex_1_1_boost_perl_matcher.html" title="Boost matcher engine class, extends reflex::BoostMatcher for Boost Perl regex matching. ">reflex::BoostPerlMatcher</a></code> class with a Boost.Regex normal (Perl) matcher engine for scanning. The matching behavior differs from the POSIX <em>leftmost longest rule</em> and results in the first matching rule to be applied instead of the rule that produces the longest match. The matcher supports lazy quantifiers and word boundary anchors. No Graphviz output.</p>
<h4><code>−−pattern=NAME</code></h4>
<p>This defines a custom pattern class NAME for the custom matcher specified with option <code>-m</code>.</p>
<h4><code>−−include=FILE</code></h4>
<p>This defines a custom include FILE.h to include for the custom matcher specified with option <code>-m</code>.</p>
<h4><code>−−tabs=N</code></h4>
<p>This sets the tab size to N, where N &gt; 0 must be a power of 2. The tab size is used internally to determine the column position in indent <code>\i</code> and dedent <code>\j</code> matching. It has no effect otherwise.</p>
<h4><code>-u</code>, <code>−−unicode</code></h4>
<p>This makes <code>.</code>, <code>\s</code>, <code>\w</code>, <code>\l</code>, <code>\u</code>, <code>\S</code>, <code>\W</code>, <code>\L</code>, <code>\U</code> match Unicode. Also groups UTF-8 sequences in the regex, such that each UTF-8 encoded character in a regex is properly matched as one wide character.</p>
<h4><code>-x</code>, <code>−−freespace</code></h4>
<p>This switches the <b>reflex</b> scanner to <em>free space mode</em>. Regular expressions in free space mode may contain spacing to improve readability. Spacing within regular expressions is ignored, so use <code>" "</code> or <code>[ ]</code> to match a space and <code>\h</code> to match a space or a tab character. Actions in free space mode MUST be placed in <code>{</code> and <code>}</code> blocks and all other code must be placed in <code>%{</code> and <code>%}</code> blocks. Patterns ending in an escape <code>\</code> continue on the next line.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-options-files"></a>
Output files options</h3>
<h4><code>-o FILE</code>, <code>−−outfile=FILE</code></h4>
<p>This saves the scanner to FILE instead of lex.yy.cpp.</p>
<h4><code>-t</code>, <code>−−stdout</code></h4>
<p>This writes the scanner to stdout instead of to lex.yy.cpp.</p>
<h4><code>−−graphs-file[=FILE]</code></h4>
<p>(RE/flex matcher only). This generates a Graphviz file FILE.gv, where FILE is optional. When FILE is omitted the <b>reflex</b> command generates the file reflex.S.gv for each start condition state S defined in the lexer specification. This includes reflex.INITIAL.gv for the INITIAL start condition state. This option can be used to visualize the RE/flex matcher's finite state machine with the <a href="http://www.graphviz.org">Graphviz dot</a> tool. For example:</p>
<div align="center">
<img src="dot_inline_dotgraph_4.png" alt="dot_inline_dotgraph_4.png" border="0" usemap="#dot_inline_dotgraph_4.map"/>
<map name="dot_inline_dotgraph_4.map" id="dot_inline_dotgraph_4.map"></map>
</div>
<p>In case you are curious: the specification for this FSM digraph has two patterns: [1] a pattern to match dollar amounts with the regex <code>\$\d+(\.\d{2})?</code> and [2] the regex <code>.|\n</code> to skip a character and advance to the next match.</p>
<h4><code>−−header-file[=FILE]</code></h4>
<p>This generates a C++ header file FILE.h that declares the lexer class, in addition to the generated lexer class code, where FILE is optional. When FILE is omitted the <b>reflex</b> command generates lex.yy.h.</p>
<h4><code>−−regexp-file[=FILE]</code></h4>
<p>This generates a text file FILE.txt that contains the scanner's regular expression patterns, where FILE is optional. When FILE is omitted the <b>reflex</b> command generates reflex.S.txt for each start condition state S. The regular expression patterns are converted from the lexer specification and translated into valid C++ strings that can be used with a regex library for pattern matching.</p>
<h4><code>−−tables-file[=FILE]</code></h4>
<p>(RE/flex matcher only). This generates a C++ file FILE.cpp with the finite state machine in source code form, where FILE is optional. When FILE is omitted the <b>reflex</b> command generates reflex.S.cpp for each start condition state S. This includes the file reflex.INITIAL.cpp for the INITIAL start condition state. When this option is used in combination with <code>−−full</code> or <code>−−fast</code>, the <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> is instantiated with the code table defined in this file. Therefore, when you combine this option with <code>−−full</code> or <code>−−fast</code> then you should compile the generated table file with the scanner. Options <code>−−full</code> and <code>−−fast</code> eliminate the FSM construction overhead when the scanner is initialized.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-options-code"></a>
Output code options</h3>
<h4><code>−−namespace=NAME</code></h4>
<p>This places the generated scanner class in the C++ namespace NAME scope. Which means <code>NAME::Lexer</code> (and <code>NAME::yyFlexLexer</code> when option <code>−−flex</code> is used).</p>
<h4><code>−−lexer=NAME</code></h4>
<p>This defines the NAME of the generated scanner class and replaces the default name <code>Lexer</code> (and replaces <code>yyFlexLexer</code> when option <code>−−flex</code> is used).</p>
<h4><code>−−lex=NAME</code></h4>
<p>This defines the NAME of the generated scanner function to replace the function name <code><a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">lex()</a></code> (and <code>yylex()</code> when option <code>−−flex</code> is used).</p>
<h4><code>−−class=NAME</code></h4>
<p>This defines the NAME of the scanner class that should be derived from the generated base <code>Lexer</code> class. Use this option when defining your own scanner class named NAME. You can declare a custom lexer class in the first section of the lexer specification. Because the custom lexer class is user-defined, <b>reflex</b> generates the implementation of the <code><a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">lex()</a></code> scanner function for this specified class.</p>
<h4><code>−−yyclass=NAME</code></h4>
<p>This option combines options <code>−−flex</code> and <code>−−class=NAME</code>.</p>
<h4><code>−−main</code></h4>
<p>This generates a <code>main</code> function to create a stand-alone scanner that scans data from standard input (using <code>stdin</code>).</p>
<h4><code>-L</code>, <code>−−noline</code></h4>
<p>This suppresses the <code>#line</code> directives in the generated scanner code.</p>
<h4><code>-P NAME</code>, <code>−−prefix=NAME</code></h4>
<p>This specifies NAME as a prefix for the generated <code>yyFlexLexer</code> class to replace the default <code>yy</code> prefix. Also renames the prefix of <code>yylex()</code>. Generates <code>lex.NAME.cpp</code> file instead of <code>lex.yy.cpp</code>, and generates <code>lex.NAME.h</code> with option <code>−−header-file</code>.</p>
<h4><code>−−nostdinit</code></h4>
<p>This initializes input to <code>std::cin</code> instead of using <code>stdin</code>. Automatic UTF decoding is not supported. Use <code>stdin</code> for automatic UTF BOM detection and decoding.</p>
<h4><code>−−bison</code></h4>
<p>This generates a scanner that works with Bison parsers, by defining global (non-MT-safe and non-reentrant) "yy" variables and functions. See <a class="el" href="index.html#reflex-bison">Interfacing with Bison/Yacc </a> for more details. Use option <code>−−noyywrap</code> to remove the dependency on the global <code>yywrap()</code> function.</p>
<h4><code>−−bison-bridge</code></h4>
<p>This generates a scanner that works with Bison pure (MT-safe and reentrant) parsers using a Bison bridge for one ore more scanner objects. See <a class="el" href="index.html#reflex-bison">Interfacing with Bison/Yacc </a> for more details.</p>
<h4><code>−−bison-locations</code></h4>
<p>This generates a scanner that works with Bison with locations enabled. See <a class="el" href="index.html#reflex-bison">Interfacing with Bison/Yacc </a> for more details.</p>
<h4><code>-R</code>, <code>−−reentrant</code></h4>
<p>This generates additional Flex-compatible <code>yylex()</code> reentrant scanner functions. RE/flex scanners are always reentrant, assuming that <code>%class</code> variables are used instead of global variables in the scanner's user code. This is a Flex-compatibility option and should only be used with options <code>−−flex</code> and <code>−−bison</code>. See <a class="el" href="index.html#reflex-bison">Interfacing with Bison/Yacc </a>.</p>
<h4><code>−−yywrap</code> and <code>−−noyywrap</code></h4>
<p>Option <code>−−yywrap</code> generates a scanner that calls the global <code>int yywrap()</code> function when EOF is reached. Only applicable when <code>−−flex</code> is used for compatibility and when <code>−−flex</code> and <code>−−bison</code> are used together. Use <code>−−noyywrap</code> to disable the dependence on this global function. This option has no effect for C++ lexer classes, which have a virtual <code>int wrap()</code> (or <code>yywrap()</code> with option <code>−−flex</code>) method that can be overridden.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-options-debug"></a>
Debugging options</h3>
<h4><code>-d</code>, <code>−−debug</code></h4>
<p>This enables debug mode in the generated scanner. Running the scanner produces debug messages on <code>std::cerr</code> standard error and the <code>debug()</code> function returns nonzero. To temporarily turn off debug messages, use <code>set_debug(0)</code> in your action code. To turn debug messages back on, use <code>set_debug(1)</code>. The <code>set_debug()</code> and <code>debug()</code> functions are virtual, so you can override their behavior in a derived lexer class. Also enables assertions that check for errors.</p>
<h4><code>-p</code>, <code>−−perf-report</code></h4>
<p>This enables the collection and reporting of statistics by the generated scanner. The scanner reports the performance statistics on <code>std::cerr</code> when EOF is reached. If your scanner does not reach EOF, then invoke the lexer's <code>perf_report()</code> method explicitly in your code. Invoking this method also resets the statistics and timers, meaning that this method will report the statistics collected since its last call.</p>
<h4><code>-s</code>, <code>−−nodefault</code></h4>
<p>This suppresses the default rule that ECHOs all unmatched text when no rule matches. With the <code>−−flex</code> option, the scanner reports "scanner jammed" when no rule matches. Without the <code>−−flex</code> option, unmatched input is silently ignored.</p>
<h4><code>-v</code>, <code>−−verbose</code></h4>
<p>This displays a summary of scanner statistics.</p>
<h4><code>-w</code>, <code>−−nowarn</code></h4>
<p>This disables warnings.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-options-miscellaneous"></a>
Miscellaneous options</h3>
<h4><code>-h</code>, <code>−−help</code></h4>
<p>This displays helpful information about <b>reflex</b>.</p>
<h4><code>-V</code>, <code>−−version</code></h4>
<p>This displays the current <b>reflex</b> release version.</p>
<h4><code>−−yylineno</code>, <code>−−yymore</code></h4>
<p>These options are enabled by default and have no effect.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-spec"></a>
Lexer specifications                                             </h2>
<p>A lexer specification consists of three sections that are divided by <code>%%</code> delimiters:</p>
<div class="alt"> <div class="fragment"><div class="line">Definitions</div><div class="line">%%</div><div class="line">Rules</div><div class="line">%%</div><div class="line">User code</div></div><!-- fragment --> </div><p>The definitions section is used to define named regex patterns, to set options for the scanner, and for including C++ declarations.</p>
<p>The rules section is the main workhorse of the scanner and consists of patterns and actions, where patterns may use named regex patterns that are defined in the definitions section. The actions are executed when patterns match. For example, the following lexer specification replaces all occurrences of <code>cow</code> by <code>chick</code>:</p>
<div class="alt"> <div class="fragment"><div class="line">%%</div><div class="line">cow      out() &lt;&lt; <span class="stringliteral">&quot;chick&quot;</span>;</div><div class="line">%%</div></div><!-- fragment --> </div><p>The default rule is to echo any input character that is read from input that does not match a rule in the rules section, so all other text is faithfully reproduced.</p>
<p>Because the pattern <code>cow</code> also matches words partly we get <code>chicks</code> for <code>cows</code>. But we also get badly garbled output for words such as <code>coward</code> and we are skipping capitalized Cows. We can improve this with a pattern that anchors word boundaries and accepts a lower or upper case C:</p>
<div class="alt"> <div class="fragment"><div class="line">cow      \&lt;[Cc]ow\&gt;</div><div class="line">%%</div><div class="line">{cow}    out() &lt;&lt; text()[0] &lt;&lt; <span class="stringliteral">&quot;hick&quot;</span>;</div><div class="line">%%</div></div><!-- fragment --> </div><p>Note that we defined a named pattern <code>cow</code> in the definitions section to match the start and end of (capitalized) "cow" word with the regex <code>\&lt;[Cc]ow\&gt;</code>. We use <code>{cow}</code> in our rule for matching. The matched text first character is emitted with <code>text()[0]</code> and we simply add "hick" to complete our chick.</p>
<p>Note that regex grouping with parenthesis to capture text matched by a parenthesized sub-regex is generally not supported by scanner generators, so we have to use the entire matched <code>text()</code> string.</p>
<p>Flex and Lex do not support word boundary anchors <code>\&lt;</code>, <code>\&gt;</code>, <code>\b</code>, and <code>\B</code> so this example only works with RE/flex.</p>
<p>If you are wondering about the action code in our example not exactly reflecting the C code expected with Flex, then rest assured that RE/flex supports the classic Flex and Lex actions such as <code>yytext</code> instead of <code>text()</code> and <code>*yyout</code> instead of <code>out()</code>. Simply use option <code>−−flex</code> to regress to the C-style Flex names and actions. Use options <code>−−flex</code> and <code>−−bison</code> to regress even further to generated a global <code>yylex()</code> function and "yy" variables.</p>
<p>To create a stand-alone scanner, we add <code>main</code> to the user code section:</p>
<div class="alt"> <div class="fragment"><div class="line">cow      \&lt;[Cc]ow\&gt;</div><div class="line">%%</div><div class="line">{cow}    out() &lt;&lt; text()[0] &lt;&lt; <span class="stringliteral">&quot;hick&quot;</span>;</div><div class="line">%%</div><div class="line"><span class="keywordtype">int</span> <a class="code" href="reflex_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() { <span class="keywordflow">return</span> Lexer().lex(); }</div></div><!-- fragment --> </div><p>The main function instantiates the lexer class and invokes the scanner, which will not return until the entire input is processed.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-spec-defs"></a>
The definitions section</h3>
<p>The definitions section includes name-pattern pairs to define names for patterns. Named patterns can be referenced in regex patterns by embracing them in <code>{</code> and <code>}</code>.</p>
<p>The following example defines two names for two patterns, where the second regex pattern uses the previously named pattern:</p>
<div class="alt"> <div class="fragment"><div class="line">digit     [0-9]</div><div class="line">number    {digit}+</div></div><!-- fragment --> </div><p>Patterns ending in an escape <code>\</code> continue on the next line with optional line indentation. This permits layout of long patterns.</p>
<p>Names must be defined before being referenced. Names are expanded as macros in regex patterns. For example, <code>{digit}+</code> is expanded into <code>[0-9]+</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This is not entirely accurate: when a name is expanded to its right-hand side pattern <code>φ</code> then the expanded pattern <code>φ</code> is placed in a non-capturing group <code>(?:φ)</code> to preserve its structure. For example, <code>{number}</code> expands to <code>(?:{digit}+)</code> which in turn expands to <code>(?:(?:[0-9])+)</code>.</dd></dl>
<p>To inject code into the generated scanner, indent the code or place the code within a <code>%{</code> and <code>%}</code>. The <code>%{</code> and <code>%}</code> should be placed at the start of a new line. To inject code at the very top of the generated scanner, place this code within <code>%top{</code> and <code>%}</code>:</p>
<div class="alt"> <div class="fragment"><div class="line">%top{</div><div class="line"><span class="preprocessor">  #include &lt;iostream&gt;</span>    <span class="comment">// std::cout etc.</span></div><div class="line">%}</div></div><!-- fragment --> </div><p>The definitions section may also contain one or more options with <code>%option</code> (or <code>%o</code> for short). For example:</p>
<div class="alt"> <div class="fragment"><div class="line">%option <a class="code" href="namespacereflex_1_1convert__flag.html#ab6a63c3a106c2dbcbad7b86797453f58">dotall</a> <a class="code" href="reflex_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="line">%o matcher=boost</div></div><!-- fragment --> </div><p>Multiple options can be grouped on the same line as is shown above. See <a class="el" href="index.html#reflex-options">Command-line options </a> for a list of available options.</p>
<dl class="section note"><dt>Note</dt><dd>Options <code>freespace</code>, <code>case-insensitive</code>, <code>dotall</code>, and <code>unicode</code> affect the named patterns defined in the definitions section. Therefore, we should place these options ahead of all named patterns. If a regex pattern specifically requires one or more of these options, use the <code>(?isx:φ)</code> modifier(s), see <a class="el" href="index.html#reflex-patterns">Patterns </a>.</dd></dl>
<p>Consider the following example. Say we want to count the number of occurrences of the word "cow" in some text. We declare a global counter, increment the counter when we see a "cow", and finally report the total tally when we reach the end of the input marked by the <code>&lt;&lt;EOF&gt;&gt;</code> rule:</p>
<div class="alt"> <div class="fragment"><div class="line">%option <a class="code" href="namespacereflex_1_1convert__flag.html#ab6a63c3a106c2dbcbad7b86797453f58">dotall</a> <a class="code" href="reflex_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="line"></div><div class="line">%top{</div><div class="line"><span class="preprocessor">  #include &lt;iostream&gt;</span>    <span class="comment">// std::cout etc.</span></div><div class="line">%}</div><div class="line"></div><div class="line">%{</div><div class="line">  <span class="keyword">static</span> <span class="keywordtype">int</span> herd = 0;   <span class="comment">// a global static variable to count cows</span></div><div class="line">%}</div><div class="line"></div><div class="line">cow        \&lt;[Cc]ow\&gt;</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">{cow}      herd++;       <span class="comment">// found a cow, bump count by one</span></div><div class="line">.          <span class="comment">// do nothing</span></div><div class="line">&lt;&lt;EOF&gt;&gt;    out() &lt;&lt; herd &lt;&lt; <span class="stringliteral">&quot; cows!&quot;</span> &lt;&lt; std::endl; <span class="keywordflow">return</span> 0;</div><div class="line"></div><div class="line">%%</div></div><!-- fragment --> </div><p>The above works fine, but we are using a global counter which is not a best practice and is not MT-safe or reentrant: multiple Lexer class instances may compete to bump the counter. Another problem is that the Lexer can only be used once, there is no proper initialization to restart the Lexer on new input.</p>
<p>RE/flex allows you to inject code in the generated Lexer class, meaning that class members and constructor code can be added to manage the Lexer class state. All Lexer class members are visible in actions, even when private. New Lexers can be instantiated given some input to scan. Lexers can run in parallel in threads without requiring synchronization when their state is part of the instance and not managed by global variables.</p>
<p>To inject Lexer class member declarations such as variables and methods, place the declarations within <code>%class{</code> and <code>%}</code>. The <code>%class{</code> and <code>%}</code> should be placed at the start of a new line.</p>
<p>Likewise, to inject Lexer class constructor code, for example to initialize members, place the code within <code>%init{</code> and <code>%}</code>. The <code>%init{</code> and <code>%}</code> should be placed at the start of a new line.</p>
<p>Additional constructors and/or a destructor may be placed in <code>%class{</code> and <code>%}</code>, using the class name <code>Lexer</code> (or <code>yyFlexLexer</code> with option <code>−−flex</code>), unless the class is renamed with option <code>−−lexer=NAME</code> (<code>%option lexer=NAME</code>). For convenience you can use the <code>REFLEX_OPTION_lexer</code> macro in your code that expands to the class name. To do so, use <b>reflex</b> option <code>−−header-file</code> to generate a header file to include in your code.</p>
<p>For example, we use these code injectors to make our cow counter <code>herd</code> part of the Lexer class state:</p>
<div class="alt"> <div class="fragment"><div class="line">%option <a class="code" href="namespacereflex_1_1convert__flag.html#ab6a63c3a106c2dbcbad7b86797453f58">dotall</a> <a class="code" href="reflex_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="line"></div><div class="line">%top{</div><div class="line"><span class="preprocessor">  #include &lt;iostream&gt;</span>    <span class="comment">// std::cout etc.</span></div><div class="line">%}</div><div class="line"></div><div class="line">%<span class="keyword">class</span>{</div><div class="line">  <span class="keywordtype">int</span> herd;  <span class="comment">// lexer class member variable (private by default)</span></div><div class="line">%}</div><div class="line"></div><div class="line">%init{</div><div class="line">  herd = 0;  <span class="comment">// initialize member variable in Lexer class constructor</span></div><div class="line">%}</div><div class="line"></div><div class="line">cow        \&lt;[Cc]ow\&gt;</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">{cow}      herd++;       <span class="comment">// found a cow, bump count by one</span></div><div class="line">.          <span class="comment">// do nothing</span></div><div class="line">&lt;&lt;EOF&gt;&gt;    out() &lt;&lt; herd &lt;&lt; <span class="stringliteral">&quot; cows!&quot;</span> &lt;&lt; std::endl; <span class="keywordflow">return</span> 0;</div><div class="line"></div><div class="line">%%</div></div><!-- fragment --> </div><p>Note that nothing else needed to be changed, because the actions are part of the generated Lexer class and can access the Lexer class members, in this example the member variable <code>herd</code>.</p>
<p>To modularize specifications of lexers, use <code>%include</code> (or <code>%i</code> for short) to include files into the definitions section of a specification. For example:</p>
<div class="alt"> <div class="fragment"><div class="line">%include <span class="stringliteral">&quot;examples/jdefs.l&quot;</span></div></div><!-- fragment --> </div><p>This includes examples/jdefs.l with Java patterns into the current specification so you can match Java lexical structures, such as copying Java identifiers to the output given some Java source program as input:</p>
<div class="alt"> <div class="fragment"><div class="line">%include <span class="stringliteral">&quot;examples/jdefs.l&quot;</span></div><div class="line">%%</div><div class="line">{Identifier}    echo();</div><div class="line">.|\n            <span class="comment">// do nothing</span></div><div class="line">%%</div></div><!-- fragment --> </div><p>To declare start condition state names use <code>%state</code> (<code>%s</code> for short) to declare inclusive states and use <code>%xstate</code> (<code>%x</code> for short) to declare exclusive states:</p>
<div class="alt"> <div class="fragment"><div class="line">%s INCLUSIVE</div><div class="line">%x EXCLUSIVE</div></div><!-- fragment --> </div><p>See <a class="el" href="index.html#reflex-states">Start condition states </a> for more information about states.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-spec-rules"></a>
The rules section</h3>
<p>Each rule in the rules section consists of a pattern-action pair. For example, the following defines an action for a pattern:</p>
<div class="alt"> <div class="fragment"><div class="line">{number}    out() &lt;&lt; <span class="stringliteral">&quot;number &quot;</span> &lt;&lt; text() &lt;&lt; std::endl;</div></div><!-- fragment --> </div><p>To add action code that spans multiple lines, indent the code or place the code within a <code>{</code> and <code>}</code> code block. When local variables are declared in an action then the code should always be placed in a code block.</p>
<p>In free space mode you MUST place actions in <code>{</code> and <code>}</code> blocks and other code in <code>%{</code> and <code>%}</code> instead of indented.</p>
<p>Actions in the rules section can use predefined RE/flex variables and functions. With <b>reflex</b> option <code>−−flex</code>, the variables and functions are the classic Flex actions shown in the second column of this table:</p>
<table class="doxtable">
<tr>
<th>RE/flex action </th><th>Flex action </th><th>Result  </th></tr>
<tr>
<td><code>text()</code> </td><td><code>YYText()</code>, <code>yytext</code> </td><td>NUL-terminated text match </td></tr>
<tr>
<td><code>str()</code> </td><td><em>n/a</em> </td><td><code>std::string</code> of <code>text()</code> </td></tr>
<tr>
<td><code>wstr()</code> </td><td><em>n/a</em> </td><td><code>std::wstring</code> of <code>text()</code> </td></tr>
<tr>
<td><code>size()</code> </td><td><code>YYLeng()</code>, <code>yyleng</code> </td><td>size of the match in bytes </td></tr>
<tr>
<td><code>wsize()</code> </td><td><em>n/a</em> </td><td>number of wide chars matched </td></tr>
<tr>
<td><code>lineno()</code> </td><td><code>yylineno</code> </td><td>line number of match (&gt;=1) </td></tr>
<tr>
<td><code>columno()</code> </td><td><em>n/a</em> </td><td>column number of match (&gt;=0) </td></tr>
<tr>
<td><code>echo()</code> </td><td><code>ECHO</code> </td><td><code>out().write(text(), size())</code> </td></tr>
<tr>
<td><code>in(i)</code> </td><td><code><a class="el" href="flexlexer_8h.html#a4ecb7d50aa442ca3a95ef3cc806a911a" title="Flex-compatible macro: restart from the given input source. ">yyrestart(i)</a></code> </td><td>set input to <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> i</code> </td></tr>
<tr>
<td><code>in()</code>, <code>in() = &amp;i</code> </td><td><code>*yyin</code>, <code>yyin = &amp;i</code> </td><td>get/set <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> object </td></tr>
<tr>
<td><code>out(s)</code> </td><td><code>yyout = &amp;s</code> </td><td>set output to <code>std::ostream s</code> </td></tr>
<tr>
<td><code>out()</code> </td><td><code>*yyout</code> </td><td>get <code>std::ostream</code> object </td></tr>
<tr>
<td><code>out().write(s, n)</code> </td><td><code>LexerOutput(s, n)</code> </td><td>output chars <code>s[0..n-1]</code> </td></tr>
<tr>
<td><code>out().put(c)</code> </td><td><code>output(c)</code> </td><td>output char <code>c</code> </td></tr>
<tr>
<td><code>start(n)</code> </td><td><code>BEGIN n</code> </td><td>set start condition to <code>n</code> </td></tr>
<tr>
<td><code>start()</code> </td><td><code>YY_START</code> </td><td>get current start condition </td></tr>
<tr>
<td><code>push_state(n)</code> </td><td><code>yy_push_state(n)</code> </td><td>push current state, start <code>n</code> </td></tr>
<tr>
<td><code>pop_state()</code> </td><td><code>yy_pop_state()</code> </td><td>pop state and make it current </td></tr>
<tr>
<td><code>top_state()</code> </td><td><code>yy_top_state()</code> </td><td>get top state start condition </td></tr>
<tr>
<td><code>matcher().accept()</code> </td><td><code>yy_act</code> </td><td>number of the matched rule </td></tr>
<tr>
<td><code>matcher().text()</code> </td><td><code>YYText()</code>, <code>yytext</code> </td><td>same as <code>text()</code> </td></tr>
<tr>
<td><code>matcher().str()</code> </td><td><em>n/a</em> </td><td>same as <code>str()</code> </td></tr>
<tr>
<td><code>matcher().wstr()</code> </td><td><em>n/a</em> </td><td>same as <code>wstr()</code> </td></tr>
<tr>
<td><code>matcher().size()</code> </td><td><code>YYLeng()</code>, <code>yyleng</code> </td><td>same as <code>size()</code> </td></tr>
<tr>
<td><code>matcher().wsize()</code> </td><td><em>n/a</em> </td><td>same as <code>wsize()</code> </td></tr>
<tr>
<td><code>matcher().input()</code> </td><td><code><a class="el" href="flexlexer_8h.html#a411db26910a55c4e92a226dee582564b" title="Flex-compatible macro: read one character, returns zero when EOF. ">yyinput()</a></code> </td><td>get next char from input </td></tr>
<tr>
<td><code>matcher().winput()</code> </td><td><em>n/a</em> </td><td>get wide character from input </td></tr>
<tr>
<td><code>matcher().unput(c)</code> </td><td><code>unput(c)</code> </td><td>put back 8-bit char <code>c</code> </td></tr>
<tr>
<td><code>matcher().peek()</code> </td><td><em>n/a</em> </td><td>peek at next char on input </td></tr>
<tr>
<td><code>matcher().more()</code> </td><td><code><a class="el" href="flexlexer_8h.html#a5de61440b4ccefd409a06728ec4734a6" title="Flex-compatible macro: append the next matched text to the currently matched text (use only when scan...">yymore()</a></code> </td><td>concat next match to the match </td></tr>
<tr>
<td><code>matcher().less(n)</code> </td><td><code><a class="el" href="flexlexer_8h.html#a1964ef51119f7cfb659f2f342ba24a02" title="Flex-compatible macro: truncate the yytext length of the match to n characters in length and repositi...">yyless(n)</a></code> </td><td>shrink match's length to <code>n</code> </td></tr>
<tr>
<td><code>matcher().first()</code> </td><td><em>n/a</em> </td><td>first pos of match in input </td></tr>
<tr>
<td><code>matcher().last()</code> </td><td><em>n/a</em> </td><td>last pos+1 of match in input </td></tr>
<tr>
<td><code>matcher().rest()</code> </td><td><em>n/a</em> </td><td>get rest of input until end </td></tr>
<tr>
<td><code>matcher().at_bob()</code> </td><td><em>n/a</em> </td><td>true if at the begin of input </td></tr>
<tr>
<td><code>matcher().at_end()</code> </td><td><em>n/a</em> </td><td>true if at the end of input </td></tr>
<tr>
<td><code>matcher().at_bol()</code> </td><td><code><a class="el" href="flexlexer_8h.html#ab0f58747b9e45b4d0732833f3886a128" title="Flex-compatible macro: at-begin-of-line check (use only when scanner has started). ">YY_AT_BOL()</a></code> </td><td>true if at begin of a newline </td></tr>
<tr>
<td><code>set_debug(n)</code> </td><td><code>set_debug(n)</code> </td><td>reflex option <code>-d</code> sets <code>n=1</code> </td></tr>
<tr>
<td><code>debug()</code> </td><td><code>debug()</code> </td><td>nonzero when debugging </td></tr>
</table>
<p>Note that Flex <code>switch_streams(i, o)</code> is the same as invoking the <code>in(i)</code> and <code>out(o)</code> methods. Flex <code><a class="el" href="flexlexer_8h.html#a4ecb7d50aa442ca3a95ef3cc806a911a" title="Flex-compatible macro: restart from the given input source. ">yyrestart(i)</a></code> is the same as invoking <code>in(i)</code> to set input to a file, stream, or string. Invoking <code>switch_streams(i, o)</code> and <code>in(i)</code> also resets the lexer's matcher (internally with <code>matcher.reset()</code>). This clears the line and column counters, resets the internal anchor and boundary flags for anchor and word boundary matching, and resets the matcher to consume buffered input.</p>
<p>You can also set the input with <code>in() = &amp;i</code> (or <code>yyin = &amp;i)</code> with option <code>−−flex</code>). This does not reset the matcher. This means that when an end of input (EOF) was reached, you should clear the EOF state with <code>matcher().set_end(false)</code> or reset the matcher state with <code>matcher().reset()</code>.</p>
<p>The <code>matcher().input()</code>, <code>matcher().winput()</code>, and <code>matcher().peek()</code> methods return EOF (-1) when the end of input is reached.</p>
<dl class="section warning"><dt>Warning</dt><dd>The Flex-compatible <code><a class="el" href="flexlexer_8h.html#a411db26910a55c4e92a226dee582564b" title="Flex-compatible macro: read one character, returns zero when EOF. ">yyinput()</a></code> returns 0 when the end of input is reached, which makes it impossible to distinguish <code>\0</code> (NUL) from EOF.</dd>
<dd>
Do not invoke <code>matcher()</code> before <code><a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">lex()</a></code> (or <code>yylex()</code> with option <code>−−flex</code>) is invoked! A matcher is not initially assigned to the lexer when it is constructed.</dd></dl>
<p>Use <b>reflex</b> options <code>−−flex</code> and <code>−−bison</code> to enable global Flex actions and variables. This makes Flex actions and variables globally accessible outside of the rules section, with the exception of <code>yy_push_state</code>, <code>yy_pop_state</code>, <code>yy_top_state</code>. Outside the rules section you must use the global action <code>yyinput</code> instead of <code>input</code>, global action <code>yyunput</code> instead of <code>unput</code>, and global action <code>yyoutput</code> instead of <code>output</code>. Because <code>yyin</code> and <code>yyout</code> are macros they cannot be (re)declared or accessed as global variables, but they can be used as if these were variables. To avoid compilation errors, use <b>reflex</b> option <code>−−header-file</code> to generate a header file <code>lex.yy.h</code> to include in your code to use the global use Flex actions and variables. See <a class="el" href="index.html#reflex-bison">Interfacing with Bison/Yacc </a> for more details on the <code>−−bison</code> options to use.</p>
<p>From the first couple of entries in the table shown above you may have guessed correctly that <code>text()</code> is just a shorthand for <code>matcher().text()</code>, since <code>matcher()</code> is the matcher object associated with the generated Lexer class. The same shorthands apply to <code>str()</code>, <code>wstr()</code>, <code>size()</code>, <code>wsize()</code>, <code>lineno()</code> and <code>columno()</code>. Use <code>text()</code> for fast access to the matched text. The <code>str()</code> method returns a string copy of the match and is less efficient.</p>
<p>Because <code>matcher()</code> returns the current matcher object, the following Flex-like actions are also supported:</p>
<table class="doxtable">
<tr>
<th>RE/flex action </th><th>Flex action </th><th>Result  </th></tr>
<tr>
<td><code>matcher().buffer()</code> </td><td><em>n/a</em> </td><td>buffer entire input </td></tr>
<tr>
<td><code>matcher().buffer(n)</code> </td><td><em>n/a</em> </td><td>set buffer size to <code>n</code> </td></tr>
<tr>
<td><code>matcher().interactive()</code> </td><td><code><a class="el" href="flexlexer_8h.html#a83e55b4e09de54e0f7c1b00ebd255a57" title="Flex-compatible macro: interactive mode on/off (use only when scanner has started). ">yy_set_interactive(1)</a></code> </td><td>set interactive input </td></tr>
<tr>
<td><code>matcher().flush()</code> </td><td><code>YY_FLUSH_BUFFER</code> </td><td>flush input buffer </td></tr>
<tr>
<td><code>matcher().get(s, n)</code> </td><td><code>LexerInput(s, n)</code> </td><td>read <code>s[0..n-1]</code> </td></tr>
<tr>
<td><code>matcher().set_bol(b)</code> </td><td><code><a class="el" href="flexlexer_8h.html#a2669724201ee38c6ebc5ffe8f893d172" title="Flex-compatible macro: a begin-of-line forced set (use only when scanner has started). ">yy_set_bol(b)</a></code> </td><td>set begin of line </td></tr>
<tr>
<td><code>matcher().set_end(b)</code> </td><td><em>n/a</em> </td><td>set EOF flag to <code>b</code> </td></tr>
<tr>
<td><code>matcher().reset()</code> </td><td><em>n/a</em> </td><td>reset the state as new </td></tr>
</table>
<p>You can switch to a new matcher while scanning input, and use operations to create a new matcher, push/pop a matcher on/from a stack, and delete a matcher:</p>
<table class="doxtable">
<tr>
<th>RE/flex action </th><th>Flex action </th><th>Result  </th></tr>
<tr>
<td><code>matcher(m)</code> </td><td><code><a class="el" href="flexlexer_8h.html#a97d5ac1e34fadb1c7121a3bb9837a973" title="Flex-compatible macro: switch to another buffer. ">yy_switch_to_buffer(m)</a></code> </td><td>use matcher <code>m</code> </td></tr>
<tr>
<td><code>new_matcher(i)</code> </td><td><code><a class="el" href="flexlexer_8h.html#aaa025493affa705e21d5b1ac1f9c004f" title="Flex-compatible macro: create and return a new buffer. ">yy_create_buffer(i, n)</a></code> </td><td>new matcher <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> i</code> </td></tr>
<tr>
<td><code>del_matcher(m)</code> </td><td><code><a class="el" href="flexlexer_8h.html#a252001f79f2c35d4b76ad3a43432371d" title="Flex-compatible macro: delete a buffer. ">yy_delete_buffer(m)</a></code> </td><td>delete matcher <code>m</code> </td></tr>
<tr>
<td><code>push_matcher(m)</code> </td><td><code><a class="el" href="flexlexer_8h.html#a3807e0a231906457045e429d6721f291" title="Flex-compatible macro: push the current buffer on the stack to use the given buffer. ">yypush_buffer_state(m)</a></code> </td><td>push current matcher, use <code>m</code> </td></tr>
<tr>
<td><code>pop_matcher()</code> </td><td><code><a class="el" href="flexlexer_8h.html#a5a5ee4eb3501fe9673a0ad2263a4c5cc" title="Flex-compatible macro: pop buffer from the stack and delete the current buffer. ">yypop_buffer_state()</a></code> </td><td>pop matcher and delete current </td></tr>
<tr>
<td><code>ptr_matcher()</code> </td><td><code>YY_CURRENT_BUFFER</code> </td><td>pointer to current matcher </td></tr>
</table>
<p>The matcher type <code>m</code> is a Lexer class-specific <code>Matcher</code> type, which depends on the underlying matcher used by the scanner. Therefore, <code>new_matcher(i)</code> instantiates a <code><a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a></code> or <code><a class="el" href="classreflex_1_1_boost_posix_matcher.html" title="Boost matcher engine class, extends reflex::BoostMatcher for Boost POSIX regex matching. ">reflex::BoostPosixMatcher</a></code> depending on the <code>−−matcher</code> option.</p>
<p>The Flex <code><a class="el" href="flexlexer_8h.html#afd47859dde5a17ec41867674dc65d03a" title="Flex-compatible macro: scan a string, returns NULL buffer because we don&#39;t allocate anything...">yy_scan_string(string)</a></code> and <code><a class="el" href="flexlexer_8h.html#a65add7262b009a8828e8582986473f9c" title="Flex-compatible macro: scan raw bytes, returns NULL buffer because we don&#39;t allocate anything...">yy_scan_bytes(bytes, len)</a></code> functions are also supported with <b>reflex</b> option <code>−−flex</code> and are simply creating setting the matcher's <code>in(i)</code> input to a string.</p>
<p>The generated scanner reads from the standard input by default or from an input source specified as a <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> object, such as a string, wide string, file, or a stream.</p>
<p>See <a class="el" href="index.html#reflex-input">Switching input sources </a> for more details on managing the input to a scanner.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-spec-user"></a>
User code sections</h3>
<p>To inject code at the end of the generated scanner, such as a <code>main</code> function, we can use the third and fnal User Code section. All of the code in the User Code section is copied to the generated scanner.</p>
<p>Below is a User Code section example with <code>main</code> that invokes the lexer to read from standard input (the default input) and display all numbers found:</p>
<div class="alt"> <div class="fragment"><div class="line">%top{</div><div class="line"><span class="preprocessor">  #include &lt;iostream&gt;</span></div><div class="line">%}</div><div class="line"></div><div class="line">digit       [0-9]</div><div class="line">number      {digit}+</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">{number}    out() &lt;&lt; <span class="stringliteral">&quot;number &quot;</span> &lt;&lt; text() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="reflex_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>() { <span class="keywordflow">return</span> Lexer().lex(); }</div></div><!-- fragment --> </div><p>You can also automatically generate a <code>main</code> with the <b>reflex</b> <code>−−main</code> option, which will produce the same <code>main</code> function shown in the example above. This creates a stand-alone scanner that instantiates a Lexer that reads input from standard input.</p>
<p>To scan from other input than standard input, such as from files, streams, and strings, instantiate the Lexer class with the input source as the first argument. To set an alternative output stream than standard output, pass a <code>std::ostream</code> object as the second argument to the Lexer class constructor:</p>
<div class="alt"> <div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="reflex_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  FILE *fd = stdin;</div><div class="line">  <span class="keywordflow">if</span> (argc &gt; 1 &amp;&amp; (fd = fopen(argv[1], <span class="stringliteral">&quot;r&quot;</span>)) == NULL)</div><div class="line">    exit(EXIT_FAILURE);</div><div class="line">  std::ofstream of(<span class="stringliteral">&quot;output.txt&quot;</span>, std::ofstream::out);</div><div class="line">  <span class="keywordflow">if</span> (!of)</div><div class="line">    exit(EXIT_FAILURE);</div><div class="line">  Lexer(fd, of).lex();</div><div class="line">  of.close();</div><div class="line">  <span class="keywordflow">if</span> (fd != stdin)</div><div class="line">    fclose(fd);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div><p>The above uses a <code>FILE</code> descriptor to read input from, which has the advantage of automatically decoding UTF-8/16/32 input. Other permissible input sources are <code>std::istream</code>, <code>std::string</code>, <code>std::wstring</code>, <code>char*</code>, and <code>wchar_t*</code>.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-patterns"></a>
Patterns                                                     </h2>
<p>Regex pattern syntax depends on the regex matcher library being used. However, lexer specifications accept a broad pattern syntax that extends the Flex/Lex pattern syntax. The <b>reflex</b> command internally converts patterns to regex forms that the underlying matcher engine library supports. This ensures that the same pattern syntax can be used with any matcher engine library.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-pattern-syntax"></a>
Pattern syntax</h3>
<p>A pattern is an extended set of regular expressions, with nested sub-expression patterns <code>φ</code> and <code>ψ</code>:</p>
<table class="doxtable">
<tr>
<th>Pattern </th><th>Matches  </th></tr>
<tr>
<td><code>x</code> </td><td>matches the character <code>x</code>, where <code>x</code> is not a special character </td></tr>
<tr>
<td><code>.</code> </td><td>matches any single character except newline (unless in dotall mode) </td></tr>
<tr>
<td><code>\.</code> </td><td>matches <code>.</code> (dot), special characters are escaped with a backslash </td></tr>
<tr>
<td><code>\n</code> </td><td>matches a newline, others are <code>\a</code> (BEL), <code>\b</code> (BS), <code>\t</code> (HT), <code>\v</code> (VT), <code>\f</code> (FF), and <code>\r</code> (CR) </td></tr>
<tr>
<td><code>\0</code> </td><td>matches the NUL character </td></tr>
<tr>
<td><code>\cX</code> </td><td>matches the control character <code>X</code> mod 32 (e.g. <code>\cA</code> is <code>\x01</code>) </td></tr>
<tr>
<td><code>\0177</code> </td><td>matches an 8-bit character with octal value <code>177</code> (see below) </td></tr>
<tr>
<td><code>\x7f</code> </td><td>matches an 8-bit character with hexadecimal value <code>7f</code> </td></tr>
<tr>
<td><code>\x{7f}</code> </td><td>matches an 8-bit character with hexadecimal value <code>7f</code> </td></tr>
<tr>
<td><code>\p{C}</code> </td><td>matches a character in category C </td></tr>
<tr>
<td><code>\Q..\E</code> </td><td>matches the quoted content between <code>\Q</code> and <code>\E</code> literally </td></tr>
<tr>
<td><code>[abc]</code> </td><td>matches one of <code>a</code>, <code>b</code>, or <code>c</code> (character class in bracket list) </td></tr>
<tr>
<td><code>[0-9]</code> </td><td>matches a digit <code>0</code> to <code>9</code> (character class range) </td></tr>
<tr>
<td><code>[^0-9]</code> </td><td>matches any character but a digit (negative list) </td></tr>
<tr>
<td><code>φ?</code> </td><td>matches <code>φ</code> zero or one time (optional) </td></tr>
<tr>
<td><code>φ*</code> </td><td>matches <code>φ</code> zero or more times (repetition) </td></tr>
<tr>
<td><code>φ+</code> </td><td>matches <code>φ</code> one or more times (repetition) </td></tr>
<tr>
<td><code>φ{2,5}</code> </td><td>matches <code>φ</code> two to five times (repetition) </td></tr>
<tr>
<td><code>φ{2,}</code> </td><td>matches <code>φ</code> at least two times (repetition) </td></tr>
<tr>
<td><code>φ{2}</code> </td><td>matches <code>φ</code> exactly two times (repetition) </td></tr>
<tr>
<td><code>φ??</code> </td><td>matches <code>φ</code> zero or once as needed (lazy optional) </td></tr>
<tr>
<td><code>φ*?</code> </td><td>matches <code>φ</code> a minimum number of times as needed (lazy repetition) </td></tr>
<tr>
<td><code>φ+?</code> </td><td>matches <code>φ</code> a minimum number of times at least once as needed (lazy repetition) </td></tr>
<tr>
<td><code>φ{2,5}?</code> </td><td>matches <code>φ</code> two to five times as needed (lazy repetition) </td></tr>
<tr>
<td><code>φ{2,}?</code> </td><td>matches <code>φ</code> at least two times or more as needed (lazy repetition) </td></tr>
<tr>
<td><code>φψ</code> </td><td>matches <code>φ</code> then matches <code>ψ</code> (concatenation) </td></tr>
<tr>
<td><code>φ⎮ψ</code> </td><td>matches <code>φ</code> or matches <code>ψ</code> (alternation) </td></tr>
<tr>
<td><code>(φ)</code> </td><td>matches <code>φ</code> as a group (capture) </td></tr>
<tr>
<td><code>(?:φ)</code> </td><td>matches <code>φ</code> without group capture </td></tr>
<tr>
<td><code>(?=φ)</code> </td><td>matches <code>φ</code> without consuming it (lookahead) </td></tr>
<tr>
<td><code>(?&lt;=φ)</code> </td><td>matches <code>φ</code> to the left without consuming it (lookbehind, not supported by the RE/flex matcher) </td></tr>
<tr>
<td><code>(?^φ)</code> </td><td>matches <code>φ</code> and ignore it to continue matching (RE/flex only) </td></tr>
<tr>
<td><code>^φ</code> </td><td>matches <code>φ</code> at the start of input or start of a line (multi-line mode) </td></tr>
<tr>
<td><code>φ$</code> </td><td>matches <code>φ</code> at the end of input or end of a line (multi-line mode) </td></tr>
<tr>
<td><code>\Aφ</code> </td><td>matches <code>φ</code> at the start of input </td></tr>
<tr>
<td><code>φ\z</code> </td><td>matches <code>φ</code> at the end of input </td></tr>
<tr>
<td><code>\bφ</code> </td><td>matches <code>φ</code> starting at a word boundary </td></tr>
<tr>
<td><code>φ\b</code> </td><td>matches <code>φ</code> ending at a word boundary </td></tr>
<tr>
<td><code>\Bφ</code> </td><td>matches <code>φ</code> starting at a non-word boundary </td></tr>
<tr>
<td><code>φ\B</code> </td><td>matches <code>φ</code> ending at a non-word boundary </td></tr>
<tr>
<td><code>\&lt;φ</code> </td><td>matches <code>φ</code> that starts as a word </td></tr>
<tr>
<td><code>\&gt;φ</code> </td><td>matches <code>φ</code> that starts as a non-word </td></tr>
<tr>
<td><code>φ\&lt;</code> </td><td>matches <code>φ</code> that ends as a non-word </td></tr>
<tr>
<td><code>φ\&gt;</code> </td><td>matches <code>φ</code> that ends as a word </td></tr>
<tr>
<td><code>(?i:φ)</code> </td><td><em>case insensitive mode</em>: matches <code>φ</code> ignoring case </td></tr>
<tr>
<td><code>(?m:φ)</code> </td><td><em>multi-line mode</em>: <code>^</code> and <code>$</code> in <code>φ</code> match begin and end of a line (default in lexer specifications) </td></tr>
<tr>
<td><code>(?s:φ)</code> </td><td><em>dotall mode</em>: <code>.</code> (dot) in <code>φ</code> matches newline </td></tr>
<tr>
<td><code>(?u:φ)</code> </td><td><em>unicode mode</em>: <code>.</code>, <code>\s</code>, <code>\w</code>, <code>\l</code>, <code>\u</code>, <code>\S</code>, <code>\W</code>, <code>\L</code>, <code>\U</code> match Unicode </td></tr>
<tr>
<td><code>(?x:φ)</code> </td><td><em>free space mode</em>: ignore all whitespace and comments in <code>φ</code> </td></tr>
<tr>
<td><code>(?#:..)</code> </td><td><em>comment</em>: all of <code>..</code> is skipped as a comment </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The lazy quantifier <code>?</code> for optional patterns <code>φ??</code> and repetitions <code>φ*?</code> <code>φ+?</code> is not supported by Boost.Regex in POSIX mode. In general, POSIX matchers do not support lazy quantifiers due to POSIX limitations that are rooted in the theory of formal languages FSM of regular expressions.</dd></dl>
<p>The following patterns use Flex/Lex syntax specific to lexer specifications and should only be used in specifications:</p>
<table class="doxtable">
<tr>
<th>Pattern </th><th>Matches  </th></tr>
<tr>
<td><code>\177</code> </td><td>matches an 8-bit character with octal value <code>177</code> </td></tr>
<tr>
<td><code>".."</code> </td><td>matches the quoted content literally </td></tr>
<tr>
<td><code>φ/ψ</code> </td><td>matches <code>φ</code> if followed by <code>ψ</code> (trailing context) </td></tr>
<tr>
<td><code>&lt;S&gt;φ</code> </td><td>matches <code>φ</code> only if state <code>S</code> is enabled </td></tr>
<tr>
<td><code>&lt;S1,S2,S3&gt;φ</code> </td><td>matches <code>φ</code> only if state <code>S1</code>, <code>S2</code>, or state <code>S3</code> is enabled </td></tr>
<tr>
<td><code>&lt;*&gt;φ</code> </td><td>matches <code>φ</code> in any state </td></tr>
<tr>
<td><code>&lt;&lt;EOF&gt;&gt;</code> </td><td>matches EOF in any state </td></tr>
<tr>
<td><code>&lt;S&gt;&lt;&lt;EOF&gt;&gt;</code> </td><td>matches EOF only if state <code>S</code> is enabled </td></tr>
<tr>
<td><code>[a-z]{+}[A-Z]</code> </td><td>matches a letter, same as <code>[a-z⎮⎮[A-Z]]</code> </td></tr>
<tr>
<td><code>[a-z]{-}[aeiou]</code> </td><td>matches a consonant, same as <code>[a-z−−[aeiou]]</code> </td></tr>
<tr>
<td><code>[a-z]{&amp;}[^aeiou]</code> </td><td>matches a consonant, same as <code>[a-z&amp;&amp;[^aeiou]]</code> </td></tr>
<tr>
<td><code>[a-z]{⎮}[A-Z]</code> </td><td>matches a letter, same as <code>[a-z⎮⎮[A-Z]]</code> </td></tr>
</table>
<p>Note that the characters <code>.</code> (dot), <code>\</code>, <code>?</code>, <code>*</code>, <code>+</code>, <code>|</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>^</code>, and <code>$</code> are meta-characters and should be escaped to match. Lexer specifications also include the <code>"</code> and <code>/</code> as meta-characters and these should be escaped to match.</p>
<p>The order of precedence for composing larger patterns from sub-patterns is as follows, from high to low precedence:</p>
<ol type="1">
<li>Characters, character classes, bracket expressions, escapes, quotation</li>
<li>Grouping <code>(φ)</code>, <code>(?:φ)</code>, <code>(?=φ)</code>, and inline modifiers <code>(?imsux:φ)</code></li>
<li>Quantifiers <code>?</code>, <code>*</code>, <code>+</code>, <code>{n,m}</code></li>
<li>Concatenation (including trailing context <code>φ/ψ</code>)</li>
<li>Anchoring <code>^</code>, <code>$</code>, <code>\&lt;</code>, <code>\&gt;</code>, <code>\b</code>, <code>\B</code>, <code>\A</code>, <code>\z</code></li>
<li>Alternation <code>|</code></li>
<li>Global modifiers <code>(?imsux)φ</code></li>
</ol>
<dl class="section note"><dt>Note</dt><dd>When using regex patterns in C++ literal strings, we need the "regex
escapes to be escaped", meaning that an extra backslash is needed for every backslash in the regex string.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Trigraphs in C++ strings are special three character sequences, beginning with two question marks and followed by one other character. Avoid <code>??</code> at all cost in C++ strings. Instead, use at least one escaped question mark, such as <code>?\?</code>, which the compiler will translate to <code>??</code>. Otherwise, lazy optional pattern constructs will appear broken. Fortunately, most C++ compilers will warn about trigraph translation before causing trouble.</dd></dl>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-pattern-class"></a>
Character classes</h3>
<p>Character classes in bracket lists are sets of characters. Sets can be inverted, subtracted, intersected, and merged:</p>
<table class="doxtable">
<tr>
<th>Pattern </th><th>Matches  </th></tr>
<tr>
<td><code>[a-zA-Z]</code> </td><td>matches a letter </td></tr>
<tr>
<td><code>[^a-zA-Z]</code> </td><td>matches a non-letter (character class inversion) </td></tr>
<tr>
<td><code>[a-z−−[aeiou]]</code> </td><td>matches a consonant (character class subtraction) </td></tr>
<tr>
<td><code>[a-z&amp;&amp;[^aeiou]]</code> </td><td>matches a consonant (character class intersection) </td></tr>
<tr>
<td><code>[a-z⎮⎮[A-Z]]</code> </td><td>matches a letter (character class union) </td></tr>
</table>
<p>Bracket lists cannot be empty, so <code>[]</code> and <code>[^]</code> are invalid. In fact, the first character after the bracket is always part of the list. So <code>[][]</code> is a list that matches a <code>]</code> and a <code>[</code>, <code>[^][]</code> is a list that matches anything but <code>]</code> and <code>[</code>, and <code>[-^]</code> is a list that matches a <code>-</code> and a <code>^</code>.</p>
<p>The character class sets may be Unicode character sets. In that case <a class="el" href="index.html#reflex-pattern-unicode">Unicode mode</a> should be enabled.</p>
<p>Shorthands for character classes are character categories, discussed next.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-patterns-cat"></a>
Character categories</h3>
<p>The 7-bit ASCII character categories are:</p>
<table class="doxtable">
<tr>
<th>Category </th><th>List form </th><th>Matches  </th></tr>
<tr>
<td><code>\p{Space}</code> </td><td><code>[[:space:]]</code> </td><td>matches a white space character <code>[ \t\n\v\f\r]</code> same as <code>\s</code> </td></tr>
<tr>
<td><code>\p{Xdigit}</code> </td><td><code>[[:xdigit:]]</code> </td><td>matches a hex digit <code>[0-9A-Fa-f]</code> </td></tr>
<tr>
<td><code>\p{Cntrl}</code> </td><td><code>[[:cntrl:]]</code> </td><td>matches a control character <code>[\x00-\0x1f\x7f]</code> </td></tr>
<tr>
<td><code>\p{Print}</code> </td><td><code>[[:print:]]</code> </td><td>matches a printable character <code>[\x20-\x7e]</code> </td></tr>
<tr>
<td><code>\p{Alnum}</code> </td><td><code>[[:alnum:]]</code> </td><td>matches a alphanumeric character <code>[0-9A-Za-z]</code> </td></tr>
<tr>
<td><code>\p{Alpha}</code> </td><td><code>[[:alpha:]]</code> </td><td>matches a letter <code>[A-Za-z]</code> </td></tr>
<tr>
<td><code>\p{Blank}</code> </td><td><code>[[:blank:]]</code> </td><td>matches a blank <code>[ \t]</code> same as <code>\h</code> </td></tr>
<tr>
<td><code>\p{Digit}</code> </td><td><code>[[:digit:]]</code> </td><td>matches a digit <code>[0-9]</code> same as <code>\d</code> </td></tr>
<tr>
<td><code>\p{Graph}</code> </td><td><code>[[:graph:]]</code> </td><td>matches a visible character <code>[\x21-\x7e]</code> </td></tr>
<tr>
<td><code>\p{Lower}</code> </td><td><code>[[:lower:]]</code> </td><td>matches a lower case letter <code>[a-z]</code> same as <code>\l</code> </td></tr>
<tr>
<td><code>\p{Punct}</code> </td><td><code>[[:punct:]]</code> </td><td>matches a punctuation character <code>[\x21-\x2f\x3a-\x40\x5b-\x60\x7b-\x7e]</code> </td></tr>
<tr>
<td><code>\p{Upper}</code> </td><td><code>[[:upper:]]</code> </td><td>matches an upper case letter <code>[A-Z]</code> same as <code>\u</code> </td></tr>
<tr>
<td><code>\p{Word}</code> </td><td><code>[[:word:]]</code> </td><td>matches a word character <code>[0-9A-Za-z_]</code> same as <code>\w</code> </td></tr>
<tr>
<td><code>\d</code> </td><td><code>[[:digit:]]</code> </td><td>matches a digit <code>[0-9]</code> </td></tr>
<tr>
<td><code>\D</code> </td><td><code>[^[:digit:]]</code> </td><td>matches a non-digit <code>[^0-9]</code> </td></tr>
<tr>
<td><code>\h</code> </td><td><code>[[:blank:]]</code> </td><td>matches a blank character <code>[ \t]</code> </td></tr>
<tr>
<td><code>\H</code> </td><td><code>[^[:blank:]]</code> </td><td>matches a non-blank character <code>[^ \t]</code> </td></tr>
<tr>
<td><code>\s</code> </td><td><code>[[:space:]]</code> </td><td>matches a white space character <code>[ \t\n\v\f\r]</code> </td></tr>
<tr>
<td><code>\S</code> </td><td><code>[^[:space:]]</code> </td><td>matches a non-white space <code>[^ \t\n\v\f\r]</code> </td></tr>
<tr>
<td><code>\l</code> </td><td><code>[[:lower:]]</code> </td><td>matches a lower case letter <code>[a-z]</code> </td></tr>
<tr>
<td><code>\L</code> </td><td><code>[^[:lower:]]</code> </td><td>matches a non-lower case letter <code>[^a-z]</code> </td></tr>
<tr>
<td><code>\u</code> </td><td><code>[[:upper:]]</code> </td><td>matches an upper case letter <code>[A-Z]</code> </td></tr>
<tr>
<td><code>\U</code> </td><td><code>[^[:upper:]]</code> </td><td>matches a nonupper case letter <code>[^A-Z]</code> </td></tr>
<tr>
<td><code>\w</code> </td><td><code>[[:word:]]</code> </td><td>matches a word character <code>[0-9A-Za-z_]</code> </td></tr>
<tr>
<td><code>\W</code> </td><td><code>[^[:word:]]</code> </td><td>matches a non-word character <code>[^0-9A-Za-z_]</code> </td></tr>
</table>
<p>The following Unicode character categories are enabled with the <b>reflex</b> <code>−−unicode</code> option and with the regex matcher converter flag <code><a class="el" href="namespacereflex_1_1convert__flag.html#ab1c057a380f8673a13064c755652dc39" title="convert . (dot), \s, \w, \l, \u, \S, \W, \L, \U to Unicode ">reflex::convert_flag::unicode</a></code> when using a regex library:</p>
<table class="doxtable">
<tr>
<th>Category </th><th>Matches  </th></tr>
<tr>
<td><code>.</code> </td><td>matches any Unicode character (beware of <a class="el" href="index.html#invalid-utf">Invalid UTF encodings </a>) </td></tr>
<tr>
<td><code>\X</code> </td><td>matches any ISO-8859-1 or Unicode character (with or without the <code>−−unicode</code> option) </td></tr>
<tr>
<td><code>\R</code> </td><td>matches a Unicode line break </td></tr>
<tr>
<td><code>\s</code>, <code>\p{Zs}</code> </td><td>matches a white space character with Unicode sub-propert Zs </td></tr>
<tr>
<td><code>\l</code>, <code>\p{Ll}</code> </td><td>matches a lower case letter with Unicode sub-property Ll </td></tr>
<tr>
<td><code>\u</code>, <code>\p{Lu}</code> </td><td>matches an upper case letter with Unicode sub-property Lu </td></tr>
<tr>
<td><code>\w</code>, <code>\p{Word}</code> </td><td>matches a Unicode word character with property L, Nd, or Pc </td></tr>
<tr>
<td><code>\p{Unicode}</code> </td><td>matches any Unicode character (U+00 to U+10FFFF minus U+D800 to U+DFFF) </td></tr>
<tr>
<td><code>\p{ASCII}</code> </td><td>matches an ASCII character U+00 to U+007F) </td></tr>
<tr>
<td><code>\p{Non_ASCII_Unicode}</code> </td><td>matches a non-ASCII character U+80 to U+10FFFF minus U+D800 to U+DFFF) </td></tr>
<tr>
<td><code>\p{Letter}</code> </td><td>matches a character with Unicode property Letter </td></tr>
<tr>
<td><code>\p{Mark}</code> </td><td>matches a character with Unicode property Mark </td></tr>
<tr>
<td><code>\p{Separator}</code> </td><td>matches a character with Unicode property Separator </td></tr>
<tr>
<td><code>\p{Symbol}</code> </td><td>matches a character with Unicode property Symbol </td></tr>
<tr>
<td><code>\p{Number}</code> </td><td>matches a character with Unicode property Number </td></tr>
<tr>
<td><code>\p{Punctuation}</code> </td><td>matches a character with Unicode property Punctuation </td></tr>
<tr>
<td><code>\p{Other}</code> </td><td>matches a character with Unicode property Other </td></tr>
<tr>
<td><code>\p{Lowercase_Letter}</code>, <code>\p{Ll}</code> </td><td>matches a character with Unicode sub-property Ll </td></tr>
<tr>
<td><code>\p{Uppercase_Letter}</code>, <code>\p{Lu}</code> </td><td>matches a character with Unicode sub-property Lu </td></tr>
<tr>
<td><code>\p{Titlecase_Letter}</code>, <code>\p{Lt}</code> </td><td>matches a character with Unicode sub-property Lt </td></tr>
<tr>
<td><code>\p{Modifier_Letter}</code>, <code>\p{Lm}</code> </td><td>matches a character with Unicode sub-property Lm </td></tr>
<tr>
<td><code>\p{Other_Letter}</code>, <code>\p{Lo}</code> </td><td>matches a character with Unicode sub-property Lo </td></tr>
<tr>
<td><code>\p{Non_Spacing_Mark}</code>, <code>\p{Mn}</code> </td><td>matches a character with Unicode sub-property Mn </td></tr>
<tr>
<td><code>\p{Spacing_Combining_Mark}</code>, <code>\p{Mc}</code> </td><td>matches a character with Unicode sub-property Mc </td></tr>
<tr>
<td><code>\p{Enclosing_Mark}</code>, <code>\p{Me}</code> </td><td>matches a character with Unicode sub-property Me </td></tr>
<tr>
<td><code>\p{Space_Separator}</code>, <code>\p{Zs}</code> </td><td>matches a character with Unicode sub-property Zs </td></tr>
<tr>
<td><code>\p{Line_Separator}</code>, <code>\p{Zl}</code> </td><td>matches a character with Unicode sub-property Zl </td></tr>
<tr>
<td><code>\p{Paragraph_Separator}</code>, <code>\p{Zp}</code> </td><td>matches a character with Unicode sub-property Zp </td></tr>
<tr>
<td><code>\p{Math_Symbol}</code>, <code>\p{Sm}</code> </td><td>matches a character with Unicode sub-property Sm </td></tr>
<tr>
<td><code>\p{Currency_Symbol}</code>, <code>\p{Sc}</code> </td><td>matches a character with Unicode sub-property Sc </td></tr>
<tr>
<td><code>\p{Modifier_Symbol}</code>, <code>\p{Sk}</code> </td><td>matches a character with Unicode sub-property Sk </td></tr>
<tr>
<td><code>\p{Other_Symbol}</code>, <code>\p{So}</code> </td><td>matches a character with Unicode sub-property So </td></tr>
<tr>
<td><code>\p{Decimal_Digit_Number}</code>, <code>\p{Nd}</code> </td><td>matches a character with Unicode sub-property Nd </td></tr>
<tr>
<td><code>\p{Letter_Number}</code>, <code>\p{Nl}</code> </td><td>matches a character with Unicode sub-property Nl </td></tr>
<tr>
<td><code>\p{Other_Number}</code>, <code>\p{No}</code> </td><td>matches a character with Unicode sub-property No </td></tr>
<tr>
<td><code>\p{Dash_Punctuation}</code>, <code>\p{Pd}</code> </td><td>matches a character with Unicode sub-property Pd </td></tr>
<tr>
<td><code>\p{Open_Punctuation}</code>, <code>\p{Ps}</code> </td><td>matches a character with Unicode sub-property Ps </td></tr>
<tr>
<td><code>\p{Close_Punctuation}</code>, <code>\p{Pe}</code> </td><td>matches a character with Unicode sub-property Pe </td></tr>
<tr>
<td><code>\p{Initial_Punctuation}</code>, <code>\p{Pi}</code> </td><td>matches a character with Unicode sub-property Pi </td></tr>
<tr>
<td><code>\p{Final_Punctuation}</code>, <code>\p{Pf}</code> </td><td>matches a character with Unicode sub-property Pf </td></tr>
<tr>
<td><code>\p{Connector_Punctuation}</code>, <code>\p{Pc}</code> </td><td>matches a character with Unicode sub-property Pc </td></tr>
<tr>
<td><code>\p{Other_Punctuation}</code>, <code>\p{Po}</code> </td><td>matches a character with Unicode sub-property Po </td></tr>
<tr>
<td><code>\p{Control}</code>, <code>\p{Cc}</code> </td><td>matches a character with Unicode sub-property Cc </td></tr>
<tr>
<td><code>\p{Format}</code>, <code>\p{Cf}</code> </td><td>matches a character with Unicode sub-property Cf </td></tr>
<tr>
<td><code>\p{UnicodeIdentifierStart}</code> </td><td>matches a character in the Unicode IdentifierStart class </td></tr>
<tr>
<td><code>\p{UnicodeIdentifierPart}</code> </td><td>matches a character in the Unicode IdentifierPart class </td></tr>
<tr>
<td><code>\p{IdentifierIgnorable}</code> </td><td>matches a character in the IdentifierIgnorable class </td></tr>
<tr>
<td><code>\p{JavaIdentifierStart}</code> </td><td>matches a character in the Java IdentifierStart class </td></tr>
<tr>
<td><code>\p{JavaIdentifierPart}</code> </td><td>matches a character in the Java IdentifierPart class </td></tr>
<tr>
<td><code>\p{CsIdentifierStart}</code> </td><td>matches a character in the C# IdentifierStart class </td></tr>
<tr>
<td><code>\p{CsIdentifierPart}</code> </td><td>matches a character in the C# IdentifierPart class </td></tr>
<tr>
<td><code>\p{PythonIdentifierStart}</code> </td><td>matches a character in the Python IdentifierStart class </td></tr>
<tr>
<td><code>\p{PythonIdentifierPart}</code> </td><td>matches a character in the Python IdentifierPart class </td></tr>
</table>
<p>In addition, the <code>−−unicode</code> option enables Unicode language scripts:</p>
<p><code>\p{Arabic}</code>, <code>\p{Armenian}</code>, <code>\p{Avestan}</code>, <code>\p{Balinese}</code>, <code>\p{Bamum}</code>, <code>\p{Bassa_Vah}</code>, <code>\p{Batak}</code>, <code>\p{Bengali}</code>, <code>\p{Bopomofo}</code>, <code>\p{Brahmi}</code>, <code>\p{Braille}</code>, <code>\p{Buginese}</code>, <code>\p{Buhid}</code>, <code>\p{Canadian_Aboriginal}</code>, <code>\p{Carian}</code>, <code>\p{Caucasian_Albanian}</code>, <code>\p{Chakma}</code>, <code>\p{Cham}</code>, <code>\p{Cherokee}</code>, <code>\p{Common}</code>, <code>\p{Coptic}</code>, <code>\p{Cuneiform}</code>, <code>\p{Cypriot}</code>, <code>\p{Cyrillic}</code>, <code>\p{Deseret}</code>, <code>\p{Devanagari}</code>, <code>\p{Duployan}</code>, <code>\p{Egyptian_Hieroglyphs}</code>, <code>\p{Elbasan}</code>, <code>\p{Ethiopic}</code>, <code>\p{Georgian}</code>, <code>\p{Glagolitic}</code>, <code>\p{Gothic}</code>, <code>\p{Grantha}</code>, <code>\p{Greek}</code>, <code>\p{Gujarati}</code>, <code>\p{Gurmukhi}</code>, <code>\p{Han}</code>, <code>\p{Hangul}</code>, <code>\p{Hanunoo}</code>, <code>\p{Hebrew}</code>, <code>\p{Hiragana}</code>, <code>\p{Imperial_Aramaic}</code>, <code>\p{Inherited}</code>, <code>\p{Inscriptional_Pahlavi}</code>, <code>\p{Inscriptional_Parthian}</code>, <code>\p{Javanese}</code>, <code>\p{Kaithi}</code>, <code>\p{Kannada}</code>, <code>\p{Katakana}</code>, <code>\p{Kayah_Li}</code>, <code>\p{Kharoshthi}</code>, <code>\p{Khmer}</code>, <code>\p{Khojki}</code>, <code>\p{Khudawadi}</code>, <code>\p{Lao}</code>, <code>\p{Latin}</code>, <code>\p{Lepcha}</code>, <code>\p{Limbu}</code>, <code>\p{Linear_A}</code>, <code>\p{Linear_B}</code>, <code>\p{Lisu}</code>, <code>\p{Lycian}</code>, <code>\p{Lydian}</code>, <code>\p{Mahajani}</code>, <code>\p{Malayalam}</code>, <code>\p{Mandaic}</code>, <code>\p{Manichaean}</code>, <code>\p{Meetei_Mayek}</code>, <code>\p{Mende_Kikakui}</code>, <code>\p{Meroitic_Cursive}</code>, <code>\p{Meroitic_Hieroglyphs}</code>, <code>\p{Miao}</code>, <code>\p{Modi}</code>, <code>\p{Mongolian}</code>, <code>\p{Mro}</code>, <code>\p{Myanmar}</code>, <code>\p{Nabataean}</code>, <code>\p{New_Tai_Lue}</code>, <code>\p{Nko}</code>, <code>\p{Ogham}</code>, <code>\p{Ol_Chiki}</code>, <code>\p{Old_Italic}</code>, <code>\p{Old_North_Arabian}</code>, <code>\p{Old_Permic}</code>, <code>\p{Old_Persian}</code>, <code>\p{Old_South_Arabian}</code>, <code>\p{Old_Turkic}</code>, <code>\p{Oriya}</code>, <code>\p{Osmanya}</code>, <code>\p{Pahawh_Hmong}</code>, <code>\p{Palmyrene}</code>, <code>\p{Pau_Cin_Hau}</code>, <code>\p{Phags_Pa}</code>, <code>\p{Phoenician}</code>, <code>\p{Psalter_Pahlavi}</code>, <code>\p{Rejang}</code>, <code>\p{Runic}</code>, <code>\p{Samaritan}</code>, <code>\p{Saurashtra}</code>, <code>\p{Sharada}</code>, <code>\p{Shavian}</code>, <code>\p{Siddham}</code>, <code>\p{Sinhala}</code>, <code>\p{Sora_Sompeng}</code>, <code>\p{Sundanese}</code>, <code>\p{Syloti_Nagri}</code>, <code>\p{Syriac}</code>, <code>\p{Tagalog}</code>, <code>\p{Tagbanwa}</code>, <code>\p{Tai_Le}</code>, <code>\p{Tai_Tham}</code>, <code>\p{Tai_Viet}</code>, <code>\p{Takri}</code>, <code>\p{Tamil}</code>, <code>\p{Telugu}</code>, <code>\p{Thaana}</code>, <code>\p{Thai}</code>, <code>\p{Tibetan}</code>, <code>\p{Tifinagh}</code>, <code>\p{Tirhuta}</code>, <code>\p{Ugaritic}</code>, <code>\p{Vai}</code>, <code>\p{Warang_Citi}</code>, <code>\p{Yi}</code>.</p>
<p>You can also use the <code>\P{C}</code> form that is identical to <code>\p{^C}</code> that matches any character except characters in the class <code>C</code>.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-pattern-anchor"></a>
Anchors and boundaries</h3>
<p>Anchors are used to demarcate the start and end of input or the start and end of a line:</p>
<table class="doxtable">
<tr>
<th>Pattern </th><th>Matches  </th></tr>
<tr>
<td><code>^φ</code> </td><td>matches <code>φ</code> at the start of input or start of a line (multi-line mode) </td></tr>
<tr>
<td><code>φ$</code> </td><td>matches <code>φ</code> at the end of input or end of a line (multi-line mode) </td></tr>
<tr>
<td><code>\Aφ</code> </td><td>matches <code>φ</code> at the start of input </td></tr>
<tr>
<td><code>φ\z</code> </td><td>matches <code>φ</code> at the end of input </td></tr>
</table>
<p>Anchors in lexer specifications require context, meaning that <code>φ</code> cannot be empty. Note that <code>&lt;&lt;EOF&gt;&gt;</code> in lexer specifications match the end of input without requiring any context. Actions for the start of input can be specified in the code block preceding the rules.</p>
<p>Word boundaries demarcate words. Word characters <code>\w</code> are letters, digits, and the underscore.</p>
<table class="doxtable">
<tr>
<th>Pattern </th><th>Matches  </th></tr>
<tr>
<td><code>\bφ</code> </td><td>matches <code>φ</code> starting at a word boundary </td></tr>
<tr>
<td><code>φ\b</code> </td><td>matches <code>φ</code> ending at a word boundary </td></tr>
<tr>
<td><code>\Bφ</code> </td><td>matches <code>φ</code> starting at a non-word boundary </td></tr>
<tr>
<td><code>φ\B</code> </td><td>matches <code>φ</code> ending at a non-word boundary </td></tr>
<tr>
<td><code>\&lt;φ</code> </td><td>matches <code>φ</code> that starts as a word </td></tr>
<tr>
<td><code>\&gt;φ</code> </td><td>matches <code>φ</code> that starts as a non-word </td></tr>
<tr>
<td><code>φ\&lt;</code> </td><td>matches <code>φ</code> that ends as a non-word </td></tr>
<tr>
<td><code>φ\&gt;</code> </td><td>matches <code>φ</code> that ends as a word </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The RE/flex regex library requires word boundaries to be specified in patterns at the start or end of the pattern. Boundaries are not permitted in the middle of a pattern.</dd></dl>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-pattern-dents"></a>
Indent/nodent/dedent</h3>
<p>Automatic indent and dedent matching is a special feature of RE/flex and is enabled when the RE/flex matcher engine is used (not the Boost.Regex matcher).</p>
<table class="doxtable">
<tr>
<th>Pattern </th><th>Matches  </th></tr>
<tr>
<td><code>\i</code> </td><td>indent: matches and defines the next indent position </td></tr>
<tr>
<td><code>\j</code> </td><td>dedent: matches the previous indent position </td></tr>
</table>
<p>These patterns should be used in combination with the start of a line anchor <code>^</code> followed by a pattern that represents the spacing for indentations. The pattern may include any characters that are considered part of indentation margins, but should exclude <code>\n</code>. For example:</p>
<div class="alt"> <div class="fragment"><div class="line">%o tabs=8</div><div class="line">%%</div><div class="line">^\h+      out() &lt;&lt; <span class="stringliteral">&quot;| &quot;</span>; <span class="comment">// nodent: text is aligned to current indent margin</span></div><div class="line">^\h*\i    out() &lt;&lt; <span class="stringliteral">&quot;&gt; &quot;</span>; <span class="comment">// indent: matched with \i</span></div><div class="line">^\h*\j    out() &lt;&lt; <span class="stringliteral">&quot;&lt; &quot;</span>; <span class="comment">// dedent: matched with \j</span></div><div class="line">\j        out() &lt;&lt; <span class="stringliteral">&quot;&lt; &quot;</span>; <span class="comment">// dedent: for each extra level dedented</span></div><div class="line">%%</div></div><!-- fragment --> </div><p>The <code>\h</code> pattern matches space and tabs, where tabs advance to the next column that is a multiple of 8. The tab multiplier can be changed by setting the <code>−−tabs=N</code> option where <code>N</code> must be a positive integer that is a power of 2.</p>
<p>To add a pattern that consumes line continuations without affecting the indentation levels, use a negative match, which is a new RE/flex feature:</p>
<div class="alt"> <div class="fragment"><div class="line">(?^\\\n\h*)  <span class="comment">// lines ending in \ will continue on the next line</span></div></div><!-- fragment --> </div><p>The negative pattern <code>(?^\\\n\h+)</code> consumes input internally as if we are repeately calling <code>input()</code> (or <code><a class="el" href="flexlexer_8h.html#a411db26910a55c4e92a226dee582564b" title="Flex-compatible macro: read one character, returns zero when EOF. ">yyinput()</a></code> with <code>−−flex</code>). We used it here to consume the line-ending <code>\</code> and the indent that followed it, as if this text was not part of the input, which ensures that the current indent positions are not affected.</p>
<p>To scan input that continues on the next new line(s) while preserving the current indent positions, use the RE/flex matcher <code>matcher().push_stops()</code> and <code>matcher().pop_stops()</code>. For example, to continue scanning after a <code>/*</code> for multiple lines without indentation matching and up to a <code>*/</code> you can save the current indent positions and transition to a new start condition state to scan the content between <code>/*</code> and <code>*/</code>:</p>
<div class="alt"> <div class="fragment"><div class="line">%o tabs=8</div><div class="line">%x CONTINUE</div><div class="line">%%</div><div class="line">^\h+          out() &lt;&lt; <span class="stringliteral">&quot;| &quot;</span>; <span class="comment">// nodent, text is aligned to current margin</span></div><div class="line">^\h*\i        out() &lt;&lt; <span class="stringliteral">&quot;&gt; &quot;</span>; <span class="comment">// indent</span></div><div class="line">^\h*\j        out() &lt;&lt; <span class="stringliteral">&quot;&lt; &quot;</span>; <span class="comment">// dedent</span></div><div class="line">\j            out() &lt;&lt; <span class="stringliteral">&quot;&lt; &quot;</span>; <span class="comment">// dedent, triggered by each extra dedent</span></div><div class="line"><span class="stringliteral">&quot;/*&quot;</span>          matcher().push_stops(); <span class="comment">// save the indent margin/tab stops</span></div><div class="line">              start(CONTINUE);        <span class="comment">// continue w/o indent matching</span></div><div class="line">&lt;CONTINUE&gt;{</div><div class="line"><span class="stringliteral">&quot;*/&quot;</span>          matcher().pop_stops();  <span class="comment">// restore the indent margin/tab stops</span></div><div class="line">              start(INITIAL);         <span class="comment">// go back to the initial scanning state</span></div><div class="line">.|\n          <span class="comment">/* ignore */</span></div><div class="line">}</div></div><!-- fragment --> </div><p>See <a class="el" href="index.html#reflex-states">Start condition states </a> for more information about start condition states.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-pattern-lookahead"></a>
Lookahead/lookbehind</h3>
<p>Boost matchers support lookahead <code>φ(?=ψ)</code> and lookbehind <code>φ(?&lt;=ψ)</code> patterns that may appear anywhere in a regex.</p>
<p>A lookahead pattern <code>φ(?=ψ)</code> matches <code>φ</code> only when followed by pattern <code>ψ</code> and the text matched by <code>ψ</code> is not consumed.</p>
<p>A lookbehind pattern <code>φ(?&lt;=ψ)</code> matches <code>φ</code> only when it also matches pattern <code>ψ</code> at its end (that is, <code>.*(?&lt;=ab)</code> matches anything that ends in <code>ab</code>). Lookbehind patterns should not look too far behind, see <a class="el" href="index.html#reflex-limitations">Limitations </a>.</p>
<p>Flex "trailing context" matches a pattern only when followed by a lookahead pattern. That is, the trailing context match <code>φ/ψ</code> is translated to the lookahead <code>φ(?=ψ)</code>.</p>
<p>A trailing context may only occur at the end of a pattern, not in the middle of a pattern. There are some important <a class="el" href="index.html#reflex-limitations">Limitations </a> to consider that are historical and related to the contruction of efficient FSMs for regular expressions. The limitations apply to trailing context and lookaheads that the RE/flex matcher implements.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-pattern-unicode"></a>
Unicode mode</h3>
<p>Use <b>reflex</b> option <code>−−unicode</code> (or <code>%option unicode</code>) to globally enable Unicode. Use <code>(?u:φ)</code> to locally enable Unicode in a pattern <code>φ</code>. Unicode mode enables the following patterns to be used:</p>
<table class="doxtable">
<tr>
<th>Pattern </th><th>Matches  </th></tr>
<tr>
<td><code>.</code> </td><td>matches any Unicode character (beware of <a class="el" href="index.html#invalid-utf">Invalid UTF encodings </a>) </td></tr>
<tr>
<td><code>€</code> (UTF-8) </td><td>matches wide character <code>€</code>, encoded in UTF-8 </td></tr>
<tr>
<td><code>[€¥£]</code> (UTF-8) </td><td>matches wide character <code>€</code>, <code>¥</code> or <code>£</code>, encoded in UTF-8 </td></tr>
<tr>
<td><code>\X</code> </td><td>matches any ISO-8859-1 or Unicode character </td></tr>
<tr>
<td><code>\R</code> </td><td>matches a Unicode line break </td></tr>
<tr>
<td><code>\s</code> </td><td>matches a white space character with Unicode sub-property Zs </td></tr>
<tr>
<td><code>\l</code> </td><td>matches a lower case letter with Unicode sub-property Ll </td></tr>
<tr>
<td><code>\u</code> </td><td>matches an upper case letter with Unicode sub-property Lu </td></tr>
<tr>
<td><code>\w</code> </td><td>matches a Unicode word character with property L, Nd, or Pc </td></tr>
<tr>
<td><code>\u{20AC}</code> </td><td>matches Unicode character U+20AC </td></tr>
<tr>
<td><code>\p{C}</code> </td><td>matches a character in category C </td></tr>
<tr>
<td><code>\p{^C}</code>,<code>\P{C}</code> </td><td>matches any character except in category C </td></tr>
</table>
<p>When converting regex patterns for use with a C++ regex library, use regex matcher converter flag <code><a class="el" href="namespacereflex_1_1convert__flag.html#ab1c057a380f8673a13064c755652dc39" title="convert . (dot), \s, \w, \l, \u, \S, \W, \L, \U to Unicode ">reflex::convert_flag::unicode</a></code> to convert Unicode patterns for use with the 8-bit based RE/flex, Boost.Regex, and std::regex regex libraries, see <a class="el" href="index.html#regex-convert">Regex converters </a> for more details.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-pattern-freespace"></a>
Free space mode</h3>
<p>Free space mode can be useful to improve readability of patterns. Free space mode permits spacing between concatenations and alternations in patterns. To match a single space, use <code>" "</code> or <code>[ ]</code>. Long patterns can continue on the next line(s) when lines end with an escape <code>\</code>.</p>
<p>Free space mode requires lexer actions in the rules section of a lexer specification to be placed in <code>{</code> and <code>}</code> blocks and other code in <code>%{</code> and <code>%}</code> instead of indented.</p>
<p>To enable free space mode in <b>reflex</b> use the <code>−−freespace</code> option (or <code>%option freespace</code>).</p>
<p>When converting regex patterns for use with a C++ regex library, use regex matcher converter flag <code><a class="el" href="namespacereflex_1_1convert__flag.html#a32e4f47592b2442c814a32502365a8e3" title="convert regex by removing spacing, same as (?x) ">reflex::convert_flag::freespace</a></code> to convert the regex or use <code>(?x:φ)</code> to locally enable free-space mode in a pattern <code>φ</code>. See <a class="el" href="index.html#regex-convert">Regex converters </a> for more details.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-pattern-multiline"></a>
Multi-line mode</h3>
<p>Multi-line mode makes the anchors <code>^</code> and <code>$</code> match the start and end of a line, respectively. Multi-line mode is the default mode in lexer specifications.</p>
<p>When converting regex patterns for use with a C++ regex library, use regex matcher converter flag <code><a class="el" href="namespacereflex_1_1convert__flag.html#a3c4525aa454d95740eac25f4bd0934c7" title="regex with multiline anchors ^ and $, same as (?m) ">reflex::convert_flag::multiline</a></code> to convert the regex or use <code>(?m:φ)</code> to locally enable multi-line mode in a pattern <code>φ</code>. See <a class="el" href="index.html#regex-convert">Regex converters </a> for more details.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-pattern-dotall"></a>
Dotall mode</h3>
<p>To enable dotall mode in <b>reflex</b> use the <code>-a</code> or <code>−−dotall</code> option (or <code>%option dotall</code>).</p>
<p>When converting regex patterns for use with a C++ regex library, use regex matcher converter flag <code><a class="el" href="namespacereflex_1_1convert__flag.html#ab6a63c3a106c2dbcbad7b86797453f58" title="convert . (dot) to match all, same as (?s) ">reflex::convert_flag::dotall</a></code> to convert the regex or use <code>(?s:φ)</code> to locally enable dotall mode in a pattern <code>φ</code>. See <a class="el" href="index.html#regex-convert">Regex converters </a> for more details.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="reflex-pattern-anycase"></a>
Case-insensitive mode</h3>
<p>To enable case-insensitive mode in <b>reflex</b> use the <code>-i</code> or <code>−−case-insensitive</code> option (or <code>%option case-insensitive</code>).</p>
<p>When converting regex patterns for use with a C++ regex library, use regex matcher converter flag <code><a class="el" href="namespacereflex_1_1convert__flag.html#a70281ca46dbef31569206d4c110c2308" title="convert regex to ignore case, same as (?i) ">reflex::convert_flag::anycase</a></code> to convert the regex or use <code>(?i:φ)</code> to locally enable case-insensitive mode in a pattern <code>φ</code>. See <a class="el" href="index.html#regex-convert">Regex converters </a> for more details.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-lexer"></a>
The Lexer/yyFlexLexer class                                     </h2>
<p>By default, <b>reflex</b> produces a Lexer class with a virtual lex scanner function. The name of this function as well as the Lexer class name and the namespace can be set with options:</p>
<table class="doxtable">
<tr>
<th>Option </th><th>RE/flex default name </th><th>Flex default name  </th></tr>
<tr>
<td><code>namespace</code> </td><td><em>n/a</em> </td><td><em>n/a</em> </td></tr>
<tr>
<td><code>lexer</code> </td><td><code>Lexer</code> class </td><td><code>yyFlexLexer</code> class </td></tr>
<tr>
<td><code>lex</code> </td><td><code><a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">lex()</a></code> function </td><td><code>yylex()</code> function </td></tr>
</table>
<p>To customize the Lexer class use these options and code injection.</p>
<p>To understand the impact of these options, consider the following lex specification template:</p>
<div class="alt"> <div class="fragment"><div class="line">%option <span class="keyword">namespace</span>=NAMESPACE</div><div class="line">%option lexer=LEXER</div><div class="line">%option <a class="code" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805">lex</a>=LEX</div><div class="line"></div><div class="line">%<span class="keyword">class</span>{</div><div class="line">  MEMBERS</div><div class="line">%}</div><div class="line"></div><div class="line">%init{</div><div class="line">  INIT</div><div class="line">%}</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">%{</div><div class="line">  CODE</div><div class="line">%}</div><div class="line"></div><div class="line">REGEX ACTION</div><div class="line"></div><div class="line">%%</div></div><!-- fragment --> </div><p>This produces the following Lexer class with the template parts filled in:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="abslexer_8h.html">reflex/abslexer.h</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>NAMESPACE {</div><div class="line">  <span class="keyword">class </span>LEXER : <span class="keyword">public</span> <a class="code" href="classreflex_1_1_abstract_lexer.html">reflex::AbstractLexer</a>&lt;reflex::Matcher&gt; {</div><div class="line">    MEMBERS</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">    LEXER(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classreflex_1_1_input.html">reflex::Input</a>&amp; input = <a class="code" href="classreflex_1_1_input.html">reflex::Input</a>(),</div><div class="line">        std::ostream&amp;        os    = std::cout)</div><div class="line">      :</div><div class="line">        AbstractLexer(input, os)</div><div class="line">    {</div><div class="line">      INIT</div><div class="line">    }</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> INITIAL = 0;</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> LEX(<span class="keywordtype">void</span>);</div><div class="line">    <span class="keywordtype">int</span> LEX(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classreflex_1_1_input.html">reflex::Input</a>&amp; input,</div><div class="line">        std::ostream        *os = NULL)</div><div class="line">    {</div><div class="line">      in(input);</div><div class="line">      <span class="keywordflow">if</span> (os)</div><div class="line">        out(*os);</div><div class="line">      <span class="keywordflow">return</span> LEX();</div><div class="line">    }</div><div class="line">  };</div><div class="line">  <span class="keywordtype">int</span> NAMESPACE::LEXER::LEX()</div><div class="line">  {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classreflex_1_1_pattern.html">reflex::Pattern</a> PATTERN_INITIAL(<span class="stringliteral">&quot;(?m)(REGEX)&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (!has_matcher())</div><div class="line">    {</div><div class="line">      matcher(<span class="keyword">new</span> Matcher(PATTERN_INITIAL, stdinit(), <span class="keyword">this</span>));</div><div class="line">    }</div><div class="line">    CODE</div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">switch</span> (matcher().scan())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> 0:</div><div class="line">          <span class="keywordflow">if</span> (matcher().at_end())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">          }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            out().put(matcher().input());</div><div class="line">          }</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> 1:</div><div class="line">          ACTION</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The Lexer class produced with option <code>−−flex</code> is compatible with Flex (assuming Flex with option <code>-+</code> for C++):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="flexlexer_8h.html">reflex/flexlexer.h</a>&gt;</span></div><div class="line"><span class="keyword">namespace </span>NAMESPACE {</div><div class="line">  <span class="keyword">typedef</span> <a class="code" href="classreflex_1_1_flex_lexer.html">reflex::FlexLexer&lt;reflex::Matcher&gt;</a> FlexLexer;</div><div class="line">  <span class="keyword">class </span>LEXER : <span class="keyword">public</span> FlexLexer {</div><div class="line">    MEMBERS</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">    LEXER(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classreflex_1_1_input.html">reflex::Input</a>&amp; input = <a class="code" href="classreflex_1_1_input.html">reflex::Input</a>(),</div><div class="line">        std::ostream        *os    = NULL)</div><div class="line">      :</div><div class="line">        FlexLexer(input, os)</div><div class="line">    {</div><div class="line">      INIT</div><div class="line">    }</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> LEX(<span class="keywordtype">void</span>);</div><div class="line">    <span class="keywordtype">int</span> LEX(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classreflex_1_1_input.html">reflex::Input</a>&amp; input,</div><div class="line">        std::ostream        *os = NULL)</div><div class="line">    {</div><div class="line">      in(input);</div><div class="line">      <span class="keywordflow">if</span> (os)</div><div class="line">        out(*os);</div><div class="line">      <span class="keywordflow">return</span> LEX();</div><div class="line">    }</div><div class="line">  };</div><div class="line">  <span class="keywordtype">int</span> NAMESPACE::LEXER::LEX()</div><div class="line">  {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classreflex_1_1_pattern.html">reflex::Pattern</a> PATTERN_INITIAL(<span class="stringliteral">&quot;(?m)(REGEX)&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (!has_matcher())</div><div class="line">    {</div><div class="line">      matcher(<span class="keyword">new</span> Matcher(PATTERN_INITIAL, stdinit(), <span class="keyword">this</span>));</div><div class="line">      <a class="code" href="flexlexer_8h.html#a231e56d8de12d0283bd71ed4e7592171">YY_USER_INIT</a></div><div class="line">    }</div><div class="line">    CODE</div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">switch</span> (matcher().scan())</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> 0:</div><div class="line">          <span class="keywordflow">if</span> (matcher().at_end())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">          }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">          {</div><div class="line">            output(matcher().input());</div><div class="line">          }</div><div class="line">          <a class="code" href="flexlexer_8h.html#a3cc40a460ad7df816678bcc05241e84c">YY_BREAK</a></div><div class="line">        <span class="keywordflow">case</span> 1:</div><div class="line">          <a class="code" href="flexlexer_8h.html#a6198b2fcf96178b24ad4efff2a3debb0">YY_USER_ACTION</a></div><div class="line">          ACTION</div><div class="line">          <a class="code" href="flexlexer_8h.html#a3cc40a460ad7df816678bcc05241e84c">YY_BREAK</a></div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>To use a custom lexer class that inherits the generated base Lexer class, use option <code>−−class=NAME</code> to declare the name of your custom lexer class (or option <code>−−yyclass=NAME</code> to also enable <code>−−flex</code> compatibility with the <code>yyFlexLexer</code> class). For details, see <a class="el" href="index.html#reflex-inherit">Inheriting Lexer/yyFlexLexer </a>.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-inherit"></a>
Inheriting Lexer/yyFlexLexer                                  </h2>
<p>To define a custom lexer class that inherits the generated Lexer or the yyFlexLexer class, use option <code>−−class=NAME</code> or option <code>−−yyclass=NAME</code>, respectively. Note that <code>−−yyclass=NAME</code> also enables option <code>−−flex</code> and therefore enables Flex specification syntax.</p>
<p>When a <code>−−class=NAME</code> or <code>−−yyclass=NAME</code> option is specified with the name of your custom lexer class, <b>reflex</b> generates the <code><a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">lex()</a></code> (or <code>yylex()</code>) method code for your custom lexer class. The custom lexer class should declare a public <code>int <a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">lex()</a></code> method (or <code>int yylex()</code> method with option <code>−−yyclass=NAME</code>). Otherwise, C++ compilation of your custom class will fail.</p>
<p>For example, the following bare-bones custom Lexer class definition simply inherits Lexer and declares a public <code>int <a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">lex()</a></code> method:</p>
<div class="alt"> <div class="fragment"><div class="line">%option <span class="keyword">class</span>=MyLexer</div><div class="line">%{</div><div class="line">  <span class="keyword">class </span>MyLexer : <span class="keyword">public</span> Lexer {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805">lex</a>();</div><div class="line">  };</div><div class="line">%}</div></div><!-- fragment --> </div><p>The <code>int <a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">MyLexer::lex()</a></code> method code is generated by <b>reflex</b> for this lexer specification.</p>
<p>Options <code>−−lexer=NAME</code> and <code>--lex=NAME</code> can be combined with <code>−−class=NAME</code> to change the name of the inherited Lexer class and change the name of the <code><a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">lex()</a></code> method, respectively.</p>
<p>When using option <code>−−yyclass=NAME</code> the inherited lexer is <code>yyFlexLexer</code>. The custom lexer class should declare a public <code>yylex()</code> method similar to Flex. For example:</p>
<div class="alt"> <div class="fragment"><div class="line">%option yyclass=MyLexer</div><div class="line">%{</div><div class="line">  <span class="keyword">class </span>MyLexer : <span class="keyword">public</span> yyFlexLexer {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">    <span class="keywordtype">int</span> yylex();</div><div class="line">  };</div><div class="line">%}</div></div><!-- fragment --> </div><p>The <code>int MyLexer::yylex()</code> method code is generated by <b>reflex</b> for this lexer specification.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-multiple"></a>
Combining multiple lexers                                    </h2>
<p>To combine multiple lexers in one application, use the <code>−−lexer=NAME</code> option. This option renames the generated lexer class to avoid lexer class name clashes. Use this option in combination with option <code>−−header-file</code> to output a header file with the lexer class declaration to include in your application source code.</p>
<p>Use option <code>−−prefix=NAME</code> to output the generated code in file <code>lex.NAME.cpp</code> instead of the standard <code>lex.yy.cpp</code> to avoid file name clashes. This option also affect the <code>−−flex</code> option by generating <code>xxFlexLexer</code> with a <code>xxlex()</code> method when option <code>−−prefix=xx</code> is used. The generated <code>#define</code> names (some of which are added to support option <code>−−flex</code>) are prefixed to avoid macro name clashes.</p>
<p>Alternatively to <code>−−lexer=NAME</code> you can use <code>−−namespace=NAME</code> to place the generated lexer class in a C++ namespace to avoid lexer class name clashes.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-input"></a>
Switching input sources                                         </h2>
<p>To create a Lexer class instance that reads from a designated input source instead of standard input, pass the input source as the first argument to its constructor and use the second argument to optionally set an <code>std::ostream</code>:</p>
<div class="fragment"><div class="line">Lexer lexer(input, std::cout);</div></div><!-- fragment --><p>the same with the <code>−−flex</code> option becomes:</p>
<div class="fragment"><div class="line">yyFlexLexer lexer(input, std::cout);</div></div><!-- fragment --><p>where <code>input</code> is a <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> object. The <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> constructor takes a <code>FILE*</code> descriptor, <code>std::istream</code>, a string <code>std::string</code> or <code>char*</code>, or a wide string <code>std::wstring</code> or <code>wchar_t*</code>.</p>
<p>To switch input to another source while using the scanner, use <code>in(i)</code> with <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> i</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// read from a file, this also decodes UTF-16/32 encodings automatically</span></div><div class="line">FILE *fd = fopen(<span class="stringliteral">&quot;cow.txt&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> (fd)</div><div class="line">  lexer.in(fd);</div><div class="line"></div><div class="line"><span class="comment">// read from a stream (as is, can be ASCII or UTF-8)</span></div><div class="line">std::istream i = std::ifstream(<span class="stringliteral">&quot;file&quot;</span>, std::ifstream::in);</div><div class="line">lexer.in(i);</div><div class="line"></div><div class="line"><span class="comment">// read from a string (as is, can be ASCII or UTF-8)</span></div><div class="line">lexer.in(<span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// read from a wide string, encoding it to UTF-8 for matching</span></div><div class="line">lexer.in(L<span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div></div><!-- fragment --><p>Invoking <code>in(i)</code> resets the lexer's matcher (internally with <code>matcher.reset()</code>). This clears the line and column counters, resets the internal anchor and boundary flags for anchor and word boundary matching, and resets the matcher to consume buffered input.</p>
<p>You can also assign new input with <code>in() = &amp;i</code>, which does not reset the lexer's matcher. This means that when the end of the input (EOF) is reached, and you want to switch to new input, then you should clear the EOF state first with <code>lexer.matcher().set_end(false)</code> to reset EOF. Or use <code>lexer.matcher().reset()</code> to clear the state.</p>
<p>Switching input before the end of the input source is reached discards all remaining input from that source. To switch input without affecting the current input source, switch matchers instead. The matchers buffer the input and manage the input state, in addition to pattern matching the input.</p>
<p>To switch to a matcher that scans from a new input source, use:</p>
<div class="fragment"><div class="line">... <span class="comment">// scanning etc.</span></div><div class="line">Matcher *oldmatcher = matcher();</div><div class="line">Matcher *newmatcher = new_matcher(input);</div><div class="line">matcher(newmatcher);</div><div class="line">... <span class="comment">// scan the new input</span></div><div class="line">del_matcher(newmatcher);</div><div class="line">matcher(oldmatcher);</div><div class="line">... <span class="comment">// continue scanning the old input</span></div></div><!-- fragment --><p>the same with the <code>−−flex</code> option becomes:</p>
<div class="fragment"><div class="line">... <span class="comment">// scanning etc.</span></div><div class="line"><a class="code" href="flexlexer_8h.html#af8ef002da9f9ba35951176ec0be7ab23">YY_BUFFER_STATE</a> oldbuf = <a class="code" href="flexlexer_8h.html#aa093d500a6330d06d8e4760c494fac33">YY_CURRENT_BUFFER</a>;</div><div class="line"><a class="code" href="flexlexer_8h.html#af8ef002da9f9ba35951176ec0be7ab23">YY_BUFFER_STATE</a> newbuf = <a class="code" href="flexlexer_8h.html#aaa025493affa705e21d5b1ac1f9c004f">yy_create_buffer</a>(input, <a class="code" href="flexlexer_8h.html#ae7e51116e747d3390e7a6cfc6532834c">YY_BUF_SIZE</a>);</div><div class="line"><a class="code" href="flexlexer_8h.html#a97d5ac1e34fadb1c7121a3bb9837a973">yy_switch_to_buffer</a>(newbuf);</div><div class="line">... <span class="comment">// scan the new input</span></div><div class="line"><a class="code" href="flexlexer_8h.html#a252001f79f2c35d4b76ad3a43432371d">yy_delete_buffer</a>(newbuf);</div><div class="line"><a class="code" href="flexlexer_8h.html#a97d5ac1e34fadb1c7121a3bb9837a973">yy_switch_to_buffer</a>(oldbuf);</div><div class="line">... <span class="comment">// continue scanning the old input</span></div></div><!-- fragment --><p>This switches the scanner's input by switching to another matcher. Note that <code>matcher(m)</code> may be used by the virtual <code>wrap()</code> method (or <code>yywrap()</code> when option <code>−−flex</code> is used) if you use input wrapping after EOF to set things up for continued scanning.</p>
<p>Switching input sources (via either <code>matcher(m)</code> or <code>in(i)</code>) does not change the current start condition state.</p>
<p>When the scanner reaches the end of the input, it will check the <code>int wrap()</code> method to detetermine if scanning should continue. If <code>wrap()</code> returns one (1) the scanner terminates and returns zero to its caller. If <code>wrap()</code> returns zero (0) then the scanner continues. In this case <code>wrap()</code> should set up a new input source to scan.</p>
<p>For example, continuing reading from <code>std:in</code> after some other input source reached EOF:</p>
<div class="alt"> <div class="fragment"><div class="line">%<span class="keyword">class</span>{</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">int</span> wrap() <span class="comment">// note: yywrap() when option −−flex is used</span></div><div class="line">  {</div><div class="line">    in(std::in);</div><div class="line">    <span class="keywordflow">return</span> in().good() ? 0 : 1;</div><div class="line">  }</div><div class="line">%}</div></div><!-- fragment --> </div><p>To implement a <code>wrap()</code> (and <code>yywrap()</code> when option <code>−−flex</code> is used) in a derived lexer class with option <code>class=NAME</code> (or <code>yyclass=NAME</code>), override the <code>wrap()</code> (or <code>yywrap()</code>) method as follows:</p>
<div class="alt"> <div class="fragment"><div class="line">%option <span class="keyword">class</span>=Tokenizer</div><div class="line"></div><div class="line">%{</div><div class="line">  <span class="keyword">class </span>Tokenizer : Lexer { <span class="comment">// note: yyFlexLexer when option −−flex is used</span></div><div class="line">   <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> wrap() <span class="comment">// note: yywrap() when option −−flex is used</span></div><div class="line">    {</div><div class="line">      in(std::in);</div><div class="line">      <span class="keywordflow">return</span> in().good() ? 0 : 1;</div><div class="line">    }</div><div class="line">  };</div><div class="line">%}</div></div><!-- fragment --> </div><p>You can override the <code>wrap()</code> method to set up a new input source when the current input is exhausted. Do not use <code>matcher().input(i)</code> to set a new input source <code>i</code>, because that resets the internal matcher state.</p>
<p>With the <code>−−flex</code> options your can override the <code>yyFlexLexer::yywrap()</code> method that returns an integer 0 (more input available) or 1 (we're done).</p>
<p>With the <code>−−flex</code> and <code>−−bison</code> options you should define a global <code>yywrap()</code> function that returns an integer 0 (more input available) or 1 (we're done).</p>
<p>A more typical scenario is to process an <code>include</code> directive in the source input that should include the source of another file before continuing with the current input.</p>
<p>For example, the following specification defines a lexer that processes <code>#include</code> directives by switching matchers and using the stack of matchers to permit nested <code>#include</code> directives up to a depth of 99 files:</p>
<div class="alt"> <div class="fragment"><div class="line">%top{</div><div class="line"><span class="preprocessor">  #include &lt;stdio.h&gt;</span></div><div class="line">%}</div><div class="line"></div><div class="line">%<span class="keyword">class</span>{</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> depth;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> include_file()</div><div class="line">  {</div><div class="line">    depth++;</div><div class="line">    <span class="keywordflow">if</span> (depth &gt; 99)</div><div class="line">      exit(EXIT_FAILURE);           <span class="comment">// max include depth exceeded</span></div><div class="line">    <span class="keywordtype">char</span> *q = strchr(text(), <span class="charliteral">&#39;&quot;&#39;</span>);  <span class="comment">// get ...&quot;filename&quot;</span></div><div class="line">    <span class="keywordtype">char</span> *file = strdup(q + 1);     <span class="comment">// get filename&quot;</span></div><div class="line">    file[strlen(file) - 1] = <span class="charliteral">&#39;\0&#39;</span>;  <span class="comment">// get filename</span></div><div class="line">    FILE *fd = fopen(file, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line">    free(file);</div><div class="line">    <span class="keywordflow">if</span> (!fd)</div><div class="line">      exit(EXIT_FAILURE);           <span class="comment">// cannot open file</span></div><div class="line">    push_matcher(new_matcher(fd));  <span class="comment">// push current matcher, use new matcher</span></div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> end_of_file()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (depth == 0)</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;                  <span class="comment">// return true: no more input to read</span></div><div class="line">    fclose(in());                   <span class="comment">// close current input in() (a FILE*)</span></div><div class="line">    pop_matcher();                  <span class="comment">// delete current matcher, pop matcher</span></div><div class="line">    depth--;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;                   <span class="comment">// return false: continue reading</span></div><div class="line">  }</div><div class="line"></div><div class="line">%}</div><div class="line"></div><div class="line">%init{</div><div class="line">  depth = 0;</div><div class="line">%}</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">^\h*#include\h*\<span class="stringliteral">&quot;.*?\&quot;    include_file();</span></div><div class="line"><span class="stringliteral">.|\n                      echo();</span></div><div class="line"><span class="stringliteral">&lt;&lt;EOF&gt;&gt;                   if (end_of_file()) return 0;</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">%%</span></div></div><!-- fragment --> </div><p>With option <code>−−flex</code>, the statement <code>push_matcher(new_matcher(fd))</code> above becomes <code><a class="el" href="flexlexer_8h.html#a3807e0a231906457045e429d6721f291" title="Flex-compatible macro: push the current buffer on the stack to use the given buffer. ">yypush_buffer_state(yy_create_buffer(fd, YY_BUF_SIZE))</a></code> and <code>pop_matcher()</code> becomes <code><a class="el" href="flexlexer_8h.html#a5a5ee4eb3501fe9673a0ad2263a4c5cc" title="Flex-compatible macro: pop buffer from the stack and delete the current buffer. ">yypop_buffer_state()</a></code>.</p>
<p>To set the current input as interactive, such as input from a console, use <code>matcher().interactive()</code> (<code><a class="el" href="flexlexer_8h.html#a83e55b4e09de54e0f7c1b00ebd255a57" title="Flex-compatible macro: interactive mode on/off (use only when scanner has started). ">yy_set_interactive(1)</a></code> with option <code>−−flex</code>). This disables buffering of the input and makes the scanner responsive.</p>
<p>To read from the input without pattern matching, use <code>matcher().input()</code> to read one character at a time (8-bit, ASCII or UTF-8). This function returns EOF if the end of the input was reached. But be careful, the Flex <code><a class="el" href="flexlexer_8h.html#a411db26910a55c4e92a226dee582564b" title="Flex-compatible macro: read one character, returns zero when EOF. ">yyinput()</a></code> and <code>input()</code> functions return 0 instead of an <code>EOF</code> (-1)!</p>
<p>To put back one character unto the input stream, use <code>matcher().unput(c)</code></p>
<p>For example, to crudily scan a C/C++ multiline comment we can use the rule:</p>
<div class="alt"> <div class="fragment"><div class="line"><span class="stringliteral">&quot;/*&quot;</span>    {  <span class="comment">/* skip multiline comments */</span></div><div class="line">  <span class="keywordtype">int</span> c;</div><div class="line">  <span class="keywordflow">while</span> ((c = <a class="code" href="flexlexer_8h.html#a411db26910a55c4e92a226dee582564b">yyinput</a>()) != 0)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;\n&#39;</span>)</div><div class="line">      ++mylineno;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (c == <span class="charliteral">&#39;*&#39;</span>)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> ((c = <a class="code" href="flexlexer_8h.html#a411db26910a55c4e92a226dee582564b">yyinput</a>()) == <span class="charliteral">&#39;/&#39;</span>)</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">      unput(c);</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --> </div><p>Instead of the ugly solution above, a better alternative is to use a regex <code>/\*.*?\*/</code> or perhaps use start condition states, see <a class="el" href="index.html#reflex-states">Start condition states </a>.</p>
<p>To grab the rest of the input as a string, use <code>matcher().rest()</code> which returns a <code>const char*</code> string that points to an internal buffer. Copy the string before using the matcher again.</p>
<p>To read a number of bytes <code>n</code> into a string buffer <code>s[0..n-1]</code>, use <code>matcher().in.get(s, n)</code>, which is the same as invoking the virtual method <code>matcher().get(s, n)</code>. This matcher method can be overriden by a derived matcher class (to customize reading.</p>
<p>The Flex <code>YY_INPUT</code> macro is not supported by RE/flex. It is recommended to use <code>YY_BUFFER_STATE</code> (Flex), which is a <code><a class="el" href="classreflex_1_1_flex_lexer_1_1_matcher.html" title="Extends reflex::AbstractLexer&lt;M&gt;::Matcher for Flex-compatibility. ">reflex::FlexLexer::Matcher</a></code> class in RE/flex that holds the matcher state and the state of the current input, including the line and column number positions (so unlike Flex, <code>yylineno</code> does not have to be saved and restored when switching buffers). See also section <a class="el" href="index.html#reflex-spec">Lexer specifications </a> on the actions to use.</p>
<p>To implement a custom input handler you can use a proper object-oriented approach: create a derived class of <code><a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a></code> (or <code><a class="el" href="classreflex_1_1_boost_posix_matcher.html" title="Boost matcher engine class, extends reflex::BoostMatcher for Boost POSIX regex matching. ">reflex::BoostPosixMatcher</a></code>) and in the derived class override the <code>size_t <a class="el" href="classreflex_1_1_abstract_matcher.html#a92391ce2c5eab5a6dbce067a8326702e" title="Returns more input (method can be overriden, as by reflex::FlexLexer::get(s, n) for example that invo...">reflex::Matcher::get(char *s, size_t n)</a></code> method for input handling. This function is called with a string buffer <code>s</code> of size <code>n</code> bytes. Fill the string buffer <code>s</code> up to <code>n</code> bytes and return the number of bytes stored in <code>s</code>. Return zero upon EOF. Use <b>reflex</b> options <code>−−matcher=NAME</code> and <code>−−pattern=<a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> to use your new matcher class <code>NAME</code> (or leave out <code>−−pattern</code> for Boost.Regex derived matchers).</p>
<p>The <code>FlexLexer</code> lexer class that is the base class of the <code>yyFlexLexer</code> lexer class generated with <b>reflex</b> option <code>−−flex</code> defines a virtual <code>size_t LexerInput(char*, size_t)</code> method. This approach is compatible with Flex. The virtual method can be redefined in the generated <code>yyFlexLexer</code> lexer to consume input from some source of text:</p>
<div class="alt"> <div class="fragment"><div class="line">%<span class="keyword">class</span>{</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> LexerInput(<span class="keywordtype">char</span> *s, <span class="keywordtype">size_t</span> n)</div><div class="line">  {</div><div class="line">    <span class="keywordtype">size_t</span> k;</div><div class="line">    <span class="comment">// populate s[0..k-1] for some k with k &lt;= n</span></div><div class="line">    <span class="keywordflow">return</span> k; <span class="comment">// return number of bytes filled in s[]</span></div><div class="line">  }</div><div class="line">%}</div></div><!-- fragment --> </div><p>The <code>LexerInput</code> method may be invoked multiple times by the matcher engine and should eventually return zero to indicate the end of input is reached (e.g. when at EOF).</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-states"></a>
Start condition states                                         </h2>
<p>Start conditions are used to group rules and selectively activate rules when the start condition state becomes active.</p>
<p>A rule with a pattern that is prefixed with one ore more start conditions will only be active when the scanner is in one of these start condition states.</p>
<p>For example:</p>
<div class="alt"> <div class="fragment"><div class="line">&lt;A,B&gt;pattern1    action1</div><div class="line">&lt;A&gt;pattern2      action2</div><div class="line">&lt;B&gt;pattern3      action3</div></div><!-- fragment --> </div><p>When the scanner is in state <code>A</code> rules 1 and 2 are active. When the scanner is in state <code>B</code> rules 1 and 3 are active.</p>
<p>Start conditions are declared in the definitions section (the first section) of the lexer specification using <code>%state</code> or <code>%xstate</code> (or <code>%s</code> and <code>%x</code> for short) followed by a list of names called <em>start symbols</em>. Start conditions declared with <code>%s</code> are <em>inclusive start conditions</em>. Start conditions declared with <code>%x</code> are <em>exclusive start conditions</em>.</p>
<p>If a start condition is inclusive, then all rules without a start condition and rules with the corresponding start condition will be active.</p>
<p>If a start condition is exclusive, only the rules with the corresponding start condition will be active.</p>
<p>When declaring start symbol names it is recommended to use all upper case to avoid name clashes with other Lexer class members. For example, we cannot use <code>text</code> as a start symbol name because <code>text()</code> is a Lexer method. When option <code>−−flex</code> is used, start symbol names are simple macros for compatibility.</p>
<p>The scanner is initially in the <code>INITIAL</code> start condition state. The <code>INITIAL</code> start condtion is inclusive: all rules without a start condition and those prefixed with the <code>INITIAL</code> start condition are active when the scanner is in the <code>INITIAL</code> start condition state.</p>
<p>The special start condition prefix <code>&lt;*&gt;</code> matches every start condition. The prefix <code>&lt;*&gt;</code> is not needed for <code>&lt;&lt;EOF&gt;&gt;</code> rules, because unprefixed <code>&lt;&lt;EOF&gt;&gt;</code> rules are always active, as a special case (<code>&lt;&lt;EOF&gt;&gt;</code> and this special exception were introduced by Flex).</p>
<p>For example:</p>
<div class="alt"> <div class="fragment"><div class="line">%s A</div><div class="line">%x B</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">&lt;A,B&gt;pattern1    action1    <span class="comment">// rule for states A and B</span></div><div class="line">&lt;A&gt;pattern2      action2    <span class="comment">// rule for state A</span></div><div class="line">&lt;B&gt;pattern3      action3    <span class="comment">// rule for state B</span></div><div class="line">&lt;*&gt;pattern4      action4    <span class="comment">// rule for states INITIAL, A and B</span></div><div class="line">pattern5         action5    <span class="comment">// rule for states INITIAL and A</span></div><div class="line">&lt;&lt;EOF&gt;&gt;          action6    <span class="comment">// rule for states INITIAL, A and B</span></div><div class="line"></div><div class="line">%%</div></div><!-- fragment --> </div><p>When the scanner is in state <code>INITIAL</code> rules 4, 5, and 6 are active. When the scanner is in state <code>A</code> rules 1, 2, 4, 5, and 6 are active. When the scanner is in state <code>B</code> rules 1, 3, 4, and 6 are active. Note that <code>A</code> is inclusive whereas <code>B</code> is exclusive.</p>
<p>To switch to a start condition state, use <code>start(START)</code> (or <code>BEGIN START</code> when option <code>−−flex</code> is used). To get the current state use <code>start()</code> (or <code>YY_START</code> when option <code>−−flex</code> is used). Switching start condition states in your scanner allows you to create "mini-scanners" to scan portions of the input that are syntactically different from the rest of the input, such as comments:</p>
<div class="alt"> <div class="fragment"><div class="line">%x COMMENT</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line"><span class="stringliteral">&quot;/*&quot;</span>    start(COMMENT);    <span class="comment">// with −−flex use: BEGIN COMMENT;</span></div><div class="line">.|\n    echo();            <span class="comment">// with −−flex use: ECHO;</span></div><div class="line"></div><div class="line">&lt;COMMENT&gt;[^*]*         <span class="comment">// eat anything that is not a &#39;*&#39;</span></div><div class="line">&lt;COMMENT&gt;<span class="stringliteral">&quot;*&quot;</span>+[^*/]*    <span class="comment">// eat &#39;*&#39;s not followed by a &#39;/&#39;</span></div><div class="line">&lt;COMMENT&gt;<span class="stringliteral">&quot;*&quot;</span>+<span class="stringliteral">&quot;/&quot;</span>       start(INITIAL);</div><div class="line">&lt;COMMENT&gt;&lt;&lt;EOF&gt;&gt;       std::cerr &lt;&lt; <span class="stringliteral">&quot;EOF in comment\n&quot;</span>; <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">%%</div></div><!-- fragment --> </div><p>Start symbols are actually integer values, where <code>INITIAL</code> is 0. This means that you can store a start symbol value in a variable. You can also push the current start condition on a stack and transition to start condition <code>START</code> with <code>push_state(START)</code>. To transition to a start condition that is on the top of the stack and pop it use <code>pop_state()</code>. The <code>top_state()</code> returns the start condition that is on the top of the stack:</p>
<div class="alt"> <div class="fragment"><div class="line">%x COMMENT</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line"><span class="stringliteral">&quot;/*&quot;</span>    push_state(COMMENT);</div><div class="line">.|\n    echo();</div><div class="line"></div><div class="line">&lt;COMMENT&gt;[^*]*         <span class="comment">// eat anything that is not a &#39;*&#39;</span></div><div class="line">&lt;COMMENT&gt;<span class="stringliteral">&quot;*&quot;</span>+[^*/]*    <span class="comment">// eat &#39;*&#39;s not followed by a &#39;/&#39;</span></div><div class="line">&lt;COMMENT&gt;<span class="stringliteral">&quot;*&quot;</span>+<span class="stringliteral">&quot;/&quot;</span>       pop_state();</div><div class="line">&lt;COMMENT&gt;&lt;&lt;EOF&gt;&gt;       std::cerr &lt;&lt; <span class="stringliteral">&quot;EOF in comment\n&quot;</span>; <span class="keywordflow">return</span> 1;</div><div class="line"></div><div class="line">%%</div></div><!-- fragment --> </div><p>When many rules are prefixed by the same start conditions, you can simplify the rules by placing them in a <em>start condition scope</em>:</p>
<div class="alt"> <div class="fragment"><div class="line">&lt;COMMENT&gt;{</div><div class="line">[^*]*         <span class="comment">// eat anything that is not a &#39;*&#39;</span></div><div class="line"><span class="stringliteral">&quot;*&quot;</span>+[^*/]*    <span class="comment">// eat &#39;*&#39;s not followed by a &#39;/&#39;</span></div><div class="line"><span class="stringliteral">&quot;*&quot;</span>+<span class="stringliteral">&quot;/&quot;</span>       start(INITIAL);</div><div class="line">&lt;&lt;EOF&gt;&gt;       std::cerr &lt;&lt; <span class="stringliteral">&quot;EOF in comment\n&quot;</span>; <span class="keywordflow">return</span> 1;</div><div class="line">}</div></div><!-- fragment --> </div><p>Contrary to some Flex manuals, rules cannot be indented in a start condition scope. Indentation is used to specify code blocks. Code blocks can be indented or placed within <code>%{</code> and <code>%}</code>. These code blocks are executed when the scanner is invoked. A code block at the start of a condition scope is executed when the scanner is invoked and if it is in the corresponding start condition state:</p>
<div class="alt"> <div class="fragment"><div class="line">%s A</div><div class="line">%x B</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">%{</div><div class="line">  <span class="comment">// Code for all inclusive states (INITIAL and A)</span></div><div class="line">%}</div><div class="line">pattern    action</div><div class="line">...</div><div class="line">pattern    action</div><div class="line"></div><div class="line">&lt;B&gt;{</div><div class="line">%{</div><div class="line">  <span class="comment">// Code for state B</span></div><div class="line">%}</div><div class="line">pattern    action</div><div class="line">...</div><div class="line">pattern    action</div><div class="line">}</div><div class="line"></div><div class="line">&lt;*&gt;{</div><div class="line">%{</div><div class="line">  <span class="comment">// Code for all inclusive and exclusive states (INITIAL, A and B)</span></div><div class="line">%}</div><div class="line">pattern    action</div><div class="line">...</div><div class="line">pattern    action</div><div class="line">}</div><div class="line"></div><div class="line">%%</div></div><!-- fragment --> </div><p>Start condition scopes may be nested.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-bison"></a>
Interfacing with Bison/Yacc                                     </h2>
<p>The <a href="dinosaur.compilertools.net/#bison">Bison</a> tools generate parsers that invoke the global C function <code>yylex()</code> to get the next token. Tokens are integer values returned by <code>yylex()</code>.</p>
<p>To support Bison parsers use <b>reflex</b> option <code>−−bison</code>. This option generates a scanner with a global lexer object <code>YY_SCANNER</code> and a global <code>YY_EXTERN_C int yylex()</code> function. When the Bison parser is compiled in C and the scanner is compiled in C++, you must set <code>YY_EXTERN_C</code> in the lex specification to <code>extern "C"</code> to enable C linkage rules:</p>
<div class="alt"> <div class="fragment"><div class="line">%top{</div><div class="line"><span class="preprocessor">  #include &quot;y.tab.h&quot;</span>               <span class="comment">/* include y.tab.h generated by bison */</span></div><div class="line"><span class="preprocessor">  #define YY_EXTERN_C extern &quot;C&quot;   </span><span class="comment">/* yylex() must use C linkage rules */</span><span class="preprocessor"></span></div><div class="line">%}</div><div class="line"></div><div class="line">%option noyywrap bison</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">[0-9]+               yylval.num = strtol(text(), NULL, 10);</div><div class="line">                     <span class="keywordflow">return</span> CONST_NUMBER;</div><div class="line">\<span class="stringliteral">&quot;([^\\&quot;</span>]|\\<span class="stringliteral">&quot;)*\&quot;    yylval.str = text();</span></div><div class="line"><span class="stringliteral">                     return CONST_STRING;</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">%%</span></div></div><!-- fragment --> </div><p>Note that <code>noyywrap</code> is used to remove the dependency on the global <code>yywrap()</code> function that is not defined.</p>
<p>This example sets the global <code>yylval.num</code> to the integer scanned or <code>yylval.str</code> to the string scanned. It assumes that the yacc grammar specification defines the tokens <code>CONST_NUMBER</code> and <code>CONST_STRING</code> and the type <code>YYSTYPE</code> of <code>yylval</code>, which is a union. For example:</p>
<div class="alt"> <div class="fragment"><div class="line"><span class="comment">/* yacc grammar (.y file) */</span></div><div class="line"></div><div class="line">%{</div><div class="line">  <span class="keyword">extern</span> <span class="keywordtype">int</span> yylex(<span class="keywordtype">void</span>);</div><div class="line">%}</div><div class="line"></div><div class="line">%<span class="keyword">union </span>{         <span class="comment">// YYSTYPE yylval is a union:</span></div><div class="line">  <span class="keywordtype">int</span> num;       <span class="comment">// yylval.num</span></div><div class="line">  <span class="keywordtype">char</span>* str;     <span class="comment">// yylval.str</span></div><div class="line">}</div><div class="line"></div><div class="line">%token &lt;num&gt; CONST_NUMBER</div><div class="line">%token &lt;str&gt; CONST_STRING</div><div class="line"></div><div class="line">%%</div><div class="line">...  <span class="comment">// grammar rules</span></div><div class="line">%%</div></div><!-- fragment --> </div><p>When option <code>−−flex</code> is used with <code>−−bison</code>, the <code>yytext</code>, <code>yyleng</code>, and <code>yylineno</code> globals are accessible to the Bison/Yacc parser. In fact, all Flex actions and variables are globally accessible (outside the rules section of the lexer specification) with the exception of <code>yy_push_state</code>, <code>yy_pop_state</code>, and <code>yy_top_state</code> that are class methods. Furthermore, <code>yyin</code> and <code>yyout</code> are macros and cannot be (re)declared or accessed as global variables, but these can be used as if they are variables to assign a new input source and to set the output stream. To avoid compilation errors when using globals such as <code>yyin</code>, use <b>reflex</b> option <code>−−header-file</code> to generate a header file <code>lex.yy.h</code> to include in your code. Finally, in code outside of the rules section you must use <code>yyinput</code> instead of <code>input</code>, use the global action <code>yyunput</code> instead of <code>unput</code>, and use the global action <code>yyoutput</code> instead of <code>output</code>.</p>
<p>See the generated <code>lex.yy.cpp</code> BISON section, which contains declarations specific to Bison when the <code>−−bison</code> option is used.</p>
<p>There are two approaches for a Bison parser to work with a scanner. Either the yacc grammar specification for Bison should include the externs we need to import from the scanner:</p>
<div class="alt"> <div class="fragment"><div class="line"><span class="comment">/* yacc grammar (.y file) assuming C with externs defined by the scanner using YY_EXTERN_C */</span></div><div class="line"></div><div class="line">%{</div><div class="line">  <span class="keyword">extern</span> <span class="keywordtype">int</span> yylex(<span class="keywordtype">void</span>);</div><div class="line">  <span class="keyword">extern</span> <span class="keywordtype">char</span> *<a class="code" href="flexlexer_8h.html#a0d71f919dbec1ffd74b2460fa7e5ac28">yytext</a>;</div><div class="line">  <span class="keyword">extern</span> <a class="code" href="flexlexer_8h.html#aa9522b9e313cd74e4e688e358cbca836">yy_size_t</a> <a class="code" href="flexlexer_8h.html#afa07a629486cb790560bb95713ec7794">yyleng</a>;</div><div class="line">  <span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code" href="flexlexer_8h.html#ad71cf0fddcfe4f61de0929105b33226c">yylineno</a>;</div><div class="line">%}</div><div class="line"></div><div class="line">%%</div><div class="line">...  <span class="comment">// grammar rules</span></div><div class="line">%%</div></div><!-- fragment --> </div><p>or a better approach is to generate a <code>lex.yy.h</code> header file with option <code>--header-file</code> and use this header file in the yacc grammar specification:</p>
<div class="alt"> <div class="fragment"><div class="line"><span class="comment">/* yacc grammar (.y file) assuming C++ */</span></div><div class="line"></div><div class="line">%{</div><div class="line"><span class="preprocessor">  #include &quot;lex.yy.h&quot;</span></div><div class="line">%}</div><div class="line"></div><div class="line">%%</div><div class="line">...  <span class="comment">// grammar rules</span></div><div class="line">%%</div></div><!-- fragment --> </div><p>The second option requires the generated parser to be compiled in C++, because <code>lex.yy.h</code> contains C++ declarations.</p>
<p>The ugly Flex macro <code>YY_DECL</code> is not supported by RE/flex. This macro is needed with Flex to redeclare the <code>yylex()</code> function signature, for example to take an additional <code>yylval</code> parameter that must be passed through from <code>yyparse()</code> to <code>yylex()</code>. Because the generated scanner uses a Lexer class for scanning, the class can be extended with <code>%class{</code> and <code>%}</code> to hold state information and additional token-related values. These values can then be exchanged with the parser using getters and setters, which is preferred over changing the <code>yylex()</code> function signature.</p>
<p>Yacc and Bison use the global variable <code>yylval</code> to exchange token values. Reentrant Bison parsers pass the <code>yylval</code> to the <code>yylex()</code> function as a parameter. RE/flex supports all of these Bison-specific features with command-line options.</p>
<p>To change the generated code for use with Bison, use the following options:</p>
<table class="doxtable">
<tr>
<th>Options </th><th>Method </th><th>Global functions and variables  </th></tr>
<tr>
<td>&#160; </td><td><code>int <a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">Lexer::lex()</a></code> </td><td>&#160; </td></tr>
<tr>
<td><code>−−flex</code> </td><td><code>int yyFlexLexer::yylex()</code> </td><td>&#160; </td></tr>
<tr>
<td><code>−−bison</code> </td><td><code>int <a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">Lexer::lex()</a></code> </td><td><code>Lexer YY_SCANNER</code>, <code>int yylex()</code>, <code>YYSTYPE yylval</code> </td></tr>
<tr>
<td><code>−−flex</code> <code>−−bison</code> </td><td><code>int yyFlexLexer::yylex()</code> </td><td><code>yyFlexLexer YY_SCANNER</code>, <code>int yylex()</code>, <code>YYSTYPE yylval</code>, <code>char *yytext</code>, <code>yy_size_t yyleng</code>, <code>int yylineno</code> </td></tr>
<tr>
<td><code>−−bison</code> <code>−−reentrant</code> </td><td><code>int <a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">Lexer::lex()</a></code> </td><td><code>int yylex(yyscan_t)</code>, <code>void yylex_init(yyscan_t*)</code>, <code>void yylex_destroy(yyscan_t)</code> </td></tr>
<tr>
<td><code>−−flex</code> <code>−−bison</code> <code>−−reentrant</code> </td><td><code>int <a class="el" href="namespacereflex_1_1convert__flag.html#a7222821c0cc6579424c71c261e9b8805" title="convert Lex/Flex regular expression syntax ">yyFlexLexer::lex()</a></code> </td><td><code>int yylex(yyscan_t)</code>, <code>void yylex_init(yyscan_t*)</code>, <code>void yylex_destroy(yyscan_t)</code> </td></tr>
<tr>
<td><code>−−bison-bridge</code> </td><td><code>int Lexer::lex(YYSTYPE&amp; yylval)</code> </td><td><code>int yylex(YYSTYPE*, yyscan_t)</code>, <code>void yylex_init(yyscan_t*)</code>, <code>void yylex_destroy(yyscan_t)</code> </td></tr>
<tr>
<td><code>−−flex</code> <code>−−bison-bridge</code> </td><td><code>int yyFlexLexer::yylex(YYSTYPE&amp; yylval)</code> </td><td><code>int yylex(YYSTYPE*, yyscan_t)</code>, <code>void yylex_init(yyscan_t*)</code>, <code>void yylex_destroy(yyscan_t)</code> </td></tr>
<tr>
<td><code>−−bison-locations</code> </td><td><code>int Lexer::lex(YYSTYPE&amp; yylval)</code> </td><td><code>Lexer YY_SCANNER</code>, <code>int yylex(YYSTYPE*, YYLTYPE*)</code> </td></tr>
<tr>
<td><code>−−flex</code> <code>−−bison-locations</code> </td><td><code>int yyFlexLexer::yylex(YYSTYPE&amp; yylval)</code> </td><td><code>yyFlexLexer YY_SCANNER</code>, <code>int yylex(YYSTYPE*, YYLTYPE*)</code> </td></tr>
<tr>
<td><code>−−bison-locations</code> <code>−−bison-bridge</code> </td><td><code>int Lexer::lex(YYSTYPE&amp; yylval)</code> </td><td><code>int yylex(YYSTYPE*, YYLTYPE*, yyscan_t)</code>, <code>void yylex_init(yyscan_t*)</code>, <code>void yylex_destroy(yyscan_t)</code> </td></tr>
<tr>
<td><code>−−flex</code> <code>−−bison-locations</code> <code>−−bison-bridge</code> </td><td><code>int yyFlexLexer::yylex(YYSTYPE&amp; yylval)</code> </td><td><code>int yylex(YYSTYPE*, YYLTYPE*, yyscan_t)</code>, <code>void yylex_init(yyscan_t*)</code>, <code>void yylex_destroy(yyscan_t)</code> </td></tr>
</table>
<p>Option <code>−−prefix</code> may be used with option <code>−−flex</code> to change the prefix of the generated <code>yyFlexLexer</code> and <code>yylex</code>. This option can be combined with option <code>−−bison</code> to also change the prefix of the generated <code>yytext</code>, <code>yyleng</code>, and <code>yylineno</code>.</p>
<p>The <b>reflex</b> option <code>−−bison-bridge</code> expects a Bison "pure parser":</p>
<div class="alt"> <div class="fragment"><div class="line"><span class="comment">/* yacc grammar (.y file) assuming C++ */</span></div><div class="line"></div><div class="line">%{</div><div class="line"><span class="preprocessor">  #include &quot;lex.yy.h&quot;</span></div><div class="line"><span class="preprocessor">  #define YYPARSE_PARAM scanner</span></div><div class="line"><span class="preprocessor">  #define YYLEX_PARAM   scanner</span></div><div class="line">%}</div><div class="line"></div><div class="line">%pure-parser</div><div class="line"></div><div class="line">%%</div><div class="line">...  <span class="comment">// grammar rules</span></div><div class="line">%%</div></div><!-- fragment --> </div><p>For the <code>−−bison-bridge</code> option, the <code>yyscan_t</code> argument type of <code>yylex()</code> is a <code>void*</code> type that passes the scanner object to this global function (as defined by <code>YYPARSE_PARAM</code> and <code>YYLEX_PARAM</code>). The function then invokes this scanner's lex function. This option also passes the <code>yylval</code> value to the lex function, which is a reference to an <code>YYSTYPE</code> value.</p>
<p>For the <code>−−reentrant</code> and <code>−−bison-bridge</code> options two additional functions are generated that can be used to create a new scanner and delete the scanner:</p>
<div class="alt"> <div class="fragment"><div class="line">yyscan_t scanner = <span class="keyword">nullptr</span>;</div><div class="line">yylex_init(&amp;scanner);      <span class="comment">// create a new scanner</span></div><div class="line">...</div><div class="line"><span class="comment">// three possibilities, depending on options:</span></div><div class="line">int token = yylex(scanner);                   <span class="comment">// reentrant scan</span></div><div class="line"><span class="keywordtype">int</span> token = yylex(&amp;yylval, scanner);          <span class="comment">// reentrant scan with bison-bridge</span></div><div class="line"><span class="keywordtype">int</span> token = yylex(&amp;yylval, &amp;yylloc, scanner); <span class="comment">// reentrant scan with bison-bridge and bison-locations</span></div><div class="line">...</div><div class="line">yylex_destroy(scanner);    <span class="comment">// delete a scanner</span></div><div class="line">scanner = <span class="keyword">nullptr</span>;</div></div><!-- fragment --> </div><p>The option <code>−−bison-locations</code> expects a Bison parser with the locations feature enabled. This feature provides line and column numbers of the matched text for error reporting. For example:</p>
<div class="alt"> <div class="fragment"><div class="line"><span class="comment">/* yacc grammar (.y file) assuming C++ */</span></div><div class="line"></div><div class="line">%{</div><div class="line"><span class="preprocessor">  #include &quot;lex.yy.h&quot;</span></div><div class="line">  <span class="keywordtype">void</span> yyerror(<span class="keyword">const</span> <span class="keywordtype">char</span>*);</div><div class="line">%}</div><div class="line"></div><div class="line">%locations</div><div class="line"></div><div class="line">%<span class="keyword">union </span>{         <span class="comment">// YYSTYPE yylval is a union:</span></div><div class="line">  <span class="keywordtype">int</span> num;       <span class="comment">// type of yylval.num is int</span></div><div class="line">  <span class="keywordtype">char</span>* str;     <span class="comment">// type of yylval.str is char*</span></div><div class="line">}</div><div class="line"></div><div class="line">%{</div><div class="line">  <span class="comment">/* add this only to patch old bison versions */</span></div><div class="line">  <span class="keyword">extern</span> <span class="keywordtype">int</span> yylex(YYSTYPE*, YYLTYPE*);</div><div class="line"><span class="preprocessor">  #define YYLEX_PARAM &amp;yylval, &amp;yylloc</span></div><div class="line">%}</div><div class="line"></div><div class="line">%token &lt;num&gt; CONST_NUMBER</div><div class="line">%token &lt;str&gt; CONST_STRING</div><div class="line"></div><div class="line">%%</div><div class="line">...  <span class="comment">// grammar rules</span></div><div class="line">%%</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> yyerror(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg)</div><div class="line">{</div><div class="line">  fprintf(stderr, <span class="stringliteral">&quot;%s at %d,%d to line %d,%d\n&quot;</span>,</div><div class="line">      msg,</div><div class="line">      yylloc.first_line,</div><div class="line">      yylloc.first_column,</div><div class="line">      yylloc.last_line,</div><div class="line">      yylloc.last_column);</div><div class="line">}</div></div><!-- fragment --> </div><p>The <code>yylval</code> value is passed to the lex function. The <code>yylloc</code> structure is automatically set by the RE/flex scanner, so you do not need to define a <code>YY_USER_ACTION</code> macro as you have to with Flex.</p>
<p>And a final example that combines options <code>−−bison-locations</code> and <code>−−bison-bridge</code>, which expects a Bison pure-parser with locations enabled:</p>
<div class="alt"> <div class="fragment"><div class="line"><span class="comment">/* yacc grammar (.y file) */</span></div><div class="line"></div><div class="line">%{</div><div class="line"><span class="preprocessor">  #include &quot;lex.yy.h&quot;</span></div><div class="line"><span class="preprocessor">  #define YYPARSE_PARAM scanner</span></div><div class="line"><span class="preprocessor">  #define YYLEX_PARAM   scanner</span></div><div class="line">%}</div><div class="line"></div><div class="line">%pure-parser</div><div class="line">%locations</div><div class="line"></div><div class="line">%<span class="keyword">union </span>{         <span class="comment">// YYSTYPE yylval is a union:</span></div><div class="line">  <span class="keywordtype">int</span> num;       <span class="comment">// yylval.num</span></div><div class="line">  <span class="keywordtype">char</span>* str;     <span class="comment">// yylval.str</span></div><div class="line">}</div><div class="line"></div><div class="line">%token &lt;num&gt; CONST_NUMBER</div><div class="line">%token &lt;str&gt; CONST_STRING</div><div class="line"></div><div class="line">%%</div><div class="line">...  <span class="comment">// grammar rules</span></div><div class="line">%%</div></div><!-- fragment --> </div><p>When Bison <code>locations</code> with <code>define api.pure full</code> is used, <code>yyerror</code> has the signature <code>void yyerror(YYLTYPE *locp, char const *msg)</code>. This function signature is required to obtain the location information with Bison pure-parsers.</p>
<dl class="section note"><dt>Note</dt><dd><code>yylval</code> is not a pointer argument but is always passed by reference and can be used as such in the scanner's rules.</dd>
<dd>
Because <code>YYSTYPE</code> is declared by the parser, do not forget to add a <code>#include "y.tab.h"</code> to the top of the specification of your lexer:</dd></dl>
<div class="alt"> <div class="fragment"><div class="line">%top{</div><div class="line"><span class="preprocessor">  #include &quot;y.tab.h&quot;</span>    <span class="comment">/* include y.tab.h generated by bison */</span></div><div class="line">%}</div></div><!-- fragment --> </div><p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-posix-perl"></a>
POSIX versus Perl matching                                 </h2>
<p>The <b>reflex</b> scanner generator gives you a choice of matchers to use in the generated scanner, where the default is the POSIX RE/flex matcher engine. Other options are the Boost.Regex matcher in POSIX mode or in Perl mode.</p>
<p>To use a matcher for the generated scanner, use one of these three choices:</p>
<table class="doxtable">
<tr>
<th>Option </th><th>Matcher class used </th><th>Mode </th><th>Engine  </th></tr>
<tr>
<td><code>-m reflex</code> </td><td><code>Matcher</code> </td><td>POSIX </td><td>RE/flex lib (default choice) </td></tr>
<tr>
<td><code>-m boost</code> </td><td><code>BoostPosixMatcher</code> </td><td>POSIX </td><td>Boost.Regex </td></tr>
<tr>
<td><code>-m boost-perl</code> </td><td><code>BoostPerlMatcher</code> </td><td>Perl </td><td>Boost.Regex </td></tr>
</table>
<p>The POSIX matchers look for the <em>longest possible match</em> among the given set of alternative patterns. Perl matchers look for the <em>first match</em> among the given set of alternative patterns.</p>
<p>POSIX is generally preferred for scanners, since it is easier to arrange rules that may have partially overlapping patterns. Since we are looking for the longest match anyway, it does not matter which rule comes first. The order does not matter as long as the length of the matches differ. When matches are of the same length because multiple patterns match, then the first rule is selected.</p>
<p>Consider for example the following specification if a lexer with rules that are intended to match keywords and identifiers in some input text:</p>
<div class="alt"> <div class="fragment"><div class="line">%%</div><div class="line"></div><div class="line"><span class="keywordtype">int</span>                     out() &lt;&lt; <span class="stringliteral">&quot;int keyword\n;</span></div><div class="line"><span class="stringliteral">interface               out() &lt;&lt; &quot;</span><span class="keyword">interface </span>keyword\n;</div><div class="line"><span class="keywordtype">float</span>                   out() &lt;&lt; <span class="stringliteral">&quot;float keyword\n;</span></div><div class="line"><span class="stringliteral">[A-Za-z][A-Za-z0-9]*    out() &lt;&lt; &quot;</span>identifier\n<span class="stringliteral">&quot;;</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">%%</span></div></div><!-- fragment --> </div><p>When the input to the scanner is the text <code>integer</code> then a POSIX matcher selects the last rule, which is what we want because it is an identifier.</p>
<p>By contrast, a Perl matcher selects the first rule because it matches the first part <code>int</code> of <code>integer</code>. This is NOT what we want. The same problem occurs when the text <code>interface</code> is encountered on the input, which we want to recognize as a separate keyword and not match against <code>int</code>. Switching the rules for <code>int</code> and <code>interface</code> fixes that problem. But note that we cannot do the same to fix matching <code>integer</code> as an identifier: when moving the last rule up to the top we cannot match <code>int</code> any longer!</p>
<dl class="section note"><dt>Note</dt><dd>To prevent a Perl matcher from matching a keyword when an identifier starts with the name of that keyword, we could use a lookahead pattern such as <code>int(?=[^A-Za-z0-9_])</code> which is written in a lexer specification as <code>int/[^A-Za-z0-9_]</code> with the <code>/</code> lookahead meta symbol.</dd></dl>
<p>Basically, a Perl matcher works in an <em>operational</em> mode by working the regex pattern as a sequence of <em>operations</em> for matching, usually using backtracking to find a matching pattern.</p>
<p>A POSIX matcher on the other hand is <em>declarative</em> and have a deeper foundation in formal language theory. An advantage of POSIX matchers is that regular expressions can be compiled to deterministic finite state machines for efficient matching.</p>
<dl class="section note"><dt>Note</dt><dd>POSIX matching still require moving the <code>int</code> matching rule before the identifier matching rule. Otherwise an <code>int</code> on the input will be matched by the identifier rule.</dd></dl>
<p>Perl matchers generally support lazy quantifiers and group captures, while most POSIX matchers do not (Boost.Regex in POSIX mode does not support lazy quantifiers). The RE/flex POSIX matcher supports lazy quantifiers, but not group captures. The added support for lazy quantifiers and word boundary anchors in RE/flex matching offers a reasonably new and useful feature for scanners that require POSIX mode matching.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-examples"></a>
Examples                                                     </h2>
<p>Some lexer specification examples to generate scanners with RE/flex.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3>Example 1</h3>
<p>The following Flex specification counts the lines, words, and characters on the input. We use <code>yyleng</code> match text length to count 8-bit characters (bytes).</p>
<p>To build this example with RE/flex, use <b>reflex</b> option <code>−−flex</code> to generate Flex-compatible "yy" variables and functions. This generates a C++ scanner class <code>yyFlexLexer</code> that is compatible with the Flex scanner class (assuming Flex with option <code>-+</code> for C++).</p>
<div class="alt"> <div class="fragment"><div class="line">%{</div><div class="line"><span class="preprocessor">  #include &lt;stdio.h&gt;</span></div><div class="line">  <span class="keywordtype">int</span> ch = 0, wd = 0, nl = 0;</div><div class="line">%}</div><div class="line"></div><div class="line">%option noyywrap</div><div class="line">%option <a class="code" href="reflex_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="line"></div><div class="line">nl      \r?\n</div><div class="line">wd      [^ \t\r\n]+</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">{nl}    ch += <a class="code" href="flexlexer_8h.html#afa07a629486cb790560bb95713ec7794">yyleng</a>; ++nl;</div><div class="line">{wd}    ch += <a class="code" href="flexlexer_8h.html#afa07a629486cb790560bb95713ec7794">yyleng</a>; ++wd;</div><div class="line">.       ++ch;</div><div class="line">&lt;&lt;EOF&gt;&gt; printf(<span class="stringliteral">&quot;%8d%8d%8d\n&quot;</span>, nl, wd, ch); <a class="code" href="flexlexer_8h.html#a14a01126580f1d5ad5d4fc521bc715d2">yyterminate</a>();</div><div class="line"></div><div class="line">%%</div></div><!-- fragment --> </div><p>To generate a scanner with a global <code>yylex()</code> function similar to Flex in C mode (i.e. without Flex option <code>-+</code>), use <b>reflex</b> option <code>−−bison</code> with the specification shown above. This option when combined with <code>−−flex</code> produces the global "yy" functions and variables. This means that you can use RE/flex scanners with Bison (Yacc) and with any other C code, assuming everything is compiled together with a C++ compiler.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3>Example 2</h3>
<p>An improved implementation drops the use of global variables in favor of Lexer class member variables. We also want to count Unicode letters with the <code>wd</code> counter instead of ASCII letters, which are single bytes while Unicode UTF-8 encodings vary in size. So we add the Unicode option and use <code>\w</code> to match Unicode word characters. Note that <code>.</code> (dot) matches Unicode, so the match length may be longer than one character that must be counted. We drop the <code>−−flex</code> option and use RE/flex Lexer methods instead of the Flex "yy" functions:</p>
<div class="alt"> <div class="fragment"><div class="line">%top{</div><div class="line"><span class="preprocessor">  #include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">  #include &lt;iomanip&gt;</span></div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line">%}</div><div class="line"></div><div class="line">%<span class="keyword">class</span>{</div><div class="line">  <span class="keywordtype">int</span> ch, wd, nl;</div><div class="line">%}</div><div class="line"></div><div class="line">%init{</div><div class="line">  ch = wd = nl = 0;</div><div class="line">%}</div><div class="line"></div><div class="line">%option <a class="code" href="namespacereflex_1_1convert__flag.html#ab1c057a380f8673a13064c755652dc39">unicode</a></div><div class="line">%option <a class="code" href="reflex_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="line">%option full</div><div class="line"></div><div class="line">nl      \r?\n</div><div class="line">wd      (\w|\p{Punctuation})+</div><div class="line"></div><div class="line">%%</div><div class="line"></div><div class="line">{nl}    ch += size(); ++nl;</div><div class="line">{wd}    ch += size(); ++wd;</div><div class="line">.       ch += size();</div><div class="line">&lt;&lt;EOF&gt;&gt; out() &lt;&lt; setw(8) &lt;&lt; nl &lt;&lt; setw(8) &lt;&lt; wd &lt;&lt; setw(8) &lt;&lt; ch &lt;&lt; endl;</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line"></div><div class="line">%%</div></div><!-- fragment --> </div><p>This simple word count program differs slightly from the Unix wc utility, because the wc utility counts words delimited by wide character spaces (<code>iswspace</code>) whereas this program counts words made up from word characters combined with punctuation.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3>Example 3</h3>
<p>The following RE/flex specification filters tags from XML documents and verifies whether or not the tags are properly balanced. Note that this example uses the lazy repetitions to keep the patterns simple. The XML document scanned should not include invalid XML characters such as <code>/</code>, <code>&lt;</code>, or <code>&gt;</code> in attributes (otherwise the tags will not match properly). The <code>dotall</code> option allows <code>.</code> (dot) to match newline in all patterns, similar to the <code>(?s)</code> modifier in regexes.</p>
<div class="alt"> <div class="fragment"><div class="line">%top{</div><div class="line"><span class="preprocessor">  #include &lt;stdio.h&gt;</span></div><div class="line">%}</div><div class="line"></div><div class="line">%<span class="keyword">class</span>{</div><div class="line">  <span class="keywordtype">int</span> level;</div><div class="line">%}</div><div class="line"></div><div class="line">%init{</div><div class="line">  level = 0;</div><div class="line">%}</div><div class="line"></div><div class="line">%o matcher=<a class="code" href="namespacereflex.html">reflex</a> <a class="code" href="namespacereflex_1_1convert__flag.html#ab6a63c3a106c2dbcbad7b86797453f58">dotall</a> <a class="code" href="reflex_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="line">%x ATTRIBUTES</div><div class="line"></div><div class="line">name                    [A-Za-z_:\x80-\xFF][-.0-9A-Za-z_:\x80-\xFF]*</div><div class="line">pi                      &lt;\?{name}</div><div class="line">comment                 </div><div class="line">open                    &lt;{name}</div><div class="line">close                   &lt;\/{name}&gt;</div><div class="line">cdata                   &lt;!\[CDATA\[.*?]]&gt;</div><div class="line"><span class="keywordtype">string</span>                  \<span class="stringliteral">&quot;.*?\&quot;|&#39;.*?&#39;</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">%%</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">{comment}               |</span></div><div class="line"><span class="stringliteral">{cdata}                 // skip comments and CDATA sections</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">{pi}                    level++;</span></div><div class="line"><span class="stringliteral">                        start(ATTRIBUTES);</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">{open}                  printf(&quot;</span>%*s%s\n<span class="stringliteral">&quot;, level++, &quot;</span><span class="stringliteral">&quot;, text() + 1);</span></div><div class="line"><span class="stringliteral">                        start(ATTRIBUTES);</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">{close}                 matcher().less(size() - 1);</span></div><div class="line"><span class="stringliteral">                        printf(&quot;</span>%*s%s\n<span class="stringliteral">&quot;, --level, &quot;</span><span class="stringliteral">&quot;, text() + 2);</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">&lt;&lt;EOF&gt;&gt;                 printf(&quot;</span>Tags are %sbalanced\n<span class="stringliteral">&quot;, level ? &quot;</span>im<span class="stringliteral">&quot; : &quot;</span><span class="stringliteral">&quot;);</span></div><div class="line"><span class="stringliteral">                        return 0;</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">&lt;ATTRIBUTES&gt;&quot;</span>/&gt;<span class="stringliteral">&quot;        --level;</span></div><div class="line"><span class="stringliteral">                        start(INITIAL);</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">&lt;ATTRIBUTES&gt;&quot;</span>&gt;<span class="stringliteral">&quot;         start(INITIAL);</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">&lt;ATTRIBUTES&gt;{name}      |</span></div><div class="line"><span class="stringliteral">&lt;ATTRIBUTES&gt;{string}    // skip attribute names and strings</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">&lt;*&gt;.                    // skip anything else</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">%%</span></div></div><!-- fragment --> </div><p>Note thay we restrict XML tag names to valid characters, including all UTF-8 sequences that run in the range <code>\x80</code>-<code>\xFF</code> per 8-bit character. This matches all Unicode characters U+0080 to U+10FFFF.</p>
<p>The <code>ATTRIBUTES</code> state is used to scan attributes and their quoted values separately from the <code>INITIAL</code> state. The <code>INITIAL</code> state permits quotes to freely occur in character data, whereas the <code>ATTRIBUTES</code> state matches quoted attribute values.</p>
<p>We use <code>matcher().less(size() - 1)</code> to remove the ending <code>&gt;</code> from the match in <code>text()</code>. The <code>&gt;</code> will be matched again, this time by the <code>&lt;*&gt;.</code> rule that ignores it. We could also have used a lookahead pattern <code>"\&lt;/"{name}/"\&gt;"</code> where <code>X/Y</code> means look ahead for <code>Y</code> after <code>X</code>.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3>Example 4</h3>
<p>This example Flex specification scans C/C++ source code. It uses free space mode to enhance readability.</p>
<div class="alt"> <div class="fragment"><div class="line">%{</div><div class="line"><span class="preprocessor">  #include &lt;stdio.h&gt;</span></div><div class="line">%}</div><div class="line"></div><div class="line">%o flex <a class="code" href="namespacereflex_1_1convert__flag.html#a32e4f47592b2442c814a32502365a8e3">freespace</a> <a class="code" href="reflex_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a></div><div class="line"></div><div class="line">directive       ^ \h* # (. | \\ \r? \n)+</div><div class="line">name            [\u\l_] \w*</div><div class="line">udec            0 | [1-9] \d*</div><div class="line">uhex            0 [Xx] [[:xdigit:]]+</div><div class="line">uoct            0 [0-7]+</div><div class="line"><span class="keywordtype">int</span>             [-+]? ({udec} | {uhex}) \</div><div class="line">                  ([Ll]{0,2} [Uu]? | [Uu] [Ll]{0,2})</div><div class="line"><span class="keywordtype">float</span>           [-+] \d* (\d | \.\d | \d\.) \d* \</div><div class="line">                  ([Ee][-+]? \d+)? \</div><div class="line">                  [FfLl]?</div><div class="line"><span class="keywordtype">char</span>            L? <span class="stringliteral">&#39; (\\. | [^\\\n&#39;</span>])* <span class="stringliteral">&#39;</span></div><div class="line"><span class="stringliteral">string          L? \&quot; (\\. | \\\r?\n | [^\\\n&quot;])* \&quot;</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">%%</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">\s+</span></div><div class="line"><span class="stringliteral">&quot;//&quot; .*? \n</span></div><div class="line"><span class="stringliteral">&quot;/*&quot; (.|\n)*? &quot;*/&quot;</span></div><div class="line"><span class="stringliteral">{directive}     { printf(&quot;DIRECTIVE %s\n&quot;, yytext); }</span></div><div class="line"><span class="stringliteral">{name}          { printf(&quot;NAME      %s\n&quot;, yytext); }</span></div><div class="line"><span class="stringliteral">{int}           { printf(&quot;INT       %s\n&quot;, yytext); }</span></div><div class="line"><span class="stringliteral">{float}         { printf(&quot;FLOAT     %s\n&quot;, yytext); }</span></div><div class="line"><span class="stringliteral">{char}          { printf(&quot;CHAR      %s\n&quot;, yytext); }</span></div><div class="line"><span class="stringliteral">{string}        { printf(&quot;STRING    %s\n&quot;, yytext); }</span></div><div class="line"><span class="stringliteral">[[:punct:]]     { printf(&quot;PUNCT     %s\n&quot;, yytext); }</span></div><div class="line"><span class="stringliteral">.               { printf(&quot;*** ERROR &#39;</span>%s<span class="stringliteral">&#39; at line %d\n&quot;, yytext, yylineno); }</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">%%</span></div></div><!-- fragment --> </div><p>Free space mode permits spacing between concatenations and alternations. To match a single space, use <code>" "</code> or <code>[ ]</code>. Long patterns can continue on the next line(s) when lines ends with an escape <code>\</code>.</p>
<p>In free space mode you MUST place actions in <code>{</code> and <code>}</code> blocks and other code in <code>%{</code> and <code>%}</code>.</p>
<p>When used with option <code>unicode</code>, the scanner automatically recognizes and scans Unicode identifier names. Note that we can use <code>matcher().columno()</code> in the error message. The <code>matcher()</code> object associated with the Lexer offers several other methods that Flex does not support.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="reflex-limitations"></a>
Limitations                                               </h2>
<p>The RE/flex matcher engine uses an efficient FSM. There are known limitations to FSM matching that apply to Lex/Flex and therefore also apply to the <b>reflex</b> scanner generator and to the RE/flex matcher engine:</p>
<ul>
<li>Lookaheads (trailing contexts) must appear at the end of a pattern when using the RE/flex matcher, so <code>a/b</code> (which is the same as lookahead <code>a(?=b)</code>) is permitted, but <code>(a/b)c</code> and <code>a(?=b)c</code> are not.</li>
<li>Lookaheads cannot be properly matched when the ending of the first part of the pattern matches the beginning of the second part, such as <code>zx*/xy*</code>, where the <code>x*</code> matches the <code>x</code> at the beginning of the lookahead pattern.</li>
<li>Anchors and boundaries must appear at the start or at the end of a pattern. The begin of buffer/line anchors <code>\A</code> and <code>^</code>, end of buffer/line anchors <code>\z</code> and <code>$</code> and the word boundary anchors must start or end a pattern. For example, <code>\&lt;cow\&gt;</code> is permitted, but <code>.*\Bboy</code> is not.</li>
</ul>
<p>Current <b>reflex</b> tool limitations that may be removed in future versions:</p>
<ul>
<li>The <code>REJECT</code> action is not supported.</li>
<li>Flex translations <code>T</code> are not supported.</li>
</ul>
<p>Boost.Regex library limitations:</p>
<ul>
<li>Lookbehinds <code>φ(?&lt;=ψ)</code> with the Boost.Regex matcher engine should not look too far behind, because the input is shifted through a buffer which means that prior text is no longer available for matching. The lookbehind pattern <code>ψ</code> should not match text that is longer than what pattern <code>φ</code> can match.</li>
<li>Boost.Regex may fail to find the longest match when greedy repetition patterns such as <code>.*</code> are used. Under certain conditions greedy repetitions may behave as lazy repetitions. For example, the Boost.Regex engine may return the short match <code>abc</code> when the regex <code>a.*c</code> is applied to <code>abc abc</code>, instead of returning the full match <code>abc abc</code>. The problem is caused by the limitations of Boost.Regex <code>match_partial</code> matching algorithm. To work around this limitation, we suggest to make the repetition pattern as specific as possible and not overlap with the pattern that follows the repetition. <em>The easiest solution is to read the entire input</em> using <b>reflex</b> option <code>-B</code> (batch input). For a stand-alone <code>BoostMatcher</code>, use the <code>buffer()</code> method. We consider this Boost.Regex partial match behavior a bug, not a restriction, because <em>as long as backtracking on a repetition pattern is possible given some partial text, Boost.Regex should flag the result as a partial match instead of a full match.</em></li>
</ul>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="regex"></a>
The RE/flex regex library                                              </h1>
<p>The RE/flex regex library consists of a set of C++ templates and classes that encapsulate regex engines in a standard API for scanning, tokenizing, searching, and splitting of strings, wide strings, files, and streams.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="regex-boost"></a>
Boost matcher classes                                            </h2>
<p>The RE/flex regex library is a class hierarchy that has at the root an abstract class <code><a class="el" href="classreflex_1_1_abstract_matcher.html" title="The abstract matcher base class template defines an interface for all pattern matcher engines...">reflex::AbstractMatcher</a></code>. Pattern types may differ between for matchers so the <code><a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a></code> template class takes a pattern type and creates a class that is complete except for the implementation of the <code>reflex::match()</code> virtual method that requires a regex engine, such as Boost.Regex or the RE/flex engine.</p>
<p>The <code><a class="el" href="classreflex_1_1_boost_matcher.html" title="Boost matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::BoostMatcher</a></code> inherits <code><a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a>&lt;boost::regex&gt;</code>, and in turn the <code><a class="el" href="classreflex_1_1_boost_perl_matcher.html" title="Boost matcher engine class, extends reflex::BoostMatcher for Boost Perl regex matching. ">reflex::BoostPerlMatcher</a></code> and <code><a class="el" href="classreflex_1_1_boost_posix_matcher.html" title="Boost matcher engine class, extends reflex::BoostMatcher for Boost POSIX regex matching. ">reflex::BoostPosixMatcher</a></code> are both derived from <code><a class="el" href="classreflex_1_1_boost_matcher.html" title="Boost matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::BoostMatcher</a></code>:</p>
<div class="image">
<img src="classreflex_1_1_boost_matcher__inherit__graph.png" />
</div>
<p>An instance of <code><a class="el" href="classreflex_1_1_boost_perl_matcher.html" title="Boost matcher engine class, extends reflex::BoostMatcher for Boost Perl regex matching. ">reflex::BoostPerlMatcher</a></code> is initialized with flag <code>match_perl</code> and the flag <code>match_not_dot_newline</code>, these are <code>boost::regex_constants</code> flags. These flags are the only difference with the plain <code><a class="el" href="classreflex_1_1_boost_matcher.html" title="Boost matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::BoostMatcher</a></code>.</p>
<p>An instance of <code><a class="el" href="classreflex_1_1_boost_posix_matcher.html" title="Boost matcher engine class, extends reflex::BoostMatcher for Boost POSIX regex matching. ">reflex::BoostPosixMatcher</a></code> creates a POSIX matcher. This means that lazy quantifiers are not supported and the <em>leftmost longest rule</em> applies to pattern matching. This instance is initialized with the flags <code>match_posix</code> and <code>match_not_dot_newline</code>.</p>
<p>Boost.Regex is a powerful library. The RE/flex regex API enhances this library with operations to match, search, scan, and split data from a given input. The input can be a file, a string, or a stream. Files that are UTF-8/16/32-encoded are automatically decoded. Further, streams can be of unlimited length because internal buffering is used by the RE/flex regex API enhancements to efficiently apply Boost.Regex pattern matching to streaming data. This enhancement permits pattern matching of interactive input from the console, such that searching and scanning interactive input for matches will return these matches immediately.</p>
<dl class="section note"><dt>Note</dt><dd>The <code><a class="el" href="classreflex_1_1_boost_matcher.html" title="Boost matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::BoostMatcher</a></code> extends the capabilities of Boost.Regex, which does not natively support streaming input:</dd>
<dd>
The Boost.Regex library requires the target text to be loaded into memory for pattern matching. It is possible to match a target text incrementally with the <code>match_partial</code> flag and <code>boost::regex_iterator</code>. Incremental matching can be used to support matching on (possibly infinite) streams. To use this method correctly, a buffer should be created that is large enough to hold the text for each match. The buffer must adjust with a growing size of the matched text, to ensure that long matches that do not fit the buffer are not discared.</dd>
<dd>
Boost.Regex <code>Boost.IOStreams</code> with <code>regex_filter</code> loads the entire stream into memory which does not permit pattern matching of streaming and interactive input data.</dd></dl>
<p>A <code><a class="el" href="classreflex_1_1_boost_matcher.html" title="Boost matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::BoostMatcher</a></code> (or <code><a class="el" href="classreflex_1_1_boost_perl_matcher.html" title="Boost matcher engine class, extends reflex::BoostMatcher for Boost Perl regex matching. ">reflex::BoostPerlMatcher</a></code>) engine is created from a <code>boost::regex</code> object, or string regex, and some given input for normal (Perl mode) matching:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher( boost::regex or <span class="keywordtype">string</span>, <a class="code" href="classreflex_1_1_input.html">reflex::Input</a> [, <span class="stringliteral">&quot;options&quot;</span>] )</div></div><!-- fragment --><p>A <code><a class="el" href="classreflex_1_1_boost_posix_matcher.html" title="Boost matcher engine class, extends reflex::BoostMatcher for Boost POSIX regex matching. ">reflex::BoostPosixMatcher</a></code> engine is created from a <code>boost::regex</code> object, or string regex, and some given input for POSIX mode matching:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_boost_posix_matcher.html">reflex::BoostPosixMatcher</a> matcher( boost::regex or <span class="keywordtype">string</span>, <a class="code" href="classreflex_1_1_input.html">reflex::Input</a> [, <span class="stringliteral">&quot;options&quot;</span>] )</div></div><!-- fragment --><p>For input you can specify a string, a wide string, a file, or a stream object.</p>
<p>Use option <code>"N"</code> to permit empty matches (nullable results).</p>
<p>You can convert an expressive regex of the form defined in <a class="el" href="index.html#reflex-patterns">Patterns </a> to a regex that the boost::regex engine can handle:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string regex = <a class="code" href="classreflex_1_1_boost_matcher.html#ad1827615da2d51f4896e9c802b6463fc">reflex::BoostMatcher::convert</a>( <span class="keywordtype">string</span>, [ flags ]);</div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher( regex, <a class="code" href="classreflex_1_1_input.html">reflex::Input</a> [, <span class="stringliteral">&quot;options&quot;</span>] )</div></div><!-- fragment --><p>The converter is specific to the matcher selected, i.e. <code><a class="el" href="classreflex_1_1_boost_matcher.html#ad1827615da2d51f4896e9c802b6463fc" title="Convert a regex to an acceptable form, given the specified regex library signature &quot;[decls:]escapes[...">reflex::BoostMatcher::convert</a></code>, <code><a class="el" href="classreflex_1_1_boost_matcher.html#ad1827615da2d51f4896e9c802b6463fc" title="Convert a regex to an acceptable form, given the specified regex library signature &quot;[decls:]escapes[...">reflex::BoostPerlMatcher::convert</a></code>, and <code><a class="el" href="classreflex_1_1_boost_posix_matcher.html#a51f86b84e5bd4914ef37495c6847eb2a" title="Convert a regex to an acceptable form, given the specified regex library signature &quot;[decls:]escapes[...">reflex::BoostPosixMatcher::convert</a></code>. The converters also translates Unicode <code>\p</code> character classes to UTF-8 patterns, converts bracket character classes containing Unicode, and groups UTF-8 multi-byte sequences in the regex string.</p>
<p>The converter throws a <code><a class="el" href="classreflex_1_1regex__error.html" title="Regex syntax error exceptions. ">reflex::regex_error</a></code> exception if conversion fails, for example when the regex syntax is invalid.</p>
<p>See <a class="el" href="index.html#reflex-patterns">Patterns </a> for more details on regex patterns.</p>
<p>See <a class="el" href="index.html#regex-input">The Input class </a> for more details on the <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> class.</p>
<p>See <a class="el" href="index.html#regex-methods">Methods and iterators </a> for more details on pattern matching methods.</p>
<p>See <a class="el" href="index.html#regex-convert">Regex converters </a> for more details on regex converters.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="regex-std"></a>
std::regex matcher classes                                         </h2>
<p>The <code><a class="el" href="classreflex_1_1_std_matcher.html" title="std matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::StdMatcher</a></code> class inherits <code><a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a>&lt;std::regex&gt;</code> as a base. The <code><a class="el" href="classreflex_1_1_std_ecma_matcher.html" title="std matcher engine class, extends reflex::StdMatcher for ECMA std::regex::ECMAScript syntax and regex...">reflex::StdEcmaMatcher</a></code> and <code><a class="el" href="classreflex_1_1_std_posix_matcher.html" title="std matcher engine class, extends reflex::StdMatcher for POSIX ERE std::regex::awk syntax and regex m...">reflex::StdPosixMatcher</a></code> are derived classes from <code><a class="el" href="classreflex_1_1_std_matcher.html" title="std matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::StdMatcher</a></code>:</p>
<div class="image">
<img src="classreflex_1_1_std_matcher__inherit__graph.png" />
</div>
<p>An instance of <code><a class="el" href="classreflex_1_1_std_ecma_matcher.html" title="std matcher engine class, extends reflex::StdMatcher for ECMA std::regex::ECMAScript syntax and regex...">reflex::StdEcmaMatcher</a></code> is initialized with regex syntax option <code>std::regex::ECMAScript</code>. This is also the default std::regex syntax.</p>
<p>An instance of <code><a class="el" href="classreflex_1_1_std_posix_matcher.html" title="std matcher engine class, extends reflex::StdMatcher for POSIX ERE std::regex::awk syntax and regex m...">reflex::StdPosixMatcher</a></code> creates a POSIX AWK-based matcher. So that lazy quantifiers are not supported and the <em>leftmost longest rule</em> applies to pattern matching. This instance is initialized with the regex syntax option <code>std::regex::awk</code>.</p>
<p>The C++11 std::regex library does not support <code>match_partial</code> that is needed to match patterns on real streams with an adaptive internal buffer that grows when longer matches are made when more input becomes available. Therefore all input is buffered with the C++11 std::regex class matchers.</p>
<p>With respect to performance, as of this time of writing, std::regex matching is much slower than Boost.Regex, slower by a factor 10 or more.</p>
<p>The std::regex syntax is more limited than Boost.Regex and RE/flex regex. Also the matching behavior differs and cannot be controlled with mode modifiers:</p>
<ul>
<li><code>.</code> (dot) matches anything except <code>\0</code> (NUL);</li>
<li><code>\177</code> is erroneously interpreted as a backreference, <code>\0177</code> does not match;</li>
<li><code>\x7f</code> is not supported in POSIX mode;</li>
<li><code>\cX</code> is not supported in POSIX mode;</li>
<li><code>\Q..\E</code> is not supported;</li>
<li>no mode modifiers <code>(?imsux:φ)</code>;</li>
<li>no <code>\A</code>, <code>\z</code>, <code>\&lt;</code> and <code>\&gt;</code> anchors;</li>
<li>no <code>\b</code> and <code>\B</code> anchors in POSIX mode;</li>
<li>no non-capturing groups <code>(?:φ)</code> in POSIX mode;</li>
<li>empty regex patterns and matcher option <code>"N"</code> (nullable) may cause issues (std::regex <code>match_not_null</code> is buggy);</li>
<li><code>interactive()</code> is not supported.</li>
</ul>
<p>To avoid these limitations on the std::regex syntax imposed, you can convert an expressive regex of the form defined in section <a class="el" href="index.html#reflex-patterns">Patterns </a> to a regex that the std::regex engine can handle:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdmatcher_8h.html">reflex/stdmatcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string regex = <a class="code" href="classreflex_1_1_std_matcher.html#a5b24b7a11cc3c8b7c2b949fb9cfae60a">reflex::StdMatcher::convert</a>( <span class="keywordtype">string</span>, [ flags ]);</div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_std_matcher.html">reflex::StdMatcher</a> matcher( regex, <a class="code" href="classreflex_1_1_input.html">reflex::Input</a> [, <span class="stringliteral">&quot;options&quot;</span>] )</div></div><!-- fragment --><p>The converter is specific to the matcher selected, i.e. <code><a class="el" href="classreflex_1_1_std_matcher.html#a5b24b7a11cc3c8b7c2b949fb9cfae60a" title="Convert a regex to an acceptable form, given the specified regex library signature &quot;[decls:]escapes[...">reflex::StdMatcher::convert</a></code>, <code><a class="el" href="classreflex_1_1_std_matcher.html#a5b24b7a11cc3c8b7c2b949fb9cfae60a" title="Convert a regex to an acceptable form, given the specified regex library signature &quot;[decls:]escapes[...">reflex::StdEcmaMatcher::convert</a></code>, and <code><a class="el" href="classreflex_1_1_std_posix_matcher.html#af0c8ddd6ae3216b70dc36357e41c71c6" title="Convert a regex to an acceptable form, given the specified regex library signature &quot;[decls:]escapes[...">reflex::StdPosixMatcher::convert</a></code>. The converters also translates Unicode <code>\p</code> character classes to UTF-8 patterns, converts bracket character classes containing Unicode, and groups UTF-8 multi-byte sequences in the regex string.</p>
<p>The converter throws a <code><a class="el" href="classreflex_1_1regex__error.html" title="Regex syntax error exceptions. ">reflex::regex_error</a></code> exception if conversion fails, for example when the regex syntax is invalid.</p>
<p>See <a class="el" href="index.html#reflex-patterns">Patterns </a> for more details on regex patterns.</p>
<p>See <a class="el" href="index.html#regex-input">The Input class </a> for more details on the <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> class.</p>
<p>See <a class="el" href="index.html#regex-methods">Methods and iterators </a> for more details on pattern matching methods.</p>
<p>See <a class="el" href="index.html#regex-convert">Regex converters </a> for more details on regex converters.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="regex-matcher"></a>
The RE/flex matcher class                                      </h2>
<p>The RE/flex framework includes a POSIX regex matching library <code><a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a></code> that inherits the API from <code><a class="el" href="classreflex_1_1_pattern_matcher.html" title="The pattern matcher class template extends abstract matcher base class. ">reflex::PatternMatcher</a>&lt;<a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a>&gt;</code>:</p>
<div class="image">
<img src="classreflex_1_1_matcher__inherit__graph.png" />
</div>
<p>where the RE/flex <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> class represents a regex pattern. Patterns as regex texts are internally compiled into deterministic finite state machines by the <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> class. The machines are used by the <code><a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a></code> for fast matching of regex patterns on some given input. The <code><a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a></code> can be much faster than the Boost.Regex matchers.</p>
<p>A <code><a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a></code> engine is constructed from a <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> object, or a string regex, and some given input:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matcher_8h.html">reflex/matcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_matcher.html">reflex::Matcher</a> matcher( <a class="code" href="classreflex_1_1_pattern.html">reflex::Pattern</a> or <span class="keywordtype">string</span>, <a class="code" href="classreflex_1_1_input.html">reflex::Input</a> [, <span class="stringliteral">&quot;options&quot;</span>] )</div></div><!-- fragment --><p>The regex is specified as a string or a <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> object, see <a class="el" href="index.html#regex-pattern">The RE/flex pattern class </a> below.</p>
<p>Use option <code>"N"</code> to permit empty matches (nullable results). Option <code>"T=8"</code> sets the tab size to 8 for indent <code>\i</code> and dedent <code>\j</code> matching.</p>
<p>For input you can specify a string, a wide string, a file, or a stream object.</p>
<p>A regex string with Unicode patterns can be converted for Unicode matching as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matcher_8h.html">reflex/matcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> std::string regex = <a class="code" href="classreflex_1_1_matcher.html#a8862686f6d5680d4d0e5af146c4aed69">reflex::Matcher::convert</a>( <span class="keywordtype">string</span>, [ flags ]);</div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_matcher.html">reflex::Matcher</a> matcher( regex, <a class="code" href="classreflex_1_1_input.html">reflex::Input</a> [, <span class="stringliteral">&quot;options&quot;</span>] )</div></div><!-- fragment --><p>The converter is specific to the matcher and translates Unicode <code>\p</code> character classes to UTF-8 patterns, converts bracket character classes containing Unicode, and groups UTF-8 multi-byte sequences in the regex string.</p>
<p>See <a class="el" href="index.html#reflex-patterns">Patterns </a> for more details on regex patterns.</p>
<p>See <a class="el" href="index.html#regex-input">The Input class </a> for more details on the <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> class.</p>
<p>See <a class="el" href="index.html#regex-methods">Methods and iterators </a> for more details on pattern matching methods.</p>
<p>See <a class="el" href="index.html#regex-convert">Regex converters </a> for more details on regex converters.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="regex-pattern"></a>
The RE/flex pattern class                                      </h2>
<p>The <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> class is used by the <code>reflex::matcher</code> for pattern matching. The <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> class converts a regex pattern to an efficient FSM and takes a regex string and options to construct the FSM internally:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matcher_8h.html">reflex/matcher.h</a>&gt;</span></div><div class="line"></div><div class="line">[<span class="keyword">static</span>] <a class="code" href="namespacereflex.html">reflex</a>:Pattern pattern(<span class="keywordtype">string</span> [, <span class="stringliteral">&quot;options&quot;</span>] )</div></div><!-- fragment --><p>It is recommended to create a static instance of the pattern if the regex string is fixed. This avoids repeated FSM construction.</p>
<p>The following options are combined in a string and passed to the <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> contructor:</p>
<table class="doxtable">
<tr>
<th>Option </th><th>Effect  </th></tr>
<tr>
<td><code>b</code> </td><td>bracket lists are parsed without converting escapes </td></tr>
<tr>
<td><code>e=c;</code> </td><td>redefine the escape character </td></tr>
<tr>
<td><code>f=file.cpp;</code> </td><td>save finite state machine code to file.cpp </td></tr>
<tr>
<td><code>f=file.gv;</code> </td><td>save deterministic finite state machine to file.gv </td></tr>
<tr>
<td><code>i</code> </td><td>case-insensitive matching, same as <code>(?i)X</code> </td></tr>
<tr>
<td><code>l</code> </td><td>Lex-style trailing context with <code>/</code>, same as <code>(?l)X</code> </td></tr>
<tr>
<td><code>m</code> </td><td>multiline mode, same as <code>(?m)X</code> </td></tr>
<tr>
<td><code>n=name;</code> </td><td>use <code>reflex_code_name</code> for the machine (instead of FSM) </td></tr>
<tr>
<td><code>q</code> </td><td>Lex-style quotations "..." equals <code>\Q...\E</code>, same as <code>(?q)X</code> </td></tr>
<tr>
<td><code>r</code> </td><td>throw regex syntax error exceptions (not just fatal errors) </td></tr>
<tr>
<td><code>s</code> </td><td>dot matches all (aka. single line mode), same as <code>(?s)X</code> </td></tr>
<tr>
<td><code>x</code> </td><td>inline comments, same as <code>(?x)X</code> </td></tr>
<tr>
<td><code>w</code> </td><td>display regex syntax errors before raising them as exceptions </td></tr>
</table>
<p>The compilation of a <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> object into a FSM may throw an exception when the regex string has problems:</p>
<div class="fragment"><div class="line"><span class="keywordflow">try</span></div><div class="line">{</div><div class="line">  <a class="code" href="classreflex_1_1_pattern.html">reflex::Pattern</a> pattern(argv[1]);</div><div class="line">  ...</div><div class="line">  <span class="comment">// code that uses the pattern object</span></div><div class="line">  ...</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span> (<a class="code" href="classreflex_1_1regex__error.html">reflex::regex_error</a>&amp; e)</div><div class="line">{</div><div class="line">  std::cerr &lt;&lt; e.what();</div><div class="line">  <span class="keywordflow">switch</span> (e)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a293014262113a8affe812cdc1a155199">reflex::regex_error::mismatched_parens</a>:    std::cerr &lt;&lt; <span class="stringliteral">&quot;mismatched ( )&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#aa103b656bc8c84276caa3a3e479d5aed">reflex::regex_error::mismatched_braces</a>:    std::cerr &lt;&lt; <span class="stringliteral">&quot;mismatched { }&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a388b62b0f150f2c4e673a7326df98bf0">reflex::regex_error::mismatched_brackets</a>:  std::cerr &lt;&lt; <span class="stringliteral">&quot;mismatched [ ]&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a4da14a39e65667e922d4ac9251d3acf2">reflex::regex_error::mismatched_quotation</a>: std::cerr &lt;&lt; <span class="stringliteral">&quot;mismatched \Q...\E quotation&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#aba10b497ace31b4e829961820f59ac1f">reflex::regex_error::empty_expression</a>:     std::cerr &lt;&lt; <span class="stringliteral">&quot;regex (sub)expression should not be empty&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#ab8d5ad921586a5821a5a6ea57f3ef7f3">reflex::regex_error::empty_class</a>:          std::cerr &lt;&lt; <span class="stringliteral">&quot;class [...] is empty, e.g. [a&amp;&amp;[b]]&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#ac7c47c5a86f7f50f4128e4b31f3b8cd8">reflex::regex_error::invalid_class</a>:        std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid character class name&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a0a3dbc259753fe9c56bcb86ab22933f6">reflex::regex_error::invalid_class_range</a>:  std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid class range, e.g. [Z-A]&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a3f67bcffa141ac3fd804dfe28a009165">reflex::regex_error::invalid_escape</a>:       std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid escape character&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#abe00de8d9374f3b3528c181c3bbcee7c">reflex::regex_error::invalid_anchor</a>:       std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid anchor&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a72584e74ccf493595d88f0ccc4b61f55">reflex::regex_error::invalid_repeat</a>:       std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid repeat range, e.g. {10,1}&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a1c01a511c833d13708a5607c7a6d810a">reflex::regex_error::invalid_quantifier</a>:   std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid lazy/possessive quantifier&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#af9454b097595a8c39fe0118cdbae60d0">reflex::regex_error::invalid_modifier</a>:     std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid (?ismux:) modifier&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#ac3e3283b3859fae05b21655d8ee096a6">reflex::regex_error::invalid_syntax</a>:       std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid regex syntax&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a0c63bf6cff5be3ddb509de3ea84d6e41">reflex::regex_error::exceeds_limits</a>:       std::cerr &lt;&lt; <span class="stringliteral">&quot;exceeds complexity limits: {n,m} range too large&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="regex-convert"></a>
Regex converters                                               </h2>
<p>To work around limitations of regex libraries and to support Unicode matching, RE/flex offers converters to translate expressive regex syntax forms (with Unicode patterns defined in section <a class="el" href="index.html#reflex-patterns">Patterns </a>) to regex strings that the selected regex engines can handle.</p>
<p>The converters translate <code>\p</code> Unicode classes, translate character class set operations such as <code>[a-z−−[aeiou]]</code>, convert escapes such as <code>\X</code>, and enforce <code>(?imsux:φ)</code> mode modifiers to a regex string that the underlying regex library understands and can use.</p>
<p>Each converter is specific to the regex engine. Use a converter for the matcher of your choice:</p>
<ul>
<li><code>std::string reflex::BoostMatcher::convert(const std::string&amp; regex, reflex::convert_flag_type flags)</code> converts <code>regex</code> for use with Boost.Regex;</li>
<li><code>std::string reflex::BoostPerlMatcher::convert(const std::string&amp; regex, reflex::convert_flag_type flags)</code> converts <code>regex</code> for use with Boost.Regex in Perl mode;</li>
<li><code>std::string reflex::BoostPosixMatcher::convert(const std::string&amp; regex, reflex::convert_flag_type flags)</code> converts <code>regex</code> for use with Boost.Regex in POSIX mode;</li>
<li><code>std::string reflex::StdMatcher::convert(const std::string&amp; regex, reflex::convert_flag_type flags)</code> converts <code>regex</code> for use with C++ std::regex;</li>
<li><code>std::string reflex::StdEcmaMatcher::convert(const std::string&amp; regex, reflex::convert_flag_type flags)</code> converts <code>regex</code> for use with C++ std::regex in ECMA mode;</li>
<li><code>std::string reflex::StdPosixMatcher::convert(const std::string&amp; regex, reflex::convert_flag_type flags)</code> converts <code>regex</code> for use with C++ std::regex in POSIX mode;</li>
<li><code>std::string reflex::Matcher::convert(const std::string&amp; regex, reflex::convert_flag_type flags)</code> converts <code>regex</code> for use with the RE/flex POSIX regex library;</li>
</ul>
<p>where <code>flags</code> is optional. When specified, it can be a combination of the following <code><a class="el" href="namespacereflex_1_1convert__flag.html">reflex::convert_flag</a></code> flags:</p>
<table class="doxtable">
<tr>
<th>Flag </th><th>Effect  </th></tr>
<tr>
<td><code>unicode</code> </td><td><code>.</code>, <code>\s</code>, <code>\w</code>, <code>\l</code>, <code>\u</code>, <code>\S</code>, <code>\W</code>, <code>\L</code>, <code>\U</code> match Unicode, same as <code>(?u)</code> </td></tr>
<tr>
<td><code>recap</code> </td><td>remove capturing groups, add capturing groups to the top level </td></tr>
<tr>
<td><code>lex</code> </td><td>convert Lex/Flex regular expression syntax </td></tr>
<tr>
<td><code>u4</code> </td><td>convert <code>\uXXXX</code> (shorthand of <code>\u{XXXX}</code>) </td></tr>
<tr>
<td><code>anycase</code> </td><td>convert regex to ignore case, same as <code>(?i)</code> </td></tr>
<tr>
<td><code>multiline</code> </td><td>regex has multiline anchors <code>^</code> and <code>$</code>, same as <code>(?m)</code> </td></tr>
<tr>
<td><code>dotall</code> </td><td>convert <code>.</code> (dot) to match all, same as <code>(?s)</code> </td></tr>
<tr>
<td><code>freespace</code> </td><td>convert regex by removing spacing, same as <code>(?x)</code> </td></tr>
</table>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matcher_8h.html">reflex/matcher.h</a>&gt;</span> <span class="comment">// reflex::Matcher, reflex::Input, reflex::Pattern</span></div><div class="line"></div><div class="line"><span class="comment">// use a Matcher to check if sentence is in Greek:</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classreflex_1_1_pattern.html">reflex::Pattern</a> pattern(<a class="code" href="classreflex_1_1_matcher.html#a8862686f6d5680d4d0e5af146c4aed69">reflex::Matcher::convert</a>(<span class="stringliteral">&quot;[\\p{Greek}\\p{Zs}\\pP]+&quot;</span>, <a class="code" href="namespacereflex_1_1convert__flag.html#ab1c057a380f8673a13064c755652dc39">reflex::convert_flag::unicode</a>));</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classreflex_1_1_matcher.html">reflex::Matcher</a>(pattern, sentence).matches())</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;This is Greek&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>For example, the <code>unicode</code> flag and <code>dotall</code> flag can be used with a <code>.</code> regex pattern to count wide characters in some <code>example</code> input:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><span class="comment">// construct a Boost.Regex matcher to count wide characters:</span></div><div class="line">std::string regex = <a class="code" href="classreflex_1_1_boost_matcher.html#ad1827615da2d51f4896e9c802b6463fc">reflex::BoostMatcher::convert</a>(<span class="stringliteral">&quot;.&quot;</span>, <a class="code" href="namespacereflex_1_1convert__flag.html#ab1c057a380f8673a13064c755652dc39">reflex::convert_flag::unicode</a> | <a class="code" href="namespacereflex_1_1convert__flag.html#ab6a63c3a106c2dbcbad7b86797453f58">reflex::convert_flag::dotall</a>);</div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> boostmatcher(regex, example);</div><div class="line"><span class="keywordtype">size_t</span> n = std::distance(boostmatcher.scan.begin(), boostmatcher.scan.end());</div></div><!-- fragment --><p>You can also use the regex <code>"\\X"</code> to match any wide character without using these flags.</p>
<p>A converter throws a <code><a class="el" href="classreflex_1_1regex__error.html" title="Regex syntax error exceptions. ">reflex::regex_error</a></code> exception if conversion fails, for example when the regex syntax is invalid:</p>
<div class="fragment"><div class="line">std::string regex;</div><div class="line"><span class="keywordflow">try</span></div><div class="line">{</div><div class="line">  regex = <a class="code" href="classreflex_1_1_boost_matcher.html#ad1827615da2d51f4896e9c802b6463fc">reflex::BoostMatcher::convert</a>(argv[1], <a class="code" href="namespacereflex_1_1convert__flag.html#ab1c057a380f8673a13064c755652dc39">reflex::convert_flag::unicode</a>));</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span> (<a class="code" href="classreflex_1_1regex__error.html">reflex::regex_error</a>&amp; e)</div><div class="line">{</div><div class="line">  std::cerr &lt;&lt; e.what();</div><div class="line">  <span class="keywordflow">switch</span> (e)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a293014262113a8affe812cdc1a155199">reflex::regex_error::mismatched_parens</a>:    std::cerr &lt;&lt; <span class="stringliteral">&quot;mismatched ( )&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#aa103b656bc8c84276caa3a3e479d5aed">reflex::regex_error::mismatched_braces</a>:    std::cerr &lt;&lt; <span class="stringliteral">&quot;mismatched { }&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a388b62b0f150f2c4e673a7326df98bf0">reflex::regex_error::mismatched_brackets</a>:  std::cerr &lt;&lt; <span class="stringliteral">&quot;mismatched [ ]&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a4da14a39e65667e922d4ac9251d3acf2">reflex::regex_error::mismatched_quotation</a>: std::cerr &lt;&lt; <span class="stringliteral">&quot;mismatched \Q...\E quotation&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#aba10b497ace31b4e829961820f59ac1f">reflex::regex_error::empty_expression</a>:     std::cerr &lt;&lt; <span class="stringliteral">&quot;regex (sub)expression should not be empty&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#ab8d5ad921586a5821a5a6ea57f3ef7f3">reflex::regex_error::empty_class</a>:          std::cerr &lt;&lt; <span class="stringliteral">&quot;class [...] is empty, e.g. [a&amp;&amp;[b]]&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#ac7c47c5a86f7f50f4128e4b31f3b8cd8">reflex::regex_error::invalid_class</a>:        std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid character class name&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a0a3dbc259753fe9c56bcb86ab22933f6">reflex::regex_error::invalid_class_range</a>:  std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid class range, e.g. [Z-A]&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a3f67bcffa141ac3fd804dfe28a009165">reflex::regex_error::invalid_escape</a>:       std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid escape character&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#abe00de8d9374f3b3528c181c3bbcee7c">reflex::regex_error::invalid_anchor</a>:       std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid anchor&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a72584e74ccf493595d88f0ccc4b61f55">reflex::regex_error::invalid_repeat</a>:       std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid repeat range, e.g. {10,1}&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#a1c01a511c833d13708a5607c7a6d810a">reflex::regex_error::invalid_quantifier</a>:   std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid lazy/possessive quantifier&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#af9454b097595a8c39fe0118cdbae60d0">reflex::regex_error::invalid_modifier</a>:     std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid (?ismux:) modifier&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="classreflex_1_1regex__error.html#ac3e3283b3859fae05b21655d8ee096a6">reflex::regex_error::invalid_syntax</a>:       std::cerr &lt;&lt; <span class="stringliteral">&quot;invalid regex syntax&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="regex-methods"></a>
Methods and iterators                                          </h2>
<p>The RE/flex abstract matcher provides four operations for matching with an instance of a regex engine:</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Result  </th></tr>
<tr>
<td><code>matches()</code> </td><td>true if the input from begin to end matches the regex pattern </td></tr>
<tr>
<td><code>find()</code> </td><td>search input and return true if a match was found </td></tr>
<tr>
<td><code>scan()</code> </td><td>scan input and return true if input at current position matches </td></tr>
<tr>
<td><code>split()</code> </td><td>split input at the next match </td></tr>
</table>
<p>The <code>find</code>, <code>scan</code>, and <code>split</code> methods are also implemented as input iterators that apply filtering tokenization, and splitting:</p>
<table class="doxtable">
<tr>
<th>Iterator range </th><th>Acts as a </th><th>Iterates over  </th></tr>
<tr>
<td><code>find.begin()</code>...<code>find.end()</code> </td><td>filter </td><td>all matches </td></tr>
<tr>
<td><code>scan.begin()</code>...<code>scan.end()</code> </td><td>tokenizer </td><td>continuous matches </td></tr>
<tr>
<td><code>split.begin()</code>...<code>split.end()</code> </td><td>splitter </td><td>text between matches </td></tr>
</table>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="regex-methods-matches"></a>
matches</h3>
<p>The <code>matches()</code> method returns true if the given input from begin to the end matches the specified pattern. For example, to match a UUID string:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line">std::string uuid = <span class="stringliteral">&quot;123e4567-e89b-12d3-a456-426655440000&quot;</span>;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a>(<span class="stringliteral">&quot;[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}&quot;</span>, uuid).matches())</div><div class="line">  std::cout &lt;&lt; uuid &lt;&lt; <span class="stringliteral">&quot; is a string in UUID format&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">123e4567-e89b-12d3-a456-426655440000 is a string in UUID format
</pre><p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="regex-methods-find"></a>
find</h3>
<p>The <code>find()</code> method and <code>find</code> iterator search for a match in the given input. The iterator iterates over matches found and serves as an input filter.</p>
<p>For example, to find all words in a string:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;\\w+&quot;</span>, <span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line"><span class="keywordflow">while</span> (matcher.find() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; matcher.text() &lt;&lt; std::endl;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">How
now
brown
cow
</pre><p>In C++11 we can use a range-based loop to loop over matches using the <code>find</code> iterator:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; match : <a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a>(<span class="stringliteral">&quot;\\w+&quot;</span>, <span class="stringliteral">&quot;How now brown cow.&quot;</span>).find)</div><div class="line">  std::cout &lt;&lt; match.text() &lt;&lt; std::endl;</div></div><!-- fragment --><p>Iterators can be used with STL algorithms and other iterator functions. For example to count words in a string:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;\\w+&quot;</span>, <span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line">std::cout &lt;&lt; std::distance(matcher.find.begin(), boostmatcher.find.end()) &lt;&lt; std::endl;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">4
</pre><p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="regex-methods-scan"></a>
scan</h3>
<p>The <code>scan()</code> method and <code>scan</code> iterator are similar to <code>find</code> but return continuous matches in the given input, meaning matches without gaps. The iterator iterates over continuous matches and serves as an input tokenizer.</p>
<p>For example, to scan for words, spacing, and punctuation in a sentence:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *tokens[4] = { <span class="stringliteral">&quot;n/a&quot;</span>, <span class="stringliteral">&quot;word&quot;</span>, <span class="stringliteral">&quot;space&quot;</span>, <span class="stringliteral">&quot;other&quot;</span> };</div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;(\\w+)|(\\s+)|(.)&quot;</span>, <span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line"><span class="keywordflow">while</span> (matcher.scan() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; tokens[matcher.accept()] &lt;&lt; std::endl;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">word
space
word
space
word
space
word
other
</pre><p>If the pattern does not match the input immediately succeeding a previous match, then the <code>scan()</code> method returns false and the iterator returns <code>scan.end()</code>. To determine if all input was scanned and end of input was reached, use the <code>at_end()</code> method, see <a class="el" href="index.html#regex-methods-props">Properties of a match</a>.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="regex-methods-split"></a>
split</h3>
<p>The <code>split()</code> method and <code>split</code> iterator search for text between matches in the given input. The iterator iterates over these splits and serves as an input splitter.</p>
<p>The matches returns empty text between adjacent matches. Also the start of input and end of input return text matches, which may be empty. For example, to split text into words by matching non-words:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;\\W+&quot;</span>, <span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line"><span class="keywordflow">while</span> (matcher.split() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; matcher.text() &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">'How'
'now'
'brown'
'cow'
''
</pre><p>This produces five text splits where the last text is empty because the period at the end of the sentence matches the pattern and empty input remains.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="regex-methods-props"></a>
Properties of a match</h3>
<p>To obtain properties of a match, use the following methods:</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Result  </th></tr>
<tr>
<td><code>accept()</code> </td><td>returns group capture index or zero if not captured/matched </td></tr>
<tr>
<td><code>text()</code> </td><td>returns <code>const char*</code> to NUL-terminated match (ends in <code>\0</code>) </td></tr>
<tr>
<td><code>str()</code> </td><td>returns <code>std::string</code> copy of <code>text()</code> (but preserves <code>\0</code>s) </td></tr>
<tr>
<td><code>wstr()</code> </td><td>returns <code>std::wstring</code> copy of <code>text()</code>, converted from UTF-8 </td></tr>
<tr>
<td><code>pair()</code> </td><td>returns <code>std::pair&lt;size_t,std::string&gt;(accept(),str())</code> </td></tr>
<tr>
<td><code>wpair()</code> </td><td>returns <code>std::pair&lt;size_t,std::wstring&gt;(accept(),wstr())</code> </td></tr>
<tr>
<td><code>size()</code> </td><td>returns the length of the text match in bytes </td></tr>
<tr>
<td><code>wsize()</code> </td><td>returns the length of the match in number of wide characters </td></tr>
<tr>
<td><code>begin()</code> </td><td>returns <code>const char*</code> to non-NUL-terminated match begin </td></tr>
<tr>
<td><code>end()</code> </td><td>returns <code>const char*</code> to non-NUL-terminated match end </td></tr>
<tr>
<td><code>rest()</code> </td><td>returns <code>const char*</code> to NUL-terminated rest of input </td></tr>
<tr>
<td><code>more()</code> </td><td>tells the matcher to append the next match (adjacent matches) </td></tr>
<tr>
<td><code>less(n)</code> </td><td>cuts <code>text()</code> to <code>n</code> bytes and repositions the matcher </td></tr>
<tr>
<td><code>lineno()</code> </td><td>returns line number of the match, starting with line 1 </td></tr>
<tr>
<td><code>columno()</code> </td><td>returns column number of the match, starting with 0 </td></tr>
<tr>
<td><code>first()</code> </td><td>returns position of the first character of the match </td></tr>
<tr>
<td><code>last()</code> </td><td>returns position of the last + 1 character of the match </td></tr>
<tr>
<td><code>at_bol()</code> </td><td>true if matcher reached the begin of a new line <code>\n</code> </td></tr>
<tr>
<td><code>at_bob()</code> </td><td>true if matcher is at the start of input, no matches consumed </td></tr>
<tr>
<td><code>at_end()</code> </td><td>true if matcher is at the end of input </td></tr>
<tr>
<td><code>[0]</code> </td><td>operator returns <code>std::pair&lt;const char*,size_t&gt;(begin(),size())</code> </td></tr>
<tr>
<td><code>[n]</code> </td><td>operator returns n'th capture <code>std::pair&lt;const char*,size_t&gt;</code> </td></tr>
</table>
<p>Note that <code>begin()</code>, <code>operator[0]</code>, and <code>operator[n]</code> return non-NUL-terminated strings. You must use <code>end()</code> with <code>begin()</code> to determine the span of the match. Use the size of the capture to determine the end of the match or capture.</p>
<p>All methods take constant time to execute except for <code>str()</code>, <code>wstr()</code>, <code>pair()</code>, <code>wpair()</code>, <code>wsize()</code>, <code>lineno()</code> and <code>columno()</code> that require a pass over the (matched) text.</p>
<p>In addition, the following type casts of matcher objects and iterators can be used for convenience:</p>
<ul>
<li>Casting to <code>size_t</code> gives the matcher's <code>accept()</code> index.</li>
<li>Casting to <code>std::string</code> is the same as invoking <code>str()</code></li>
<li>Casting to <code>std::wstring</code> is the same as invoking <code>wstr()</code>.</li>
<li>Casting to <code>std::pair&lt;size_t,std::string&gt;</code> is the same as <code>pair()</code>.</li>
<li>Casting to <code>std::pair&lt;size_t,std::wstring&gt;</code> is the same as <code>wpair()</code>.</li>
</ul>
<p>The following example prints some of the properties of each match:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span> <span class="comment">// reflex::BoostMatcher, reflex::Input, boost::regex</span></div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;\\w+&quot;</span>, <span class="stringliteral">&quot;How now brown cow.&quot;</span>);</div><div class="line"><span class="keywordflow">while</span> (matcher.find() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">&quot;accept: &quot;</span> &lt;&lt; matcher.accept() &lt;&lt;</div><div class="line">    <span class="stringliteral">&quot;text:   &quot;</span> &lt;&lt; matcher.text() &lt;&lt;</div><div class="line">    <span class="stringliteral">&quot;size:   &quot;</span> &lt;&lt; matcher.size() &lt;&lt;</div><div class="line">    <span class="stringliteral">&quot;line:   &quot;</span> &lt;&lt; matcher.lineno() &lt;&lt;</div><div class="line">    <span class="stringliteral">&quot;column: &quot;</span> &lt;&lt; matcher.columno() &lt;&lt;</div><div class="line">    <span class="stringliteral">&quot;first:  &quot;</span> &lt;&lt; matcher.first() &lt;&lt;</div><div class="line">    <span class="stringliteral">&quot;last:   &quot;</span> &lt;&lt; matcher.last() &lt;&lt; std::endl;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">accept: 1 text: How size: 3 line: 1 column: 0 first: 0 last: 3
accept: 1 text: now size: 3 line: 1 column: 4 first: 4 last: 7
accept: 1 text: brown size: 5 line: 1 column: 8 first: 8 last: 13
accept: 1 text: cow size: 3 line: 1 column: 14 first: 14 last: 17
</pre><p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="regex-members"></a>
Public data members</h3>
<p>Four public data members of a matcher object are accesible:</p>
<table class="doxtable">
<tr>
<th>Variable </th><th>Usage  </th></tr>
<tr>
<td><code>in</code> </td><td>the <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> object used by the matcher </td></tr>
<tr>
<td><code>find</code> </td><td>the <code><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html" title="AbstractMatcher::Operation functor to match input to a pattern, also provides a (const) AbstractMatch...">reflex::AbstractMatcher::Operation</a></code> functor for searching </td></tr>
<tr>
<td><code>scan</code> </td><td>the <code><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html" title="AbstractMatcher::Operation functor to match input to a pattern, also provides a (const) AbstractMatch...">reflex::AbstractMatcher::Operation</a></code> functor for scanning </td></tr>
<tr>
<td><code>split</code> </td><td>the <code><a class="el" href="classreflex_1_1_abstract_matcher_1_1_operation.html" title="AbstractMatcher::Operation functor to match input to a pattern, also provides a (const) AbstractMatch...">reflex::AbstractMatcher::Operation</a></code> functor for splitting </td></tr>
</table>
<p>Normally only the <code>in</code> variable should be used which holds the current input object of the matcher. See <a class="el" href="index.html#regex-input">The Input class </a> for details.</p>
<p>The functors provide <code>begin()</code> and <code>end()</code> methods that return iterators and hold the necessary state information for the iterators. A functor invocation essentially invokes the corresponding method listed in <a class="el" href="index.html#regex-methods">Methods and iterators </a>.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="regex-methods-pattern"></a>
Pattern methods</h3>
<p>To change a matcher's pattern or check if a pattern was assigned, you can use the following methods:</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Result  </th></tr>
<tr>
<td><code>pattern(p)</code> </td><td>set pattern to <code>p</code> (string regex or <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code>) </td></tr>
<tr>
<td><code>has_pattern()</code> </td><td>true if the matcher has a pattern assigned to it </td></tr>
<tr>
<td><code>own_pattern()</code> </td><td>true if the matcher has a pattern to manage and delete </td></tr>
<tr>
<td><code>pattern()</code> </td><td>get the pattern object, <code><a class="el" href="classreflex_1_1_pattern.html" title="Pattern class holds a regex pattern and its compiled FSM opcode table or code for the reflex::Matcher...">reflex::Pattern</a></code> or <code>boost::regex</code> </td></tr>
</table>
<p>The first method returns a reference to the matcher, so multiple method invocations can be chained together.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="regex-methods-input"></a>
Input methods</h3>
<p>To assign a new input source to a matcher or set the input to buffered or interactive, you can use the following methods:</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Result  </th></tr>
<tr>
<td><code>input(i)</code> </td><td>set input to <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a> i</code> (string, stream, or <code>FILE*</code>) </td></tr>
<tr>
<td><code>buffer()</code> </td><td>buffer all input at once, returns true if successful </td></tr>
<tr>
<td><code>buffer(n)</code> </td><td>set the adaptive buffer size to <code>n</code> bytes to buffer input </td></tr>
<tr>
<td><code>interactive()</code> </td><td>sets buffer size to 1 for console-based (TTY) input </td></tr>
<tr>
<td><code>flush()</code> </td><td>flush the remaining input from the internal buffer </td></tr>
<tr>
<td><code>reset()</code> </td><td>resets the matcher, restarting it from the remaining input </td></tr>
<tr>
<td><code>reset(o)</code> </td><td>resets the matcher with new options string <code>o</code> ("A?N?T?") </td></tr>
</table>
<p>The first method returns a reference to the matcher, so multiple method invocations can be chained together.</p>
<p>Four special methods can be used to read the input stream provided to a matcher directly, even when you use the matcher's search and match methods:</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Result  </th></tr>
<tr>
<td><code>input()</code> </td><td>returns next char 0..255 from the input, matcher then skips it </td></tr>
<tr>
<td><code>winput()</code> </td><td>returns the next wide character from the input, matcher skips it </td></tr>
<tr>
<td><code>unput(c)</code> </td><td>put char <code>c</code> back unto the stream, matcher then takes it </td></tr>
<tr>
<td><code>peek()</code> </td><td>returns the next char 0..255 from the input without consuming it </td></tr>
</table>
<p>A matcher reads from the specified input source using its virtual method <code>size_t get(char *s, size_t n)</code> that simply returns <code>in.get(s, n)</code>, that is, the result of the <code>reflex::Input::get(s, n)</code> method of the <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> object. This method can be overriden by a derived matcher class to customize reading.</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Result  </th></tr>
<tr>
<td><code>get(s, n)</code> </td><td>fill <code>s[0..n-1]</code> with next input, returns number of bytes added </td></tr>
<tr>
<td><code>wrap()</code> </td><td>returns false (can be overriden to wrap input after EOF) </td></tr>
</table>
<p>When a matcher reaches the end of input, it invokes the virtual method <code>wrap()</code> to check if more input is available. This method returns false by default, but this behavior can be changed by overring <code>wrap()</code> to set a new input source and return <code>true</code>, for example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>WrappedInputMatcher : <span class="keyword">public</span> <a class="code" href="classreflex_1_1_matcher.html">reflex::Matcher</a> {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  WrappedInputMatcher() : <a class="code" href="namespacereflex.html">reflex</a>::Matcher(), source_select(0)</div><div class="line">  { }</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classreflex_1_1_abstract_matcher.html#a046e0696b048d229ea2d77f5010c41e1">wrap</a>()</div><div class="line">  {</div><div class="line">    <span class="comment">// read a string, a file, and a string:</span></div><div class="line">    <span class="keywordflow">switch</span> (source_select++)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> 0: in = <span class="stringliteral">&quot;Hello World!&quot;</span>;</div><div class="line">              <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">      <span class="keywordflow">case</span> 1: in = fopen(<span class="stringliteral">&quot;hello.txt&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line">              <span class="keywordflow">return</span> in.file() != NULL;</div><div class="line">      <span class="keywordflow">case</span> 2: fclose(in.file());</div><div class="line">              in = <span class="stringliteral">&quot;Goodbye!&quot;</span>;</div><div class="line">              <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line">  <span class="keywordtype">int</span> source_select;</div><div class="line">};</div></div><!-- fragment --><p>Note that the constructor in this example does not specify a pattern and input. To set a pattern for the matcher after its instantiation use the <code>pattern(p)</code> method. In this case the input does not need to be specified, which allows us to immediately force reading the sources of input that we assigned in our <code>wrap()</code> method.</p>
<p>For details of the <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> class, see <a class="el" href="index.html#regex-input">The Input class </a>.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="regex-input"></a>
The Input class                                                  </h2>
<p>A matcher may accept several types of input, but can only read from one input source at a time. Input to a matcher is represented by a single <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> class instance that the matcher uses internally.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="regex-input-assign"></a>
Assigning input</h3>
<p>An input object can be constructed by specifying a string, a file, or a stream to read from. You can also reassign input to read from new input.</p>
<p>More specifically, you can pass a <code>std::string</code>, <code>char*</code>, <code>std::wstring</code>, <code>wchar_t*</code>, <code>FILE*</code>, or a <code>std::istream</code> object to the constructor.</p>
<p>A <code>FILE*</code> file descriptor is a special case. The input object handles various file encodings. If a UTF BOM is detected then the UTF input will be normalized to UTF-8. When no UTF BOM is detected then the input is considered plain ASCII, binary, or UTF-8 and passed through unconverted. To override the file encoding when no UTF BOM was present, and normalize Latin-1, ISO-8859-1, EBCDIC, and other encodings to UTF-8, see <a class="el" href="index.html#regex-input-file">FILE encodings</a>.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="regex-input-methods"></a>
Input methods</h3>
<p>To obtain the properties of an input source use the following methods:</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Result  </th></tr>
<tr>
<td><code>size()</code> </td><td>size of the input in total bytes (encoded) or zero when unknown </td></tr>
<tr>
<td><code>good()</code> </td><td>input is available to read (no error and not EOF) </td></tr>
<tr>
<td><code>eof()</code> </td><td>end of input (but use only <code>at_end()</code> with matchers!) </td></tr>
<tr>
<td><code>cstring()</code> </td><td>the current <code>const char*</code> (of a <code>std::string</code>) or NULL </td></tr>
<tr>
<td><code>wstring()</code> </td><td>the current <code>const wchar_t*</code> (of a <code>std::wstring</code>) or NULL </td></tr>
<tr>
<td><code>file()</code> </td><td>the current <code>FILE*</code> file descriptor or NULL </td></tr>
<tr>
<td><code>istream()</code> </td><td>a <code>std::istream*</code> pointer to the current stream object or NULL </td></tr>
</table>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3><a class="anchor" id="regex-input-file"></a>
FILE encodings</h3>
<p>File content specified with a <code>FILE*</code> file descriptor can be encoded in ASCII, binary, or UTF-8/16/32 formats. UTF-16/32 file content is automatically decoded and translated to UTF-8 which normalizes the input for matching.</p>
<p>A <a href="www.unicode.org/faq/utf_bom.html">UTF byte order mark (BOM)</a> is detected in the content of a file by the matcher, which enables UTF-8 normalization of the input automatically.</p>
<p>The file encoding is obtained with the <code>file_encoding()</code> method of a <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> object and returns an <code><a class="el" href="structreflex_1_1_input_1_1file__encoding.html" title="Common constants. ">reflex::Input::file_encoding</a></code> constant:</p>
<table class="doxtable">
<tr>
<th>Constant </th><th>File encoding  </th></tr>
<tr>
<td><code><a class="el" href="structreflex_1_1_input_1_1file__encoding.html#a9f48fc525d274af1351fdde16b9e55e3" title="plain octets: 7-bit ASCII, 8-bit binary or UTF-8 without BOM detected ">reflex::Input::file_encoding::plain</a></code> </td><td>plain octets, ASCII/binary/UTF-8 </td></tr>
<tr>
<td><code><a class="el" href="structreflex_1_1_input_1_1file__encoding.html#a1d77bb18dbc37d57df341f1878faa134" title="Basic Latin ASCII and Latin-1 supplement, ISO-8859-1. ">reflex::Input::file_encoding::latin</a></code> </td><td>ASCII and Latin-1, ISO-8859-1 </td></tr>
<tr>
<td><code><a class="el" href="structreflex_1_1_input_1_1file__encoding.html#aa3d38a4be53b6d4401ddcd8734f93c64" title="EBCDIC. ">reflex::Input::file_encoding::ebcdic</a></code> </td><td>EBCDIC </td></tr>
<tr>
<td><code><a class="el" href="structreflex_1_1_input_1_1file__encoding.html#a3fb02ae23658a5f18a9e1bd1edc7af61" title="UTF-8 with BOM detected. ">reflex::Input::file_encoding::utf8</a></code> </td><td>UTF-8 (BOM detected) </td></tr>
<tr>
<td><code><a class="el" href="structreflex_1_1_input_1_1file__encoding.html#a384c11d51f3320424bf1d78b581d1e24" title="UTF-16 big endian. ">reflex::Input::file_encoding::utf16be</a></code> </td><td>UTF-16 big endian (BOM detected) </td></tr>
<tr>
<td><code><a class="el" href="structreflex_1_1_input_1_1file__encoding.html#aa053fdac14b83ea2040ae500e06bbde5" title="UTF-16 little endian. ">reflex::Input::file_encoding::utf16le</a></code> </td><td>UTF-16 little endian (BOM detected) </td></tr>
<tr>
<td><code><a class="el" href="structreflex_1_1_input_1_1file__encoding.html#a4c9c0952f934dff7970320f054d87244" title="UTF-32 big endian. ">reflex::Input::file_encoding::utf32be</a></code> </td><td>UTF-32 big endian (BOM detected) </td></tr>
<tr>
<td><code><a class="el" href="structreflex_1_1_input_1_1file__encoding.html#a6dab80b13b986dd7d21dc59acf8a7325" title="UTF-32 little endian. ">reflex::Input::file_encoding::utf32le</a></code> </td><td>UTF-32 little endian (BOM detected) </td></tr>
</table>
<p>To set the file encoding when assigning a file to read, use <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input(file, enc)</a></code> to construct the input object.</p>
<p>For example, use <code><a class="el" href="structreflex_1_1_input_1_1file__encoding.html#a1d77bb18dbc37d57df341f1878faa134" title="Basic Latin ASCII and Latin-1 supplement, ISO-8859-1. ">reflex::Input::file_encoding::latin</a></code> to override the encoding when the file contains ISO-8859-1. This way you can match its content using Unicode patterns (matcher engines internally normalizes ISO-8859-1 to UTF-8):</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(stdin, <a class="code" href="structreflex_1_1_input_1_1file__encoding.html#a1d77bb18dbc37d57df341f1878faa134">reflex::Input::file_encoding::latin</a>);</div><div class="line"><a class="code" href="classreflex_1_1_matcher.html">reflex::Matcher</a> matcher(pattern, input);</div></div><!-- fragment --><p>This sets the standard input encoding to ISO-8859-1, but only if no UTF BOM was detected on the standard input, because the UTF encoding of a <code>FILE*</code> that starts with a UTF BOM cannot be overruled.</p>
<p>Wide strings are internally converted to UTF-8 for matching, which effectively normalizes the input for matching with Unicode patterns. This conversion is illustrated below. The copyright symbol <code>©</code> with Unicode U+00A9 is matched against its UTF-8 sequence <code>C2 A9</code> of <code>©</code>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classreflex_1_1_matcher.html">reflex::Matcher</a>(<span class="stringliteral">&quot;©&quot;</span>, L<span class="stringliteral">&quot;©&quot;</span>).matches())</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;copyright symbol matches\n&quot;</span>;</div></div><!-- fragment --><p>To ensure that Unicode patterns in UTF-8 strings are grouped properly, use <a class="el" href="index.html#regex-convert">Regex converters </a>, for example as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="classreflex_1_1_pattern.html">reflex::Pattern</a> CR(<a class="code" href="classreflex_1_1_matcher.html#a8862686f6d5680d4d0e5af146c4aed69">reflex::Matcher::convert</a>(<span class="stringliteral">&quot;(?u:\u{00A9})&quot;</span>));</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="classreflex_1_1_matcher.html">reflex::Matcher</a>(CR, L<span class="stringliteral">&quot;©&quot;</span>).matches())</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;copyright symbol matches\n&quot;</span>;</div></div><!-- fragment --><p>Here we made the converted pattern static to avoid repeated conversion and construction overheads.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="regex-examples"></a>
Examples                                                      </h2>
<p>Some examples to demonstrate the concepts discussed.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h3>Example 1</h3>
<p>This example illustrates the <code>find</code> and <code>split</code> methods and iterators with a RE/flex <code><a class="el" href="classreflex_1_1_matcher.html" title="RE/flex matcher engine class, implements reflex::PatternMatcher pattern matching interface with scan...">reflex::Matcher</a></code> and a <code><a class="el" href="classreflex_1_1_boost_matcher.html" title="Boost matcher engine class implements reflex::PatternMatcher pattern matching interface with scan...">reflex::BoostMatcher</a></code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matcher_8h.html">reflex/matcher.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacereflex.html">reflex</a>;</div><div class="line"></div><div class="line"><span class="comment">// some random text (with extra spacing)</span></div><div class="line">std::string example(<span class="stringliteral">&quot;Monty\n Python&#39;s    Flying  Circus&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// construct a fixed pattern that is case insensitive</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="classreflex_1_1_pattern.html">Pattern</a> pattern(<span class="stringliteral">&quot;monty|python&quot;</span>, <span class="stringliteral">&quot;i&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// construct a matcher to search the example text</span></div><div class="line"><a class="code" href="classreflex_1_1_matcher.html">Matcher</a> matcher(pattern, example);</div><div class="line"><span class="keywordflow">while</span> (matcher.find() == <span class="keyword">true</span>)</div><div class="line">  std::cout &lt;&lt; matcher.text()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; matcher.lineno() &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; matcher.columno()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; spans &quot;</span> &lt;&lt; matcher.first() &lt;&lt; <span class="stringliteral">&quot;..&quot;</span> &lt;&lt; matcher.last()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// construct a Boost.Regex matcher to count the words (all non-spaces &quot;\S+&quot;)</span></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">BoostMatcher</a> boostmatcher(<span class="stringliteral">&quot;\\S+&quot;</span>, example);</div><div class="line">boostmatcher.buffer(); <span class="comment">// because Boost.Regex partial_match is broken!</span></div><div class="line">std::cout &lt;&lt; std::distance(boostmatcher.find.begin(), boostmatcher.find.end())</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; words&quot;</span></div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// reuse the BoostMatcher with a C++11 range-based loop to split the example text on space &quot;\s+&quot;:</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; split : boostmatcher.pattern(<span class="stringliteral">&quot;\\s+&quot;</span>).input(example).split)</div><div class="line">  std::cout &lt;&lt; split.text() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line">std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// reuse the BoostMatcher to split on whitespace using an iterator, sort into a set, and print</span></div><div class="line">boostmatcher.input(example).buffer();</div><div class="line">std::set&lt;std::string&gt; words(boostmatcher.split.begin(), boostmatcher.split.end());</div><div class="line">std::copy(words.begin(), words.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, <span class="stringliteral">&quot; &quot;</span>));</div><div class="line">std::cout &lt;&lt; std::endl;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">Monty at 1,0 spans 0..5
Python at 2,1 spans 7..13
4 words
Monty Python's Flying Circus
Circus Flying Monty Python's
</pre><p>🔝 <a href="#">Back to table of contents</a></p>
<h3>Example 2</h3>
<p>This example shows how a URL can be matched by using two patterns: one pattern to extract the host:port/path parts and another pattern to extract the query string key-value pairs in a loop.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacereflex.html">reflex</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *URL = <span class="stringliteral">&quot;...&quot;</span>;</div><div class="line"></div><div class="line"><span class="comment">// match URL host:port/path using group captures for these</span></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">BoostMatcher</a> re(<span class="stringliteral">&quot;https?://([^:/]*):?(\\d*)/?([^?#]*)&quot;</span>, URL);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (re.scan())</div><div class="line">{</div><div class="line">  <span class="comment">// found a partial match at start, now check if we have a host</span></div><div class="line">  <span class="keywordflow">if</span> (re[1].first != NULL)</div><div class="line">  {</div><div class="line">    std::string host(re[1].first, re[1].second);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;host: &quot;</span> &lt;&lt; host &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// check of we have a port</span></div><div class="line">    <span class="keywordflow">if</span> (re[2].first != NULL &amp;&amp; re[2].second != 0)</div><div class="line">    {</div><div class="line">      std::string port(re[2].first, re[2].second);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;port: &quot;</span> &lt;&lt; port &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// check of we have a path</span></div><div class="line">    <span class="keywordflow">if</span> (re[3].first != NULL &amp;&amp; re[3].second != 0)</div><div class="line">    {</div><div class="line">      std::string path(re[3].first, re[3].second);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;path: &quot;</span> &lt;&lt; path &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// check if we have a query string</span></div><div class="line">  <span class="keywordflow">if</span> (re.input() == <span class="charliteral">&#39;?&#39;</span>)</div><div class="line">  {</div><div class="line">    <span class="comment">// now switch patterns to match the query string</span></div><div class="line">    re.pattern(<span class="stringliteral">&quot;([^=&amp;]*)=?([^&amp;]*)&amp;?&quot;</span>);</div><div class="line">    <span class="keywordflow">while</span> (re.scan())</div><div class="line">      std::cout &lt;&lt;</div><div class="line">        <span class="stringliteral">&quot;query key: &quot;</span> &lt;&lt; std::string(re[1].first, re[1].second) &lt;&lt;</div><div class="line">        <span class="stringliteral">&quot;, value: &quot;</span> &lt;&lt; std::string(re[2].first, re[2].second) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!re.at_end())</div><div class="line">  {</div><div class="line">    <span class="comment">// not a query string and not the end, we expect an # anchor</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;anchor: &quot;</span> &lt;&lt; re.rest() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Error, not a http/s URL: &quot;</span> &lt;&lt; re.rest() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>🔝 <a href="#">Back to table of contents</a></p>
<h3>Example 3</h3>
<p>This example shows how input can be reassigned in each iteration of a loop that matches wide strings against a word pattern <code>\w+</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacereflex.html">reflex</a>;</div><div class="line"></div><div class="line"><span class="comment">// four words</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">wchar_t</span> *words[] = { L<span class="stringliteral">&quot;Monty&quot;</span>, L<span class="stringliteral">&quot;Python&#39;s&quot;</span>, L<span class="stringliteral">&quot;Flying&quot;</span>, L<span class="stringliteral">&quot;Circus&quot;</span> };</div><div class="line"></div><div class="line"><span class="comment">// construct a Boost.Regex matcher for words, given empty input initially</span></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">BoostMatcher</a> wordmatcher(<span class="stringliteral">&quot;\\w+&quot;</span>, <a class="code" href="classreflex_1_1_input.html">Input</a>());</div><div class="line"></div><div class="line"><span class="comment">// check if each string in words[] is a word</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; i++)</div><div class="line">  <span class="keywordflow">if</span> (wordmatcher.input(words[i]).matches() == <span class="keyword">true</span>)</div><div class="line">    std::cout &lt;&lt; wordmatcher.text() &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">Monty, Flying, Circus, 
</pre><p>🔝 <a href="#">Back to table of contents</a></p>
<h3>Example 4</h3>
<p>This example counts the number of words, lines, and chars from the <code>std::cin</code> stream:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdmatcher_8h.html">reflex/stdmatcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacereflex.html">reflex</a>;</div><div class="line"></div><div class="line"><span class="comment">// construct a std::regex matcher like the wc command (a word is a series of nonspaces)</span></div><div class="line"><a class="code" href="classreflex_1_1_std_matcher.html">StdMatcher</a> word(<span class="stringliteral">&quot;\\S+&quot;</span>, std::cin);</div><div class="line"></div><div class="line"><span class="keywordtype">size_t</span> words = std::distance(word.find.begin(), word.find.end());</div><div class="line"><span class="keywordtype">size_t</span> lines = word.lineno() - 1;</div><div class="line"><span class="keywordtype">size_t</span> chars = word.last();</div><div class="line"></div><div class="line">std::cout &lt;&lt; lines &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; words &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; chars &lt;&lt; std::endl;</div></div><!-- fragment --><p>🔝 <a href="#">Back to table of contents</a></p>
<h3>Example 5</h3>
<p>This example tokenizes a string by grouping the subpatterns in a regex and by using the group index of the capture obtained with <code>accept()</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matcher_8h.html">reflex/matcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacereflex.html">reflex</a>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="classreflex_1_1_pattern.html">Pattern</a> pattern =</div><div class="line">  <span class="stringliteral">&quot;(\\w*cat\\w*)|&quot;</span> <span class="comment">// 1st group = token 1</span></div><div class="line">  <span class="stringliteral">&quot;(\\w*dog\\w*)|&quot;</span> <span class="comment">// 2nd group = token 2</span></div><div class="line">  <span class="stringliteral">&quot;(\\w+)|&quot;</span>        <span class="comment">// 3rd group = token 3</span></div><div class="line">  <span class="stringliteral">&quot;(.)&quot;</span>;           <span class="comment">// 4th group = token 4</span></div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_matcher.html">Matcher</a> tokenizer(pattern, <span class="stringliteral">&quot;cats love hotdogs!&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; token : tokenizer.scan)</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Token = &quot;</span> &lt;&lt; token.accept()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;: matched &#39;&quot;</span> &lt;&lt; token.text() &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; with &#39;&quot;</span> &lt;&lt; token.pattern()[token.accept()] &lt;&lt; <span class="stringliteral">&quot;&#39;\n&quot;</span>;</div><div class="line">assert(tokenizer.at_end());</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">Token = 1: matched 'cats' with '(\\w*cat\\w*)'
Token = 4: matched ' ' with '(.)'
Token = 3: matched 'love' with '(\\w+)'
Token = 4: matched ' ' with '(.)'
Token = 2: matched 'hotdogs' with '(\\w*dog\\w*)'
Token = 4: matched '!' with '(.)'
</pre><p>🔝 <a href="#">Back to table of contents</a></p>
<h3>Example 6</h3>
<p>This example reads a file with embedded credit card numbers to extract. The numbers are sorted into five sets for each type of major credit card:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matcher_8h.html">reflex/matcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacereflex.html">reflex</a>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="classreflex_1_1_pattern.html">Pattern</a> card_patterns =</div><div class="line">  <span class="stringliteral">&quot;(?# MasterCard)(5[1-5]\\d{14})|&quot;</span>                   <span class="comment">// 1st group = MC</span></div><div class="line">  <span class="stringliteral">&quot;(?# Visa)(4\\d{12}(?:\\d{3})?)|&quot;</span>                   <span class="comment">// 2nd group = VISA</span></div><div class="line">  <span class="stringliteral">&quot;(?# AMEX)(3[47]\\d{13})|&quot;</span>                          <span class="comment">// 3rd group = AMEX</span></div><div class="line">  <span class="stringliteral">&quot;(?# Discover)(6011\\d{14})|&quot;</span>                       <span class="comment">// 4th group = Discover</span></div><div class="line">  <span class="stringliteral">&quot;(?# Diners Club)((?:30[0-5]|36\\d|38\\d)\\d{11})&quot;</span>; <span class="comment">// 5th group = Diners</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *card_data =</div><div class="line">  <span class="stringliteral">&quot;mark 5212345678901234\n&quot;</span></div><div class="line">  <span class="stringliteral">&quot;vinny 4123456789012\n&quot;</span></div><div class="line">  <span class="stringliteral">&quot;victor 4123456789012345\n&quot;</span></div><div class="line">  <span class="stringliteral">&quot;amy 371234567890123\n&quot;</span></div><div class="line">  <span class="stringliteral">&quot;dirk 601112345678901234\n&quot;</span></div><div class="line">  <span class="stringliteral">&quot;doc 38812345678901 end\n&quot;</span>;</div><div class="line"></div><div class="line">std::set&lt;std::string&gt; cards[5];</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; match : <a class="code" href="classreflex_1_1_matcher.html">Matcher</a>(card_patterns, card_file).find)</div><div class="line">  cards[match.accept() - 1].insert(match.text());</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; ++i)</div><div class="line">  <span class="keywordflow">for</span> (std::set&lt;std::string&gt;::const_iterator j = cards[i].begin(); j != cards[i].end(); ++j)</div><div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; *j &lt;&lt; std::endl;</div></div><!-- fragment --><p>When executed this code prints: </p><pre class="fragment">0: 5212345678901234
1: 4123456789012
1: 4123456789012345
2: 371234567890123
3: 601112345678901234
4: 38812345678901
</pre><p>🔝 <a href="#">Back to table of contents</a></p>
<h3>Example 7</h3>
<p>The RE/flex matcher engine <code>reflex::matcher</code> only recognizes group captures at the top level of the regex (i.e. among the top-level alternations), because it uses an efficient FSM for matching.</p>
<p>By contrast, the Boost.Regex matcher can capture groups within a regex, but the matcher is slower.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// a BoostMatcher to find &#39;TODO&#39; lines on stdin and capture their content to display</span></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;TODO ([^\\n]+)&quot;</span>, stdin);</div><div class="line">matcher.buffer(); <span class="comment">// because Boost.Regex partial_match is broken!</span></div><div class="line"><span class="keywordflow">while</span> (matcher.find())</div><div class="line">  std::cout</div><div class="line">    &lt;&lt; matcher.lineno() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div><div class="line">    &lt;&lt; std::string(matcher[1].first, matcher[1].second)</div><div class="line">    &lt;&lt; std::endl;</div></div><!-- fragment --><p>🔝 <a href="#">Back to table of contents</a></p>
<h3>Example 8</h3>
<p>This example shows how a <code>FILE*</code> file descriptor is used as input. The file encoding is obtained from the UTF BOM, when present in the file. Note that the file's state is accessed through the matcher's member variable <code>in</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="boostmatcher_8h.html">reflex/boostmatcher.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacereflex.html">reflex</a>;</div><div class="line"></div><div class="line"><a class="code" href="classreflex_1_1_boost_matcher.html">BoostMatcher</a> matcher(<span class="stringliteral">&quot;\\s+&quot;</span>, fopen(<span class="stringliteral">&quot;filename&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>));</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (matcher.in.file() != NULL &amp;&amp; matcher.in.good())</div><div class="line">{</div><div class="line">  <span class="keywordflow">switch</span> (matcher.in.file_encoding())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="structreflex_1_1_input_1_1file__encoding.html#a9f48fc525d274af1351fdde16b9e55e3">Input::file_encoding::plain</a>:   std::cout &lt;&lt; <span class="stringliteral">&quot;plain ASCII/binary/UTF-8&quot;</span>; <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="structreflex_1_1_input_1_1file__encoding.html#a1d77bb18dbc37d57df341f1878faa134">Input::file_encoding::latin</a>:   std::cout &lt;&lt; <span class="stringliteral">&quot;ASCII and Latin-1&quot;</span>;        <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="structreflex_1_1_input_1_1file__encoding.html#aa3d38a4be53b6d4401ddcd8734f93c64">Input::file_encoding::ebcdic</a>:  std::cout &lt;&lt; <span class="stringliteral">&quot;EBCDIC&quot;</span>;                   <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="structreflex_1_1_input_1_1file__encoding.html#a3fb02ae23658a5f18a9e1bd1edc7af61">Input::file_encoding::utf8</a>:    std::cout &lt;&lt; <span class="stringliteral">&quot;UTF-8 with BOM&quot;</span>;           <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="structreflex_1_1_input_1_1file__encoding.html#a384c11d51f3320424bf1d78b581d1e24">Input::file_encoding::utf16be</a>: std::cout &lt;&lt; <span class="stringliteral">&quot;UTF-16 big endian&quot;</span>;        <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="structreflex_1_1_input_1_1file__encoding.html#aa053fdac14b83ea2040ae500e06bbde5">Input::file_encoding::utf16le</a>: std::cout &lt;&lt; <span class="stringliteral">&quot;UTF-16 little endian&quot;</span>;     <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="structreflex_1_1_input_1_1file__encoding.html#a4c9c0952f934dff7970320f054d87244">Input::file_encoding::utf32be</a>: std::cout &lt;&lt; <span class="stringliteral">&quot;UTF-32 big endian&quot;</span>;        <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> <a class="code" href="structreflex_1_1_input_1_1file__encoding.html#a6dab80b13b986dd7d21dc59acf8a7325">Input::file_encoding::utf32le</a>: std::cout &lt;&lt; <span class="stringliteral">&quot;UTF-32 little endian&quot;</span>;     <span class="keywordflow">break</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; of &quot;</span> &lt;&lt; matcher.in.size() &lt;&lt; <span class="stringliteral">&quot; converted bytes to read\n&quot;</span>;</div><div class="line">  matcher.buffer(); <span class="comment">// because Boost.Regex partial_match is broken!</span></div><div class="line">  <span class="keywordflow">if</span> (matcher.split() == <span class="keyword">true</span>)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Starts with: &quot;</span> &lt;&lt; matcher.text() &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Rest of the file is: &quot;</span> &lt;&lt; matcher.rest();</div><div class="line">  fclose(matcher.in.file());</div><div class="line">}</div></div><!-- fragment --><p>The default encoding is <code>Input::file_encoding::plain</code> when no UTF BOM is detected at the start of the file, meaning that <code>Input::file_encoding::latin</code> and <code>Input::file_encoding::ebcdic</code> are never detected automatically as plain UTF-8 encoding is assumed. If you expect the source file to contain ISO-8859-1 then set the file encoding as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classreflex_1_1_input.html">reflex::Input</a> input(fopen(<span class="stringliteral">&quot;filename&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>), <a class="code" href="structreflex_1_1_input_1_1file__encoding.html#a1d77bb18dbc37d57df341f1878faa134">reflex::Input::file_encoding::latin</a>);</div><div class="line"><span class="keywordflow">if</span> (input.<a class="code" href="classreflex_1_1_input.html#a948d77cb9989bf0ca0ce99ac3afd8a33">file</a>() != NULL)</div><div class="line">{</div><div class="line">  <a class="code" href="classreflex_1_1_boost_matcher.html">reflex::BoostMatcher</a> matcher(<span class="stringliteral">&quot;\\s+&quot;</span>, input);</div><div class="line">  matcher.buffer(); <span class="comment">// because Boost.Regex partial_match is broken!</span></div><div class="line">  <span class="keywordflow">if</span> (matcher.split() == <span class="keyword">true</span>)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Starts with: &quot;</span> &lt;&lt; matcher.text() &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Rest of the file is: &quot;</span> &lt;&lt; matcher.rest();</div><div class="line">  fclose(input.<a class="code" href="classreflex_1_1_input.html#a948d77cb9989bf0ca0ce99ac3afd8a33">file</a>());</div><div class="line">}</div></div><!-- fragment --><p>This sets the file encoding to ISO-8859-1, but only if no UTF BOM was detected, because UTF encodings that start with a UTF BOM cannot be overruled.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h1><a class="anchor" id="tricks"></a>
Tips, tricks and gotchas                                              </h1>
<h2><a class="anchor" id="invalid-utf"></a>
Invalid UTF encodings                                            </h2>
<p>It may be tempting to write a pattern with <code>.</code> (dot) as a wildcard in a lexer specification, but beware that in Unicode mode with option <code>−−unicode</code> (global <code>%option unicode</code> or local <code>(?u:φ)</code>) the dot matches any code point, including code points outside of the valid Unicode character range and invalid overlong UTF-8. The reason for this design decision is that a lexer should support a "catch all else" rule to report errors in the input:</p>
<div class="alt"> <div class="fragment"><div class="line">.    std::cerr &lt;&lt; <span class="stringliteral">&quot;lexical error, full stop.&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --> </div><p>If dot in Unicode mode would be restrictive (which it is not), the action above will never be triggered when invalid input is encountered. Because all non-dot regex patterns are valid Unicode in RE/flex, it would be impossible to write a "catch all else" rule that catches input format errors!</p>
<p>The dot in Unicode mode is self-synchronizing and consumes text up to to the next ASCII or Unicode character.</p>
<p>To reject invalid UTF-8 input in regex patterns, make sure to avoid <code>.</code> (dot) and use <code>\p{Unicode}</code> or <code>\X</code> instead, and reserve dot to catch anything, including invalid UTF-8 and UTF-16 encodings.</p>
<p>Invalid UTF-16 is detected automatically by the <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> class and replaced with the <code>REFLEX_NONCHAR</code> code point U+200000 that lies outside the valid Unicode range. This code point is never matched by non-dot regex patterns and is easy to detect by a regex pattern with a dot.</p>
<p>Note that character classes written as bracket lists may produce invalid Unicode ranges when not used properly. This is not a problem for matching, but for rejecting surrogate halves that are invalid Unicode. For example, <code>[\u{00}-\u{10FFFF}]</code> obviously includes the invalid range of surrogate halves <code>[\u{D800}-\u{DFFF}]</code>. You can always remove surrogate halves from any character class by intersecting the class with <code>[\p{Unicode}]</code>, that is <code>[...&amp;&amp;[\p{Unicode}]]</code>. Furthermore, character class negation with <code>^</code> results in classes that are within range U+0000 to U+10FFFF and excludes surrogate halves.</p>
<p>🔝 <a href="#">Back to contents</a></p>
<h2><a class="anchor" id="lazy"></a>
Lazy repetitions                                                        </h2>
<p>Repetitions (<code>*</code>, <code>+</code>, and <code>{n,m}</code>) are greedy, unless marked with an extra <code>?</code> to make them lazy. Lazy repetitions are useless when the regex pattern after the lazy repetitions permits empty input. For example, <code>.*?a?</code> only matches one <code>a</code> or nothing at all, because <code>a?</code> permits an empty match.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="switching"></a>
Repeately switching to the same input                              </h2>
<p>The state of the input object <code><a class="el" href="classreflex_1_1_input.html" title="Input character sequence class for unified access to sources of input text. ">reflex::Input</a></code> changes as the scanner's matcher consumes more input. If you switch to the same input again (e.g. with <code>in(i)</code> or <code>switch_stream(i)</code> for input source <code>i</code>), a portion of that input may end up being discarded as part of the matcher's internal buffer that is flushed when input is assigned. Therefore, the following code will not work because stdin is flushed repeately:</p>
<div class="fragment"><div class="line">Lexer lexer(stdin);       <span class="comment">// a lexer that reads stdin</span></div><div class="line">lexer.in(stdin);          <span class="comment">// this is OK, nothing read yet</span></div><div class="line"><span class="keywordflow">while</span> (lexer.lex(stdin))  <span class="comment">// oops, assigning stdin again and again</span></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;we&#39;re not getting anywhere?&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>If you need to read a file or stream again, you must rewind it to the location in the file to start reading. Beware that <code>FILE*</code> input is checked against an UTF BOM at the start of a file, which means that you cannot reliably move to a location in the file to start reading when files are encoded in UTF-8 or UTF-16.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="flexlexer"></a>
Where is FlexLexer.h?                                              </h2>
<p>RE/flex uses its own header file <code><a class="el" href="flexlexer_8h.html" title="RE/flex Flex-compatible FlexLexer base class and Lex/Flex-compatible macros. ">reflex/flexlexer.h</a></code> for compatibility with Flex, instead of <code><a class="el" href="flexlexer_8h.html" title="RE/flex Flex-compatible FlexLexer base class and Lex/Flex-compatible macros. ">FlexLexer.h</a></code>. The latter is specific to Flex and cannot be used with RE/flex. You should not have to include <code><a class="el" href="flexlexer_8h.html" title="RE/flex Flex-compatible FlexLexer base class and Lex/Flex-compatible macros. ">FlexLexer.h</a></code> but if you do, use:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="flexlexer_8h.html">reflex/flexlexer.h</a>&gt;</span></div></div><!-- fragment --><p>The <code>FlexLexer</code> class defined in <code><a class="el" href="flexlexer_8h.html" title="RE/flex Flex-compatible FlexLexer base class and Lex/Flex-compatible macros. ">reflex/flexlexer.h</a></code> is the base class of the generated <code>yyFlexLexer</code> class.</p>
<p>🔝 <a href="#">Back to table of contents</a></p>
<h2><a class="anchor" id="readline"></a>
Interactive input with GNU readline                                 </h2>
<p>Option <code>-I</code> for interactive input generates a scanner that uses <code>fgetc()</code> to read input from a <code>FILE*</code> descriptor (stdin by default). Interactive input is made more user-friendly with the GNU readline library that provides basic line editing and a history mechanism.</p>
<p>To use <code>readline()</code> in your lexer, call <code>readline()</code> in your Lexer's constructor and in the <code>wrap()</code> method as follows:</p>
<div class="alt"> <div class="fragment"><div class="line">%top{</div><div class="line"><span class="preprocessor">  #include &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">  #include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">  #include &lt;readline/readline.h&gt;</span></div><div class="line"><span class="preprocessor">  #include &lt;readline/history.h&gt;</span></div><div class="line">%}</div><div class="line"></div><div class="line">%<span class="keyword">class</span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> *prompt;</div><div class="line">  <span class="comment">// we use wrap() to read the next line</span></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">int</span> wrap() {</div><div class="line">    <span class="keywordflow">if</span> (line)</div><div class="line">    {</div><div class="line">      free((<span class="keywordtype">void</span>*)line);</div><div class="line">      line = readline(prompt);</div><div class="line">      <span class="keywordflow">if</span> (line != NULL)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (*line)</div><div class="line">          add_history(line);</div><div class="line">        linen.assign(line).push_back(<span class="charliteral">&#39;\n&#39;</span>);</div><div class="line">        in(linen);</div><div class="line">      }</div><div class="line">    }</div><div class="line">    <span class="comment">// wrap() == 0 means OK: wrapped after EOF</span></div><div class="line">    <span class="keywordflow">return</span> line == NULL ? 1 : 0;</div><div class="line">  }</div><div class="line">  <span class="comment">// the line returned by readline() without \n</span></div><div class="line">  <span class="keywordtype">char</span> *line;</div><div class="line">  <span class="comment">// the line with \n appended</span></div><div class="line">  std::string linen;</div><div class="line">%}</div><div class="line"></div><div class="line">%init{</div><div class="line">  prompt = NULL;</div><div class="line">  line = readline(prompt);</div><div class="line">  <span class="keywordflow">if</span> (line != NULL)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (*line)</div><div class="line">      add_history(line);</div><div class="line">    linen.assign(line).push_back(<span class="charliteral">&#39;\n&#39;</span>);</div><div class="line">  }</div><div class="line">  in(linen);</div><div class="line">%}</div></div><!-- fragment --></div><div class="alt">With option <code>−−flex</code> you will need to replace <code>wrap()</code> by <code>yywrap()</code>.</div><div class="alt">The rules can be matched as usual, where <code>\n</code> matches the end of a line, for example:</div><div class="alt"><div class="alt"> <div class="fragment"><div class="line">%%</div><div class="line"></div><div class="line">.+  echo(); <span class="comment">// ECHO the entire line</span></div><div class="line">\n  echo(); <span class="comment">// ECHO end of the line</span></div><div class="line"></div><div class="line">%%</div></div><!-- fragment --></div></div><div class="alt"><div class="alt">🔝 <a href="#">Back to table of contents</a></div></div><div class="alt"><div class="alt"></div></div><h1><a class="anchor" id="download"></a>
Getting RE/flex                                                     </h1>
<div class="alt"><div class="alt"></div></div><div class="alt"><div class="alt">Download RE/flex from <a href="https://sourceforge.net/projects/re-flex">SourceForge</a> or visit the RE/flex <a href="https://github.com/Genivia/RE-flex">GitHub repository</a>.</div></div><div class="alt"><div class="alt">🔝 <a href="#">Back to table of contents</a></div></div><div class="alt"><div class="alt"></div></div><h1><a class="anchor" id="license"></a>
License and copyright                                                </h1>
<div class="alt"><div class="alt"></div></div><div class="alt"><div class="alt">RE/flex software is released under the BSD-3 license. All parts of the software have reasonable copyright terms permitting free redistribution. This includes the ability to reuse all or parts of the RE/flex source tree.</div></div><div class="alt"><div class="alt"><blockquote class="doxtable">
<p>Copyright (c) 2016, Robert van Engelen, Genivia Inc. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<p>(1) Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p>
<p>(2) Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p>
<p>(3) The name of the author may not be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</blockquote>
</div></div><div class="alt"><div class="alt">The Free Software Foundation maintains a <a href="http://directory.fsf.org/wiki/License:BSD_3Clause">BSD-3 License Wiki</a>.</div></div><div class="alt"><div class="alt">🔝 <a href="#">Back to table of contents</a></div></div><div class="alt"><div class="alt">Copyright (c) 2017, Robert van Engelen, Genivia Inc. All rights reserved. </div></div></div></div><!-- contents -->
<hr class="footer">
<address class="footer"><small>
Converted on Sun Apr 9 2017 21:47:01 by <a target="_blank" href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.11</small></address>
<br>
<div style="height: 246px; background: #DBDBDB;">
</body>
</html>
